{"version":3,"sources":["webpack:///component---src-pages-presale-js-43de458729672c028a91.js","webpack:///./~/moment-duration-format/lib/moment-duration-format.js?1e0c","webpack:///./~/moment/moment.js?cbd3","webpack:///./src/components/presale.js","webpack:///./src/components/timer.js?c914","webpack:///./src/images/ill_allocation.svg","webpack:///./src/images/timeline.svg","webpack:///./src/pages/presale.js"],"names":["webpackJsonp","170","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","undefined","momentDurationFormatSetup","moment","this","stringIncludes","str","search","length","indexOf","repeatZero","qty","result","stringRound","digits","digitsArray","split","reverse","i","carry","parseInt","toString","push","join","formatNumber","number","options","userLocale","useToLocaleString","useGrouping","grouping","slice","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","decimalSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","toLocaleStringRoundingWorks","roundingOptions","extend","parseFloat","toLocaleString","numberString","toPrecision","toFixed","integerString","fractionString","exponentString","temp","integerLength","fractionLength","digitCount","replace","exponent","Math","abs","formattedString","group","shift","durationLabelCompare","a","b","label","durationGetLabels","token","localeData","labels","each","keys","localeDataKey","labelType","toLowerCase","labelKey","type","key","durationPluralKey","integerValue","decimalValue","isArray","array","Object","prototype","call","isObject","obj","findLast","callback","index","find","match","max","item","map","ret","pluck","prop","compact","unique","_a","intersection","_b","rest","initial","reversed","hasOwnProperty","any","flatten","child","concat","toLocaleStringSupportsLocales","e","name","featureTestToLocaleStringRounding","featureTestToLocaleString","passed","durationsFormat","durations","args","arguments","settings","arg","template","precision","returnMomentTypes","formattedDurations","dur","format","outputTypes","types","largest","durationFormat","defaults","asMilliseconds","asMonths","isValid","isNegative","remainder","duration","remainderMonths","momentTokens","years","months","weeks","days","hours","minutes","seconds","milliseconds","tokenDefs","escape","general","typeMap","test","tokenizer","RegExp","source","stopTrim","engLocale","_durationTimeTemplates","locale","useLeftUnits","usePlural","forceLength","trunc","useSignificantDigits","significantDigits","significantDigitsCache","minValue","isMinValue","maxValue","isMaxValue","toLocaleStringWorks","trim","trimIncludes","rLarge","rSmall","rBoth","rMid","rAll","rFinal","trimLarge","trimSmall","trimMid","trimFinal","rawTokens","text","currentToken","tokens","momentTypes","momentType","rawValue","isSmallest","isLargest","as","wholeValue","floor","subtract","tokenLength","truncMethod","round","truncate","value","places","factor","pow","foundFirst","bubbled","formatValue","formatOptions","formattedValue","formattedValueEn","formattedValueMS","findType","bubbleTypes","bubble","bubbleMomentType","targets","target","targetMomentType","bubbles","outputType","values","pluralKey","autoLocalized","pluralizedLabels","_durationLabelTypes","string","sort","out","defaultFormatTemplate","_data","firstType","lastType","init","context","fn","updateLocale","durationLabelsStandard","S","SS","s","ss","m","mm","h","hh","d","dd","w","ww","M","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","38","global","hooks","hookCallback","setHookCallback","input","Array","isObjectEmpty","getOwnPropertyNames","k","isUndefined","isNumber","isDate","Date","arr","res","hasOwnProp","valueOf","createUTC","strict","createLocalOrUTC","utc","defaultParsingFlags","empty","unusedTokens","unusedInput","overflow","charsLeftOver","nullInput","invalidMonth","invalidFormat","userInvalidated","iso","parsedDateParts","meridiem","rfc2822","weekdayMismatch","getParsingFlags","_pf","_isValid","flags","parsedParts","some","isNowValid","isNaN","_d","getTime","invalidWeekday","_strict","bigHour","isFrozen","createInvalid","NaN","copyConfig","to","from","val","_isAMomentObject","_i","_f","_l","_tzm","_isUTC","_offset","_locale","momentProperties","Moment","config","updateInProgress","updateOffset","isMoment","absFloor","ceil","toInt","argumentForCoercion","coercedNumber","isFinite","compareArrays","array1","array2","dontConvert","len","min","lengthDiff","diffs","warn","msg","suppressDeprecationWarnings","console","deprecate","firstTime","deprecationHandler","Error","stack","deprecateSimple","deprecations","isFunction","Function","set","_config","_dayOfMonthOrdinalParseLenient","_dayOfMonthOrdinalParse","_ordinalParse","mergeConfigs","parentConfig","childConfig","Locale","calendar","mom","now","output","_calendar","longDateFormat","_longDateFormat","formatUpper","toUpperCase","invalidDate","_invalidDate","ordinal","_ordinal","relativeTime","withoutSuffix","isFuture","_relativeTime","pastFuture","diff","addUnitAlias","unit","shorthand","lowerCase","aliases","normalizeUnits","units","normalizeObjectUnits","inputObject","normalizedProp","normalizedInput","addUnitPriority","priority","priorities","getPrioritizedUnits","unitsObj","u","zeroFill","targetLength","forceSign","absNumber","zerosToFill","sign","substr","addFormatToken","padded","func","formatTokenFunctions","removeFormattingTokens","makeFormatFunction","formattingTokens","formatMoment","expandFormat","formatFunctions","replaceLongDateFormatTokens","localFormattingTokens","lastIndex","addRegexToken","regex","strictRegex","regexes","isStrict","getParseRegexForToken","unescapeFormat","regexEscape","matched","p1","p2","p3","p4","addParseToken","addWeekParseToken","_w","addTimeToArrayFromToken","daysInYear","year","isLeapYear","getIsLeapYear","makeGetSet","keepTime","set$1","get","month","date","daysInMonth","stringGet","stringSet","prioritized","mod","n","x","modMonth","localeMonths","_months","isFormat","MONTHS_IN_FORMAT","localeMonthsShort","_monthsShort","handleStrictParse","monthName","ii","llc","toLocaleLowerCase","_monthsParse","_longMonthsParse","_shortMonthsParse","monthsShort","localeMonthsParse","_monthsParseExact","setMonth","dayOfMonth","monthsParse","getSetMonth","getDaysInMonth","monthsShortRegex","computeMonthsParse","_monthsShortStrictRegex","_monthsShortRegex","defaultMonthsShortRegex","monthsRegex","_monthsStrictRegex","_monthsRegex","defaultMonthsRegex","cmpLenRev","shortPieces","longPieces","mixedPieces","createDate","ms","getFullYear","setFullYear","createUTCDate","UTC","getUTCFullYear","setUTCFullYear","firstWeekOffset","dow","doy","fwd","fwdlw","getUTCDay","dayOfYearFromWeeks","week","weekday","resYear","resDayOfYear","localWeekday","weekOffset","dayOfYear","weekOfYear","resWeek","weeksInYear","weekOffsetNext","localeWeek","_week","localeFirstDayOfWeek","localeFirstDayOfYear","getSetWeek","add","getSetISOWeek","parseWeekday","weekdaysParse","parseIsoWeekday","localeWeekdays","_weekdays","day","localeWeekdaysShort","_weekdaysShort","localeWeekdaysMin","_weekdaysMin","handleStrictParse$1","weekdayName","_weekdaysParse","_shortWeekdaysParse","_minWeekdaysParse","weekdaysMin","weekdaysShort","weekdays","localeWeekdaysParse","_weekdaysParseExact","_fullWeekdaysParse","getSetDayOfWeek","getDay","getSetLocaleDayOfWeek","getSetISODayOfWeek","weekdaysRegex","computeWeekdaysParse","_weekdaysStrictRegex","_weekdaysRegex","defaultWeekdaysRegex","weekdaysShortRegex","_weekdaysShortStrictRegex","_weekdaysShortRegex","defaultWeekdaysShortRegex","weekdaysMinRegex","_weekdaysMinStrictRegex","_weekdaysMinRegex","defaultWeekdaysMinRegex","minp","shortp","longp","minPieces","hFormat","kFormat","lowercase","matchMeridiem","_meridiemParse","localeIsPM","charAt","localeMeridiem","isLower","normalizeLocale","chooseLocale","names","j","next","loadLocale","oldLocale","locales","globalLocale","_abbr","code","getSetGlobalLocale","data","getLocale","defineLocale","baseConfig","abbr","parentLocale","localeFamilies","forEach","tmpLocale","listLocales","checkOverflow","MONTH","DATE","YEAR","HOUR","MINUTE","SECOND","MILLISECOND","_overflowDayOfYear","_overflowWeeks","WEEK","_overflowWeekday","WEEKDAY","c","currentDateArray","nowValue","_useUTC","getUTCMonth","getUTCDate","getMonth","getDate","configFromArray","currentDate","expectedWeekday","yearToUse","dayOfYearFromWeekInfo","_dayOfYear","_nextDay","setUTCMinutes","getUTCMinutes","weekYear","weekdayOverflow","GG","W","E","createLocal","curWeek","gg","configFromISO","l","allowTime","dateFormat","timeFormat","tzFormat","extendedIsoRegex","exec","basicIsoRegex","isoDates","isoTimes","tzRegex","configFromStringAndFormat","extractFromRFC2822Strings","yearStr","monthStr","dayStr","hourStr","minuteStr","secondStr","untruncateYear","defaultLocaleMonthsShort","preprocessRFC2822","checkWeekday","weekdayStr","parsedInput","weekdayProvided","defaultLocaleWeekdaysShort","weekdayActual","calculateOffset","obsOffset","militaryOffset","numOffset","obsOffsets","hm","configFromRFC2822","parsedArray","configFromString","aspNetJsonRegex","createFromInputFallback","ISO_8601","RFC_2822","skipped","stringLength","totalParsedInputLength","_meridiem","meridiemFixWrap","hour","isPm","meridiemHour","isPM","configFromStringAndArray","tempConfig","bestMoment","scoreToBeat","currentScore","score","configFromObject","minute","second","millisecond","createFromConfig","prepareConfig","preparse","configFromInput","isUTC","pickBy","moments","isDurationValid","ordering","unitHasDecimal","isValid$1","createInvalid$1","createDuration","Duration","quarters","quarter","_milliseconds","_days","_bubble","isDuration","absRound","offset","separator","utcOffset","offsetFromString","matcher","matches","chunk","parts","chunkOffset","cloneWithOffset","model","clone","setTime","local","getDateOffset","getTimezoneOffset","getSetOffset","keepLocalTime","keepMinutes","localAdjust","matchShortOffset","_changeInProgress","addSubtract","getSetZone","setOffsetToUTC","setOffsetToLocal","setOffsetToParsedOffset","tZone","matchOffset","hasAlignedHourOffset","isDaylightSavingTime","isDaylightSavingTimeShifted","_isDSTShifted","other","toArray","isLocal","isUtcOffset","isUtc","diffRes","aspNetRegex","isoRegex","parseIso","momentsDifference","inp","positiveMomentsDifference","base","isAfter","isBefore","createAdder","direction","period","tmp","isAdding","getCalendarFormat","myMoment","calendar$1","time","formats","sod","startOf","calendarFormat","localInput","endOf","isBetween","inclusivity","isSame","inputMs","isSameOrAfter","isSameOrBefore","asFloat","that","zoneDelta","monthDiff","anchor2","adjust","wholeMonthDiff","anchor","toISOString","keepOffset","toDate","inspect","zone","prefix","datetime","suffix","inputString","defaultFormatUtc","defaultFormat","postformat","humanize","fromNow","toNow","newLocaleData","isoWeekday","unix","toObject","toJSON","isValid$2","parsingFlags","invalidAt","creationData","addWeekYearFormatToken","getter","getSetWeekYear","getSetWeekYearHelper","getSetISOWeekYear","isoWeek","getISOWeeksInYear","getWeeksInYear","weekInfo","weeksTarget","setWeekAll","dayOfYearData","getSetQuarter","getSetDayOfYear","parseMs","getZoneAbbr","getZoneName","createUnix","createInZone","parseZone","preParsePostFormat","get$1","field","setter","listMonthsImpl","listWeekdaysImpl","localeSorted","listMonths","listMonthsShort","listWeekdays","listWeekdaysShort","listWeekdaysMin","mathAbs","addSubtract$1","add$1","subtract$1","absCeil","monthsFromDays","monthsToDays","daysToMonths","valueOf$1","makeAs","alias","clone$1","get$2","makeGetter","substituteTimeAgo","relativeTime$1","posNegDuration","thresholds","getSetRelativeTimeRounding","roundingFunction","getSetRelativeTimeThreshold","threshold","limit","withSuffix","toISOString$1","abs$1","Y","D","total","asSeconds","totalSign","ymSign","daysSign","hmsSign","fun","t","defaultCalendar","sameDay","nextDay","nextWeek","lastDay","lastWeek","sameElse","defaultLongDateFormat","LTS","LT","L","LL","LLL","LLLL","defaultInvalidDate","defaultOrdinal","defaultDayOfMonthOrdinalParse","defaultRelativeTime","future","past","match1","match2","match3","match4","match6","match1to2","match3to4","match5to6","match1to3","match1to4","match1to6","matchUnsigned","matchSigned","matchTimestamp","matchWord","parseTwoDigitYear","getSetYear","o","defaultLocaleMonths","defaultLocaleWeek","defaultLocaleWeekdays","defaultLocaleWeekdaysMin","kInput","_isPm","pos","pos1","pos2","defaultLocaleMeridiemParse","getSetHour","dayOfMonthOrdinalParse","meridiemParse","UT","GMT","EDT","EST","CDT","CST","MDT","MST","PDT","PST","prototypeMin","prototypeMax","invalid","lang","isoWeekYear","getSetDayOfMonth","getSetMinute","getSetSecond","getSetMillisecond","proto","isoWeeks","isoWeeksInYear","isDST","zoneAbbr","zoneName","dates","isDSTShifted","proto$1","firstDayOfYear","firstDayOfWeek","langData","asMinutes","asHours","asDays","asWeeks","asYears","proto$2","toIsoString","version","relativeTimeRounding","relativeTimeThreshold","HTML5_FMT","DATETIME_LOCAL","DATETIME_LOCAL_SECONDS","DATETIME_LOCAL_MS","TIME","TIME_SECONDS","TIME_MS","274","_interopRequireDefault","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_taggedTemplateLiteralLoose","strings","raw","_templateObject","_templateObject2","_templateObject3","_react","_react2","_styledComponents","_styledComponents2","_container","_container2","_sectionHeader","_sectionHeader2","_timeline","_timeline2","_ill_allocation","_ill_allocation2","_timer","Header","header","CrowdsaleInfo","div","Timeline","Presale","_React$Component","_temp","_this","_ret","_len","_key","state","thanks","email","_submit","event","preventDefault","encodeURIComponent","url","window","fetch","method","setState","_change","render","createElement","href","action","onSubmit","required","placeholder","onChange","src","width","Component","106","_moment","_moment2","_momentDurationFormat","_momentDurationFormat2","Timer","remaining","componentWillMount","_this2","tick","timer","setInterval","componentWillUnmount","clearInterval","props","653","682","p","284","_whitepaper","_whitepaper2","_presale","_presale2"],"mappings":"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","file":"component---src-pages-presale-js-43de458729672c028a91.js","sourcesContent":["webpackJsonp([115261235868047],{\n\n/***/ 170:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Moment Duration Format v2.2.2\n\t *  https://github.com/jsmreese/moment-duration-format\n\t *  Date: 2018-02-16\n\t *\n\t *  Duration format plugin function for the Moment.js library\n\t *  http://momentjs.com/\n\t *\n\t *  Copyright 2018 John Madhavan-Reese\n\t *  Released under the MIT license\n\t */\n\t\n\t(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        // Node. Does not work with strict CommonJS, but only CommonJS-like\n\t        // enviroments that support module.exports, like Node.\n\t        try {\n\t            module.exports = factory(require('moment'));\n\t        } catch (e) {\n\t            // If moment is not available, leave the setup up to the user.\n\t            // Like when using moment-timezone or similar moment-based package.\n\t            module.exports = factory;\n\t        }\n\t    }\n\t\n\t    if (root) {\n\t        // Globals.\n\t        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n\t    }\n\t})(this, function (moment) {\n\t    // `Number#tolocaleString` is tested on plugin initialization.\n\t    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n\t    // native function will be used to generate formatted output. If the feature\n\t    // test fails, the fallback format function internal to this plugin will be\n\t    // used.\n\t    var toLocaleStringWorks = false;\n\t\n\t    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n\t    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n\t    // If the rounding test fails and `toLocaleString` will be used for formatting,\n\t    // the plugin will \"pre-round\" number values using the fallback number format\n\t    // function before passing them to `toLocaleString` for final formatting.\n\t    var toLocaleStringRoundingWorks = false;\n\t\n\t    // Token type names in order of descending magnitude.\n\t    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\t\n\t    var bubbles = [\n\t        {\n\t            type: \"seconds\",\n\t            targets: [\n\t                { type: \"minutes\", value: 60 },\n\t                { type: \"hours\", value: 3600 },\n\t                { type: \"days\", value: 86400 },\n\t                { type: \"weeks\", value: 604800 },\n\t                { type: \"months\", value: 2678400 },\n\t                { type: \"years\", value: 31536000 }\n\t            ]\n\t        },\n\t        {\n\t            type: \"minutes\",\n\t            targets: [\n\t                { type: \"hours\", value: 60 },\n\t                { type: \"days\", value: 1440 },\n\t                { type: \"weeks\", value: 10080 },\n\t                { type: \"months\", value: 44640 },\n\t                { type: \"years\", value: 525600 }\n\t            ]\n\t        },\n\t        {\n\t            type: \"hours\",\n\t            targets: [\n\t                { type: \"days\", value: 24 },\n\t                { type: \"weeks\", value: 168 },\n\t                { type: \"months\", value: 744 },\n\t                { type: \"years\", value: 8760 }\n\t            ]\n\t        },\n\t        {\n\t            type: \"days\",\n\t            targets: [\n\t                { type: \"weeks\", value: 7 },\n\t                { type: \"months\", value: 31 },\n\t                { type: \"years\", value: 365 }\n\t            ]\n\t        },\n\t        {\n\t            type: \"months\",\n\t            targets: [\n\t                { type: \"years\", value: 12 }\n\t            ]\n\t        }\n\t    ];\n\t\n\t    // stringIncludes\n\t    function stringIncludes(str, search) {\n\t        if (search.length > str.length) {\n\t          return false;\n\t        }\n\t\n\t        return str.indexOf(search) !== -1;\n\t    }\n\t\n\t    // repeatZero(qty)\n\t    // Returns \"0\" repeated `qty` times.\n\t    // `qty` must be a integer >= 0.\n\t    function repeatZero(qty) {\n\t        var result = \"\";\n\t\n\t        while (qty) {\n\t            result += \"0\";\n\t            qty -= 1;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    function stringRound(digits) {\n\t        var digitsArray = digits.split(\"\").reverse();\n\t        var i = 0;\n\t        var carry = true;\n\t\n\t        while (carry && i < digitsArray.length) {\n\t            if (i) {\n\t                if (digitsArray[i] === \"9\") {\n\t                    digitsArray[i] = \"0\";\n\t                } else {\n\t                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n\t                    carry = false;\n\t                }\n\t            } else {\n\t                if (parseInt(digitsArray[i], 10) < 5) {\n\t                    carry = false;\n\t                }\n\t\n\t                digitsArray[i] = \"0\";\n\t            }\n\t\n\t            i += 1;\n\t        }\n\t\n\t        if (carry) {\n\t            digitsArray.push(\"1\");\n\t        }\n\t\n\t        return digitsArray.reverse().join(\"\");\n\t    }\n\t\n\t    // formatNumber\n\t    // Formats any number greater than or equal to zero using these options:\n\t    // - userLocale\n\t    // - useToLocaleString\n\t    // - useGrouping\n\t    // - grouping\n\t    // - maximumSignificantDigits\n\t    // - minimumIntegerDigits\n\t    // - fractionDigits\n\t    // - groupingSeparator\n\t    // - decimalSeparator\n\t    //\n\t    // `useToLocaleString` will use `toLocaleString` for formatting.\n\t    // `userLocale` option is passed through to `toLocaleString`.\n\t    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n\t    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n\t    function formatNumber(number, options, userLocale) {\n\t        var useToLocaleString = options.useToLocaleString;\n\t        var useGrouping = options.useGrouping;\n\t        var grouping = useGrouping && options.grouping.slice();\n\t        var maximumSignificantDigits = options.maximumSignificantDigits;\n\t        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n\t        var fractionDigits = options.fractionDigits || 0;\n\t        var groupingSeparator = options.groupingSeparator;\n\t        var decimalSeparator = options.decimalSeparator;\n\t\n\t        if (useToLocaleString && userLocale) {\n\t            var localeStringOptions = {\n\t                minimumIntegerDigits: minimumIntegerDigits,\n\t                useGrouping: useGrouping\n\t            };\n\t\n\t            if (fractionDigits) {\n\t                localeStringOptions.maximumFractionDigits = fractionDigits;\n\t                localeStringOptions.minimumFractionDigits = fractionDigits;\n\t            }\n\t\n\t            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n\t            // when maximumSignificantDigits is set. See #96.\n\t            if (maximumSignificantDigits && number > 0) {\n\t                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n\t            }\n\t\n\t            if (!toLocaleStringRoundingWorks) {\n\t                var roundingOptions = extend({}, options);\n\t                roundingOptions.useGrouping = false;\n\t                roundingOptions.decimalSeparator = \".\";\n\t                number = parseFloat(formatNumber(number, roundingOptions), 10);\n\t            }\n\t\n\t            return number.toLocaleString(userLocale, localeStringOptions);\n\t        }\n\t\n\t        var numberString;\n\t\n\t        // Add 1 to digit output length for floating point errors workaround. See below.\n\t        if (maximumSignificantDigits) {\n\t            numberString = number.toPrecision(maximumSignificantDigits + 1);\n\t        } else {\n\t            numberString = number.toFixed(fractionDigits + 1);\n\t        }\n\t\n\t        var integerString;\n\t        var fractionString;\n\t        var exponentString;\n\t\n\t        var temp = numberString.split(\"e\");\n\t\n\t        exponentString = temp[1] || \"\";\n\t\n\t        temp = temp[0].split(\".\");\n\t\n\t        fractionString = temp[1] || \"\";\n\t        integerString = temp[0] || \"\";\n\t\n\t        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n\t        // (3.55).toFixed(1); --> \"3.5\"\n\t        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n\t        // (123.55 - 120); --> 3.549999999999997\n\t        // (123.55 - 120).toFixed(2); --> \"3.55\"\n\t        // Round by examing the string output of the next digit.\n\t\n\t        // *************** Implement String Rounding here ***********************\n\t        // Check integerString + fractionString length of toPrecision before rounding.\n\t        // Check length of fractionString from toFixed output before rounding.\n\t        var integerLength = integerString.length;\n\t        var fractionLength = fractionString.length;\n\t        var digitCount = integerLength + fractionLength;\n\t        var digits = integerString + fractionString;\n\t\n\t        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n\t            // Round digits.\n\t            digits = stringRound(digits);\n\t\n\t            if (digits.length === digitCount + 1) {\n\t                integerLength = integerLength + 1;\n\t            }\n\t\n\t            // Discard final fractionDigit.\n\t            if (fractionLength) {\n\t                digits = digits.slice(0, -1);\n\t            }\n\t\n\t            // Separate integer and fraction.\n\t            integerString = digits.slice(0, integerLength);\n\t            fractionString = digits.slice(integerLength);\n\t        }\n\t\n\t        // Trim trailing zeroes from fractionString because toPrecision outputs\n\t        // precision, not significant digits.\n\t        if (maximumSignificantDigits) {\n\t            fractionString = fractionString.replace(/0*$/, \"\");\n\t        }\n\t\n\t        // Handle exponent.\n\t        var exponent = parseInt(exponentString, 10);\n\t\n\t        if (exponent > 0) {\n\t            if (fractionString.length <= exponent) {\n\t                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\t\n\t                integerString = integerString + fractionString;\n\t                fractionString = \"\";\n\t            } else {\n\t                integerString = integerString + fractionString.slice(0, exponent);\n\t                fractionString = fractionString.slice(exponent);\n\t            }\n\t        } else if (exponent < 0) {\n\t            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\t\n\t            integerString = \"0\";\n\t        }\n\t\n\t        if (!maximumSignificantDigits) {\n\t            // Trim or pad fraction when not using maximumSignificantDigits.\n\t            fractionString = fractionString.slice(0, fractionDigits);\n\t\n\t            if (fractionString.length < fractionDigits) {\n\t                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n\t            }\n\t\n\t            // Pad integer when using minimumIntegerDigits\n\t            // and not using maximumSignificantDigits.\n\t            if (integerString.length < minimumIntegerDigits) {\n\t                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n\t            }\n\t        }\n\t\n\t        var formattedString = \"\";\n\t\n\t        // Handle grouping.\n\t        if (useGrouping) {\n\t            temp = integerString;\n\t            var group;\n\t\n\t            while (temp.length) {\n\t                if (grouping.length) {\n\t                    group = grouping.shift();\n\t                }\n\t\n\t                if (formattedString) {\n\t                    formattedString = groupingSeparator + formattedString;\n\t                }\n\t\n\t                formattedString = temp.slice(-group) + formattedString;\n\t\n\t                temp = temp.slice(0, -group);\n\t            }\n\t        } else {\n\t            formattedString = integerString;\n\t        }\n\t\n\t        // Add decimalSeparator and fraction.\n\t        if (fractionString) {\n\t            formattedString = formattedString + decimalSeparator + fractionString;\n\t        }\n\t\n\t        return formattedString;\n\t    }\n\t\n\t    // durationLabelCompare\n\t    function durationLabelCompare(a, b) {\n\t        if (a.label.length > b.label.length) {\n\t            return -1;\n\t        }\n\t\n\t        if (a.label.length < b.label.length) {\n\t            return 1;\n\t        }\n\t\n\t        // a must be equal to b\n\t        return 0;\n\t    }\n\t\n\t    // durationGetLabels\n\t    function durationGetLabels(token, localeData) {\n\t        var labels = [];\n\t\n\t        each(keys(localeData), function (localeDataKey) {\n\t            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n\t                return;\n\t            }\n\t\n\t            var labelType = localeDataKey.slice(15).toLowerCase();\n\t\n\t            each(keys(localeData[localeDataKey]), function (labelKey) {\n\t                if (labelKey.slice(0, 1) === token) {\n\t                    labels.push({\n\t                        type: labelType,\n\t                        key: labelKey,\n\t                        label: localeData[localeDataKey][labelKey]\n\t                    });\n\t                }\n\t            });\n\t        });\n\t\n\t        return labels;\n\t    }\n\t\n\t    // durationPluralKey\n\t    function durationPluralKey(token, integerValue, decimalValue) {\n\t        // Singular for a value of `1`, but not for `1.0`.\n\t        if (integerValue === 1 && decimalValue === null) {\n\t            return token;\n\t        }\n\t\n\t        return token + token;\n\t    }\n\t\n\t    var engLocale = {\n\t        durationLabelsStandard: {\n\t            S: 'millisecond',\n\t            SS: 'milliseconds',\n\t            s: 'second',\n\t            ss: 'seconds',\n\t            m: 'minute',\n\t            mm: 'minutes',\n\t            h: 'hour',\n\t            hh: 'hours',\n\t            d: 'day',\n\t            dd: 'days',\n\t            w: 'week',\n\t            ww: 'weeks',\n\t            M: 'month',\n\t            MM: 'months',\n\t            y: 'year',\n\t            yy: 'years'\n\t        },\n\t        durationLabelsShort: {\n\t            S: 'msec',\n\t            SS: 'msecs',\n\t            s: 'sec',\n\t            ss: 'secs',\n\t            m: 'min',\n\t            mm: 'mins',\n\t            h: 'hr',\n\t            hh: 'hrs',\n\t            d: 'dy',\n\t            dd: 'dys',\n\t            w: 'wk',\n\t            ww: 'wks',\n\t            M: 'mo',\n\t            MM: 'mos',\n\t            y: 'yr',\n\t            yy: 'yrs'\n\t        },\n\t        durationTimeTemplates: {\n\t            HMS: 'h:mm:ss',\n\t            HM: 'h:mm',\n\t            MS: 'm:ss'\n\t        },\n\t        durationLabelTypes: [\n\t            { type: \"standard\", string: \"__\" },\n\t            { type: \"short\", string: \"_\" }\n\t        ],\n\t        durationPluralKey: durationPluralKey\n\t    };\n\t\n\t    // isArray\n\t    function isArray(array) {\n\t        return Object.prototype.toString.call(array) === \"[object Array]\";\n\t    }\n\t\n\t    // isObject\n\t    function isObject(obj) {\n\t        return Object.prototype.toString.call(obj) === \"[object Object]\";\n\t    }\n\t\n\t    // findLast\n\t    function findLast(array, callback) {\n\t        var index = array.length;\n\t\n\t        while (index -= 1) {\n\t            if (callback(array[index])) { return array[index]; }\n\t        }\n\t    }\n\t\n\t    // find\n\t    function find(array, callback) {\n\t        var index = 0;\n\t\n\t        var max = array && array.length || 0;\n\t\n\t        var match;\n\t\n\t        if (typeof callback !== \"function\") {\n\t            match = callback;\n\t            callback = function (item) {\n\t                return item === match;\n\t            };\n\t        }\n\t\n\t        while (index < max) {\n\t            if (callback(array[index])) { return array[index]; }\n\t            index += 1;\n\t        }\n\t    }\n\t\n\t    // each\n\t    function each(array, callback) {\n\t        var index = 0,\n\t            max = array.length;\n\t\n\t        if (!array || !max) { return; }\n\t\n\t        while (index < max) {\n\t            if (callback(array[index], index) === false) { return; }\n\t            index += 1;\n\t        }\n\t    }\n\t\n\t    // map\n\t    function map(array, callback) {\n\t        var index = 0,\n\t            max = array.length,\n\t            ret = [];\n\t\n\t        if (!array || !max) { return ret; }\n\t\n\t        while (index < max) {\n\t            ret[index] = callback(array[index], index);\n\t            index += 1;\n\t        }\n\t\n\t        return ret;\n\t    }\n\t\n\t    // pluck\n\t    function pluck(array, prop) {\n\t        return map(array, function (item) {\n\t            return item[prop];\n\t        });\n\t    }\n\t\n\t    // compact\n\t    function compact(array) {\n\t        var ret = [];\n\t\n\t        each(array, function (item) {\n\t            if (item) { ret.push(item); }\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    // unique\n\t    function unique(array) {\n\t        var ret = [];\n\t\n\t        each(array, function (_a) {\n\t            if (!find(ret, _a)) { ret.push(_a); }\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    // intersection\n\t    function intersection(a, b) {\n\t        var ret = [];\n\t\n\t        each(a, function (_a) {\n\t            each(b, function (_b) {\n\t                if (_a === _b) { ret.push(_a); }\n\t            });\n\t        });\n\t\n\t        return unique(ret);\n\t    }\n\t\n\t    // rest\n\t    function rest(array, callback) {\n\t        var ret = [];\n\t\n\t        each(array, function (item, index) {\n\t            if (!callback(item)) {\n\t                ret = array.slice(index);\n\t                return false;\n\t            }\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    // initial\n\t    function initial(array, callback) {\n\t        var reversed = array.slice().reverse();\n\t\n\t        return rest(reversed, callback).reverse();\n\t    }\n\t\n\t    // extend\n\t    function extend(a, b) {\n\t        for (var key in b) {\n\t            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n\t        }\n\t\n\t        return a;\n\t    }\n\t\n\t    // keys\n\t    function keys(a) {\n\t        var ret = [];\n\t\n\t        for (var key in a) {\n\t            if (a.hasOwnProperty(key)) { ret.push(key); }\n\t        }\n\t\n\t        return ret;\n\t    }\n\t\n\t    // any\n\t    function any(array, callback) {\n\t        var index = 0,\n\t            max = array.length;\n\t\n\t        if (!array || !max) { return false; }\n\t\n\t        while (index < max) {\n\t            if (callback(array[index], index) === true) { return true; }\n\t            index += 1;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    // flatten\n\t    function flatten(array) {\n\t        var ret = [];\n\t\n\t        each(array, function(child) {\n\t            ret = ret.concat(child);\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    function toLocaleStringSupportsLocales() {\n\t        var number = 0;\n\t        try {\n\t            number.toLocaleString('i');\n\t        } catch (e) {\n\t            return e.name === 'RangeError';\n\t        }\n\t        return false;\n\t    }\n\t\n\t    function featureTestToLocaleStringRounding() {\n\t        return (3.55).toLocaleString(\"en\", {\n\t            useGrouping: false,\n\t            minimumIntegerDigits: 1,\n\t            minimumFractionDigits: 1,\n\t            maximumFractionDigits: 1\n\t        }) === \"3.6\";\n\t    }\n\t\n\t    function featureTestToLocaleString() {\n\t        var passed = true;\n\t\n\t        // Test locale.\n\t        passed = passed && toLocaleStringSupportsLocales();\n\t        if (!passed) { return false; }\n\t\n\t        // Test minimumIntegerDigits.\n\t        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 1 }) === \"1\";\n\t        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 2 }) === \"01\";\n\t        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 3 }) === \"001\";\n\t        if (!passed) { return false; }\n\t\n\t        // Test maximumFractionDigits and minimumFractionDigits.\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n\t        if (!passed) { return false; }\n\t\n\t        // Test maximumSignificantDigits.\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 1 }) === \"100\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 2 }) === \"100\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 3 }) === \"100\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n\t        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n\t        if (!passed) { return false; }\n\t\n\t        // Test grouping.\n\t        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: true }) === \"1,000\";\n\t        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: false }) === \"1000\";\n\t        if (!passed) { return false; }\n\t\n\t        return true;\n\t    }\n\t\n\t    // durationsFormat(durations [, template] [, precision] [, settings])\n\t    function durationsFormat() {\n\t        var args = [].slice.call(arguments);\n\t        var settings = {};\n\t        var durations;\n\t\n\t        // Parse arguments.\n\t        each(args, function (arg, index) {\n\t            if (!index) {\n\t                if (!isArray(arg)) {\n\t                    throw \"Expected array as the first argument to durationsFormat.\";\n\t                }\n\t\n\t                durations = arg;\n\t            }\n\t\n\t            if (typeof arg === \"string\" || typeof arg === \"function\") {\n\t                settings.template = arg;\n\t                return;\n\t            }\n\t\n\t            if (typeof arg === \"number\") {\n\t                settings.precision = arg;\n\t                return;\n\t            }\n\t\n\t            if (isObject(arg)) {\n\t                extend(settings, arg);\n\t            }\n\t        });\n\t\n\t        if (!durations || !durations.length) {\n\t            return [];\n\t        }\n\t\n\t        settings.returnMomentTypes = true;\n\t\n\t        var formattedDurations = map(durations, function (dur) {\n\t            return dur.format(settings);\n\t        });\n\t\n\t        // Merge token types from all durations.\n\t        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\t\n\t        var largest = settings.largest;\n\t\n\t        if (largest) {\n\t            outputTypes = outputTypes.slice(0, largest);\n\t        }\n\t\n\t        settings.returnMomentTypes = false;\n\t        settings.outputTypes = outputTypes;\n\t\n\t        return map(durations, function (dur) {\n\t            return dur.format(settings);\n\t        });\n\t    }\n\t\n\t    // durationFormat([template] [, precision] [, settings])\n\t    function durationFormat() {\n\t\n\t        var args = [].slice.call(arguments);\n\t        var settings = extend({}, this.format.defaults);\n\t\n\t        // Keep a shadow copy of this moment for calculating remainders.\n\t        // Perform all calculations on positive duration value, handle negative\n\t        // sign at the very end.\n\t        var asMilliseconds = this.asMilliseconds();\n\t        var asMonths = this.asMonths();\n\t\n\t        // Treat invalid durations as having a value of 0 milliseconds.\n\t        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n\t            asMilliseconds = 0;\n\t            asMonths = 0;\n\t        }\n\t\n\t        var isNegative = asMilliseconds < 0;\n\t\n\t        // Two shadow copies are needed because of the way moment.js handles\n\t        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n\t        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n\t        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\t\n\t        // Parse arguments.\n\t        each(args, function (arg) {\n\t            if (typeof arg === \"string\" || typeof arg === \"function\") {\n\t                settings.template = arg;\n\t                return;\n\t            }\n\t\n\t            if (typeof arg === \"number\") {\n\t                settings.precision = arg;\n\t                return;\n\t            }\n\t\n\t            if (isObject(arg)) {\n\t                extend(settings, arg);\n\t            }\n\t        });\n\t\n\t        var momentTokens = {\n\t            years: \"y\",\n\t            months: \"M\",\n\t            weeks: \"w\",\n\t            days: \"d\",\n\t            hours: \"h\",\n\t            minutes: \"m\",\n\t            seconds: \"s\",\n\t            milliseconds: \"S\"\n\t        };\n\t\n\t        var tokenDefs = {\n\t            escape: /\\[(.+?)\\]/,\n\t            years: /\\*?[Yy]+/,\n\t            months: /\\*?M+/,\n\t            weeks: /\\*?[Ww]+/,\n\t            days: /\\*?[Dd]+/,\n\t            hours: /\\*?[Hh]+/,\n\t            minutes: /\\*?m+/,\n\t            seconds: /\\*?s+/,\n\t            milliseconds: /\\*?S+/,\n\t            general: /.+?/\n\t        };\n\t\n\t        // Types array is available in the template function.\n\t        settings.types = types;\n\t\n\t        var typeMap = function (token) {\n\t            return find(types, function (type) {\n\t                return tokenDefs[type].test(token);\n\t            });\n\t        };\n\t\n\t        var tokenizer = new RegExp(map(types, function (type) {\n\t            return tokenDefs[type].source;\n\t        }).join(\"|\"), \"g\");\n\t\n\t        // Current duration object is available in the template function.\n\t        settings.duration = this;\n\t\n\t        // Eval template function and cache template string.\n\t        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\t\n\t        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\t\n\t        // outputTypes is an array of moment token types that determines\n\t        // the tokens returned in formatted output. This option overrides\n\t        // trim, largest, stopTrim, etc.\n\t        var outputTypes = settings.outputTypes;\n\t\n\t        // returnMomentTypes is a boolean that sets durationFormat to return\n\t        // the processed momentTypes instead of formatted output.\n\t        var returnMomentTypes = settings.returnMomentTypes;\n\t\n\t        var largest = settings.largest;\n\t\n\t        // Setup stopTrim array of token types.\n\t        var stopTrim = [];\n\t\n\t        if (!outputTypes) {\n\t            if (isArray(settings.stopTrim)) {\n\t                settings.stopTrim = settings.stopTrim.join(\"\");\n\t            }\n\t\n\t            // Parse stopTrim string to create token types array.\n\t            if (settings.stopTrim) {\n\t                each(settings.stopTrim.match(tokenizer), function (token) {\n\t                    var type = typeMap(token);\n\t\n\t                    if (type === \"escape\" || type === \"general\") {\n\t                        return;\n\t                    }\n\t\n\t                    stopTrim.push(type);\n\t                });\n\t            }\n\t        }\n\t\n\t        // Cache moment's locale data.\n\t        var localeData = moment.localeData();\n\t\n\t        if (!localeData) {\n\t            localeData = {};\n\t        }\n\t\n\t        // Fall back to this plugin's `eng` extension.\n\t        each(keys(engLocale), function (key) {\n\t            if (typeof engLocale[key] === \"function\") {\n\t                if (!localeData[key]) {\n\t                    localeData[key] = engLocale[key];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (!localeData[\"_\" + key]) {\n\t                localeData[\"_\" + key] = engLocale[key];\n\t            }\n\t        });\n\t\n\t        // Replace Duration Time Template strings.\n\t        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n\t        each(keys(localeData._durationTimeTemplates), function (item) {\n\t            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n\t        });\n\t\n\t        // Determine user's locale.\n\t        var userLocale = settings.userLocale || moment.locale();\n\t\n\t        var useLeftUnits = settings.useLeftUnits;\n\t        var usePlural = settings.usePlural;\n\t        var precision = settings.precision;\n\t        var forceLength = settings.forceLength;\n\t        var useGrouping = settings.useGrouping;\n\t        var trunc = settings.trunc;\n\t\n\t        // Use significant digits only when precision is greater than 0.\n\t        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n\t        var significantDigits = useSignificantDigits ? settings.precision : 0;\n\t        var significantDigitsCache = significantDigits;\n\t\n\t        var minValue = settings.minValue;\n\t        var isMinValue = false;\n\t\n\t        var maxValue = settings.maxValue;\n\t        var isMaxValue = false;\n\t\n\t        // formatNumber fallback options.\n\t        var useToLocaleString = settings.useToLocaleString;\n\t        var groupingSeparator = settings.groupingSeparator;\n\t        var decimalSeparator = settings.decimalSeparator;\n\t        var grouping = settings.grouping;\n\t\n\t        useToLocaleString = useToLocaleString && toLocaleStringWorks;\n\t\n\t        // Trim options.\n\t        var trim = settings.trim;\n\t\n\t        if (isArray(trim)) {\n\t            trim = trim.join(\" \");\n\t        }\n\t\n\t        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n\t            trim = \"all\";\n\t        }\n\t\n\t        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n\t            trim = \"large\";\n\t        }\n\t\n\t        if (trim === false) {\n\t            trim = \"\";\n\t        }\n\t\n\t        var trimIncludes = function (item) {\n\t            return item.test(trim);\n\t        };\n\t\n\t        var rLarge = /large/;\n\t        var rSmall = /small/;\n\t        var rBoth = /both/;\n\t        var rMid = /mid/;\n\t        var rAll = /^all|[^sm]all/;\n\t        var rFinal = /final/;\n\t\n\t        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n\t        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n\t        var trimMid = any([rMid, rAll], trimIncludes);\n\t        var trimFinal = any([rFinal, rAll], trimIncludes);\n\t\n\t        // Parse format string to create raw tokens array.\n\t        var rawTokens = map(template.match(tokenizer), function (token, index) {\n\t            var type = typeMap(token);\n\t\n\t            if (token.slice(0, 1) === \"*\") {\n\t                token = token.slice(1);\n\t\n\t                if (type !== \"escape\" && type !== \"general\") {\n\t                    stopTrim.push(type);\n\t                }\n\t            }\n\t\n\t            return {\n\t                index: index,\n\t                length: token.length,\n\t                text: \"\",\n\t\n\t                // Replace escaped tokens with the non-escaped token text.\n\t                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\t\n\t                // Ignore type on non-moment tokens.\n\t                type: ((type === \"escape\" || type === \"general\") ? null : type)\n\t            };\n\t        });\n\t\n\t        // Associate text tokens with moment tokens.\n\t        var currentToken = {\n\t            index: 0,\n\t            length: 0,\n\t            token: \"\",\n\t            text: \"\",\n\t            type: null\n\t        };\n\t\n\t        var tokens = [];\n\t\n\t        if (useLeftUnits) {\n\t            rawTokens.reverse();\n\t        }\n\t\n\t        each(rawTokens, function (token) {\n\t            if (token.type) {\n\t                if (currentToken.type || currentToken.text) {\n\t                    tokens.push(currentToken);\n\t                }\n\t\n\t                currentToken = token;\n\t\n\t                return;\n\t            }\n\t\n\t            if (useLeftUnits) {\n\t                currentToken.text = token.token + currentToken.text;\n\t            } else {\n\t                currentToken.text += token.token;\n\t            }\n\t        });\n\t\n\t        if (currentToken.type || currentToken.text) {\n\t            tokens.push(currentToken);\n\t        }\n\t\n\t        if (useLeftUnits) {\n\t            tokens.reverse();\n\t        }\n\t\n\t        // Find unique moment token types in the template in order of\n\t        // descending magnitude.\n\t        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\t\n\t        // Exit early if there are no moment token types.\n\t        if (!momentTypes.length) {\n\t            return pluck(tokens, \"text\").join(\"\");\n\t        }\n\t\n\t        // Calculate values for each moment type in the template.\n\t        // For processing the settings, values are associated with moment types.\n\t        // Values will be assigned to tokens at the last step in order to\n\t        // assume nothing about frequency or order of tokens in the template.\n\t        momentTypes = map(momentTypes, function (momentType, index) {\n\t            // Is this the least-magnitude moment token found?\n\t            var isSmallest = ((index + 1) === momentTypes.length);\n\t\n\t            // Is this the greatest-magnitude moment token found?\n\t            var isLargest = (!index);\n\t\n\t            // Get the raw value in the current units.\n\t            var rawValue;\n\t\n\t            if (momentType === \"years\" || momentType === \"months\") {\n\t                rawValue = remainderMonths.as(momentType);\n\t            } else {\n\t                rawValue = remainder.as(momentType);\n\t            }\n\t\n\t            var wholeValue = Math.floor(rawValue);\n\t            var decimalValue = rawValue - wholeValue;\n\t\n\t            var token = find(tokens, function (token) {\n\t                return momentType === token.type;\n\t            });\n\t\n\t            if (isLargest && maxValue && rawValue > maxValue) {\n\t                isMaxValue = true;\n\t            }\n\t\n\t            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n\t                isMinValue = true;\n\t            }\n\t\n\t            // Note the length of the largest-magnitude moment token:\n\t            // if it is greater than one and forceLength is not set,\n\t            // then default forceLength to `true`.\n\t            //\n\t            // Rationale is this: If the template is \"h:mm:ss\" and the\n\t            // moment value is 5 minutes, the user-friendly output is\n\t            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n\t            // even though it has length of two if the template is \"h:mm:ss\";\n\t            //\n\t            // If the minutes output should always include the leading zero\n\t            // even when the hour is trimmed then set `{ forceLength: true }`\n\t            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n\t            // clearly wanted everything padded so we should output \"05:00\";\n\t            //\n\t            // If the user wants the full padded output, they can use\n\t            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n\t            // \"00:05:00\".\n\t            if (isLargest && forceLength === null && token.length > 1) {\n\t                forceLength = true;\n\t            }\n\t\n\t            // Update remainder.\n\t            remainder.subtract(wholeValue, momentType);\n\t            remainderMonths.subtract(wholeValue, momentType);\n\t\n\t            return {\n\t                rawValue: rawValue,\n\t                wholeValue: wholeValue,\n\t                // Decimal value is only retained for the least-magnitude\n\t                // moment type in the format template.\n\t                decimalValue: isSmallest ? decimalValue : 0,\n\t                isSmallest: isSmallest,\n\t                isLargest: isLargest,\n\t                type: momentType,\n\t                // Tokens can appear multiple times in a template string,\n\t                // but all instances must share the same length.\n\t                tokenLength: token.length\n\t            };\n\t        });\n\t\n\t        var truncMethod = trunc ? Math.floor : Math.round;\n\t        var truncate = function (value, places) {\n\t            var factor = Math.pow(10, places);\n\t            return truncMethod(value * factor) / factor;\n\t        };\n\t\n\t        var foundFirst = false;\n\t        var bubbled = false;\n\t\n\t        var formatValue = function (momentType, index) {\n\t            var formatOptions = {\n\t                useGrouping: useGrouping,\n\t                groupingSeparator: groupingSeparator,\n\t                decimalSeparator: decimalSeparator,\n\t                grouping: grouping,\n\t                useToLocaleString: useToLocaleString\n\t            };\n\t\n\t            if (useSignificantDigits) {\n\t                if (significantDigits <= 0) {\n\t                    momentType.rawValue = 0;\n\t                    momentType.wholeValue = 0;\n\t                    momentType.decimalValue = 0;\n\t                } else {\n\t                    formatOptions.maximumSignificantDigits = significantDigits;\n\t                    momentType.significantDigits = significantDigits;\n\t                }\n\t            }\n\t\n\t            if (isMaxValue && !bubbled) {\n\t                if (momentType.isLargest) {\n\t                    momentType.wholeValue = maxValue;\n\t                    momentType.decimalValue = 0;\n\t                } else {\n\t                    momentType.wholeValue = 0;\n\t                    momentType.decimalValue = 0;\n\t                }\n\t            }\n\t\n\t            if (isMinValue && !bubbled) {\n\t                if (momentType.isSmallest) {\n\t                    momentType.wholeValue = minValue;\n\t                    momentType.decimalValue = 0;\n\t                } else {\n\t                    momentType.wholeValue = 0;\n\t                    momentType.decimalValue = 0;\n\t                }\n\t            }\n\t\n\t            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n\t                // Apply precision to least significant token value.\n\t                if (precision < 0) {\n\t                    momentType.value = truncate(momentType.wholeValue, precision);\n\t                } else if (precision === 0) {\n\t                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n\t                } else { // precision > 0\n\t                    if (useSignificantDigits) {\n\t                        if (trunc) {\n\t                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n\t                        } else {\n\t                            momentType.value = momentType.rawValue;\n\t                        }\n\t\n\t                        if (momentType.wholeValue) {\n\t                            significantDigits -= momentType.wholeValue.toString().length;\n\t                        }\n\t                    } else {\n\t                        formatOptions.fractionDigits = precision;\n\t\n\t                        if (trunc) {\n\t                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n\t                        } else {\n\t                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                if (useSignificantDigits && momentType.wholeValue) {\n\t                    // Outer Math.round required here to handle floating point errors.\n\t                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\t\n\t                    significantDigits -= momentType.wholeValue.toString().length;\n\t                } else {\n\t                    momentType.value = momentType.wholeValue;\n\t                }\n\t            }\n\t\n\t            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n\t                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\t\n\t                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n\t                    delete formatOptions.maximumSignificantDigits;\n\t                }\n\t            }\n\t\n\t            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n\t                foundFirst = true;\n\t            }\n\t\n\t            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\t\n\t            formatOptions.useGrouping = false;\n\t            formatOptions.decimalSeparator = \".\";\n\t            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\t\n\t            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n\t                momentType.formattedValueMS = formatNumber(momentType.value, {\n\t                    minimumIntegerDigits: 3,\n\t                    useGrouping: false\n\t                }, \"en\").slice(0, 2);\n\t            }\n\t\n\t            return momentType;\n\t        };\n\t\n\t        // Calculate formatted values.\n\t        momentTypes = map(momentTypes, formatValue);\n\t        momentTypes = compact(momentTypes);\n\t\n\t        // Bubble rounded values.\n\t        if (momentTypes.length > 1) {\n\t            var findType = function (type) {\n\t                return find(momentTypes, function (momentType) {\n\t                    return momentType.type === type;\n\t                });\n\t            };\n\t\n\t            var bubbleTypes = function (bubble) {\n\t                var bubbleMomentType = findType(bubble.type);\n\t\n\t                if (!bubbleMomentType) {\n\t                    return;\n\t                }\n\t\n\t                each(bubble.targets, function (target) {\n\t                    var targetMomentType = findType(target.type);\n\t\n\t                    if (!targetMomentType) {\n\t                        return;\n\t                    }\n\t\n\t                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n\t                        bubbleMomentType.rawValue = 0;\n\t                        bubbleMomentType.wholeValue = 0;\n\t                        bubbleMomentType.decimalValue = 0;\n\t                        targetMomentType.rawValue += 1;\n\t                        targetMomentType.wholeValue += 1;\n\t                        targetMomentType.decimalValue = 0;\n\t                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n\t                        bubbled = true;\n\t                    }\n\t                });\n\t            };\n\t\n\t            each(bubbles, bubbleTypes);\n\t        }\n\t\n\t        // Recalculate formatted values.\n\t        if (bubbled) {\n\t            foundFirst = false;\n\t            significantDigits = significantDigitsCache;\n\t            momentTypes = map(momentTypes, formatValue);\n\t            momentTypes = compact(momentTypes);\n\t        }\n\t\n\t        if (outputTypes && !(isMaxValue && !settings.trim)) {\n\t            momentTypes = map(momentTypes, function (momentType) {\n\t                if (find(outputTypes, function (outputType) {\n\t                    return momentType.type === outputType;\n\t                })) {\n\t                    return momentType;\n\t                }\n\t\n\t                return null;\n\t            });\n\t\n\t            momentTypes = compact(momentTypes);\n\t        } else {\n\t            // Trim Large.\n\t            if (trimLarge) {\n\t                momentTypes = rest(momentTypes, function (momentType) {\n\t                    // Stop trimming on:\n\t                    // - the smallest moment type\n\t                    // - a type marked for stopTrim\n\t                    // - a type that has a whole value\n\t                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n\t                });\n\t            }\n\t\n\t            // Largest.\n\t            if (largest && momentTypes.length) {\n\t                momentTypes = momentTypes.slice(0, largest);\n\t            }\n\t\n\t            // Trim Small.\n\t            if (trimSmall && momentTypes.length > 1) {\n\t                momentTypes = initial(momentTypes, function (momentType) {\n\t                    // Stop trimming on:\n\t                    // - a type marked for stopTrim\n\t                    // - a type that has a whole value\n\t                    // - the largest momentType\n\t                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n\t                });\n\t            }\n\t\n\t            // Trim Mid.\n\t            if (trimMid) {\n\t                momentTypes = map(momentTypes, function (momentType, index) {\n\t                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n\t                        return null;\n\t                    }\n\t\n\t                    return momentType;\n\t                });\n\t\n\t                momentTypes = compact(momentTypes);\n\t            }\n\t\n\t            // Trim Final.\n\t            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n\t                momentTypes = [];\n\t            }\n\t        }\n\t\n\t        if (returnMomentTypes) {\n\t            return momentTypes;\n\t        }\n\t\n\t        // Localize and pluralize unit labels.\n\t        each(tokens, function (token) {\n\t            var key = momentTokens[token.type];\n\t\n\t            var momentType = find(momentTypes, function (momentType) {\n\t                return momentType.type === token.type;\n\t            });\n\t\n\t            if (!key || !momentType) {\n\t                return;\n\t            }\n\t\n\t            var values = momentType.formattedValueEn.split(\".\");\n\t\n\t            values[0] = parseInt(values[0], 10);\n\t\n\t            if (values[1]) {\n\t                values[1] = parseFloat(\"0.\" + values[1], 10);\n\t            } else {\n\t                values[1] = null;\n\t            }\n\t\n\t            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\t\n\t            var labels = durationGetLabels(key, localeData);\n\t\n\t            var autoLocalized = false;\n\t\n\t            var pluralizedLabels = {};\n\t\n\t            // Auto-Localized unit labels.\n\t            each(localeData._durationLabelTypes, function (labelType) {\n\t                var label = find(labels, function (label) {\n\t                    return label.type === labelType.type && label.key === pluralKey;\n\t                });\n\t\n\t                if (label) {\n\t                    pluralizedLabels[label.type] = label.label;\n\t\n\t                    if (stringIncludes(token.text, labelType.string)) {\n\t                        token.text = token.text.replace(labelType.string, label.label);\n\t                        autoLocalized = true;\n\t                    }\n\t                }\n\t            });\n\t\n\t            // Auto-pluralized unit labels.\n\t            if (usePlural && !autoLocalized) {\n\t                labels.sort(durationLabelCompare);\n\t\n\t                each(labels, function (label) {\n\t                    if (pluralizedLabels[label.type] === label.label) {\n\t                        if (stringIncludes(token.text, label.label)) {\n\t                            // Stop checking this token if its label is already\n\t                            // correctly pluralized.\n\t                            return false;\n\t                        }\n\t\n\t                        // Skip this label if it is correct, but not present in\n\t                        // the token's text.\n\t                        return;\n\t                    }\n\t\n\t                    if (stringIncludes(token.text, label.label)) {\n\t                        // Replece this token's label and stop checking.\n\t                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n\t                        return false;\n\t                    }\n\t                });\n\t            }\n\t        });\n\t\n\t        // Build ouptut.\n\t        tokens = map(tokens, function (token) {\n\t            if (!token.type) {\n\t                return token.text;\n\t            }\n\t\n\t            var momentType = find(momentTypes, function (momentType) {\n\t                return momentType.type === token.type;\n\t            });\n\t\n\t            if (!momentType) {\n\t                return \"\";\n\t            }\n\t\n\t            var out = \"\";\n\t\n\t            if (useLeftUnits) {\n\t                out += token.text;\n\t            }\n\t\n\t            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n\t                out += \"< \";\n\t                isMaxValue = false;\n\t                isMinValue = false;\n\t            }\n\t\n\t            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n\t                out += \"> \";\n\t                isMaxValue = false;\n\t                isMinValue = false;\n\t            }\n\t\n\t            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n\t                out += \"-\";\n\t                isNegative = false;\n\t            }\n\t\n\t            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n\t                out += momentType.formattedValueMS;\n\t            } else {\n\t                out += momentType.formattedValue;\n\t            }\n\t\n\t            if (!useLeftUnits) {\n\t                out += token.text;\n\t            }\n\t\n\t            return out;\n\t        });\n\t\n\t        // Trim leading and trailing comma, space, colon, and dot.\n\t        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n\t    }\n\t\n\t    // defaultFormatTemplate\n\t    function defaultFormatTemplate() {\n\t        var dur = this.duration;\n\t\n\t        var findType = function findType(type) {\n\t            return dur._data[type];\n\t        };\n\t\n\t        var firstType = find(this.types, findType);\n\t\n\t        var lastType = findLast(this.types, findType);\n\t\n\t        // Default template strings for each duration dimension type.\n\t        switch (firstType) {\n\t            case \"milliseconds\":\n\t                return \"S __\";\n\t            case \"seconds\": // Fallthrough.\n\t            case \"minutes\":\n\t                return \"*_MS_\";\n\t            case \"hours\":\n\t                return \"_HMS_\";\n\t            case \"days\": // Possible Fallthrough.\n\t                if (firstType === lastType) {\n\t                    return \"d __\";\n\t                }\n\t            case \"weeks\":\n\t                if (firstType === lastType) {\n\t                    return \"w __\";\n\t                }\n\t\n\t                if (this.trim === null) {\n\t                    this.trim = \"both\";\n\t                }\n\t\n\t                return \"w __, d __, h __\";\n\t            case \"months\": // Possible Fallthrough.\n\t                if (firstType === lastType) {\n\t                    return \"M __\";\n\t                }\n\t            case \"years\":\n\t                if (firstType === lastType) {\n\t                    return \"y __\";\n\t                }\n\t\n\t                if (this.trim === null) {\n\t                    this.trim = \"both\";\n\t                }\n\t\n\t                return \"y __, M __, d __\";\n\t            default:\n\t                if (this.trim === null) {\n\t                    this.trim = \"both\";\n\t                }\n\t\n\t                return \"y __, d __, h __, m __, s __\";\n\t        }\n\t    }\n\t\n\t    // init\n\t    function init(context) {\n\t        if (!context) {\n\t            throw \"Moment Duration Format init cannot find moment instance.\";\n\t        }\n\t\n\t        context.duration.format = durationsFormat;\n\t        context.duration.fn.format = durationFormat;\n\t\n\t        context.duration.fn.format.defaults = {\n\t            // Many options are defaulted to `null` to distinguish between\n\t            // 'not set' and 'set to `false`'\n\t\n\t            // trim\n\t            // Can be a string, a delimited list of strings, an array of strings,\n\t            // or a boolean.\n\t            // \"large\" - will trim largest-magnitude zero-value tokens until\n\t            // finding a token with a value, a token identified as 'stopTrim', or\n\t            // the final token of the format string.\n\t            // \"small\" - will trim smallest-magnitude zero-value tokens until\n\t            // finding a token with a value, a token identified as 'stopTrim', or\n\t            // the final token of the format string.\n\t            // \"both\" - will execute \"large\" trim then \"small\" trim.\n\t            // \"mid\" - will trim any zero-value tokens that are not the first or\n\t            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n\t            // e.g. \"large mid\" or \"both mid\".\n\t            // \"final\" - will trim the final token if it is zero-value. Use this\n\t            // option with \"large\" or \"both\" to output an empty string when\n\t            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n\t            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n\t            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n\t            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n\t            // `false` - template tokens are not trimmed.\n\t            // `true` - treated as \"large\".\n\t            // `null` - treated as \"large\".\n\t            trim: null,\n\t\n\t            // stopTrim\n\t            // A moment token string, a delimited set of moment token strings,\n\t            // or an array of moment token strings. Trimming will stop when a token\n\t            // listed in this option is reached. A \"*\" character in the format\n\t            // template string will also mark a moment token as stopTrim.\n\t            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n\t            stopTrim: null,\n\t\n\t            // largest\n\t            // Set to a positive integer to output only the \"n\" largest-magnitude\n\t            // moment tokens that have a value. All lesser-magnitude moment tokens\n\t            // will be ignored. This option takes effect even if `trim` is set\n\t            // to `false`.\n\t            largest: null,\n\t\n\t            // maxValue\n\t            // Use `maxValue` to render generalized output for large duration values,\n\t            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n\t            /// applied to the greatest-magnitude moment token in the format template.\n\t            maxValue: null,\n\t\n\t            // minValue\n\t            // Use `minValue` to render generalized output for small duration values,\n\t            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n\t            // applied to the least-magnitude moment token in the format template.\n\t            minValue: null,\n\t\n\t            // precision\n\t            // If a positive integer, number of decimal fraction digits to render.\n\t            // If a negative integer, number of integer place digits to truncate to 0.\n\t            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n\t            // integer, sets the maximum number of significant digits used in the\n\t            // formatted output.\n\t            precision: 0,\n\t\n\t            // trunc\n\t            // Default behavior rounds final token value. Set to `true` to\n\t            // truncate final token value, which was the default behavior in\n\t            // version 1 of this plugin.\n\t            trunc: false,\n\t\n\t            // forceLength\n\t            // Force first moment token with a value to render at full length\n\t            // even when template is trimmed and first moment token has length of 1.\n\t            forceLength: null,\n\t\n\t            // userLocale\n\t            // Formatted numerical output is rendered using `toLocaleString`\n\t            // and the locale of the user's environment. Set this option to render\n\t            // numerical output using a different locale. Unit names are rendered\n\t            // and detected using the locale set in moment.js, which can be different\n\t            // from the locale of user's environment.\n\t            userLocale: null,\n\t\n\t            // usePlural\n\t            // Will automatically singularize or pluralize unit names when they\n\t            // appear in the text associated with each moment token. Standard and\n\t            // short unit labels are singularized and pluralized, based on locale.\n\t            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n\t            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n\t            // renders a plural label for a value with decimal precision.\n\t            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n\t            // Label types and pluralization function are configurable in the\n\t            // localeData extensions.\n\t            usePlural: true,\n\t\n\t            // useLeftUnits\n\t            // The text to the right of each moment token in a format string\n\t            // is treated as that token's units for the purposes of trimming,\n\t            // singularizing, and auto-localizing.\n\t            // e.g. \"h [hours], m [minutes], s [seconds]\".\n\t            // To properly singularize or localize a format string such as\n\t            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n\t            // to the left of each moment token, set useLeftUnits to `true`.\n\t            // This plugin is not tested in the context of rtl text.\n\t            useLeftUnits: false,\n\t\n\t            // useGrouping\n\t            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n\t            useGrouping: true,\n\t\n\t            // useSignificantDigits\n\t            // Treat the `precision` option as the maximum significant digits\n\t            // to be rendered. Precision must be a positive integer. Significant\n\t            // digits extend across unit types,\n\t            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n\t            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n\t            useSignificantDigits: false,\n\t\n\t            // template\n\t            // The template string used to format the duration. May be a function\n\t            // or a string. Template functions are executed with the `this` binding\n\t            // of the settings object so that template strings may be dynamically\n\t            // generated based on the duration object (accessible via `this.duration`)\n\t            // or any of the other settings. Leading and trailing space, comma,\n\t            // period, and colon characters are trimmed from the resulting string.\n\t            template: defaultFormatTemplate,\n\t\n\t            // useToLocaleString\n\t            // Set this option to `false` to ignore the `toLocaleString` feature\n\t            // test and force the use of the `formatNumber` fallback function\n\t            // included in this plugin.\n\t            useToLocaleString: true,\n\t\n\t            // formatNumber fallback options.\n\t            // When `toLocaleString` is detected and passes the feature test, the\n\t            // following options will have no effect: `toLocaleString` will be used\n\t            // for formatting and the grouping separator, decimal separator, and\n\t            // integer digit grouping will be determined by the user locale.\n\t\n\t            // groupingSeparator\n\t            // The integer digit grouping separator used when using the fallback\n\t            // formatNumber function.\n\t            groupingSeparator: \",\",\n\t\n\t            // decimalSeparator\n\t            // The decimal separator used when using the fallback formatNumber\n\t            // function.\n\t            decimalSeparator: \".\",\n\t\n\t            // grouping\n\t            // The integer digit grouping used when using the fallback formatNumber\n\t            // function. Must be an array. The default value of `[3]` gives the\n\t            // standard 3-digit thousand/million/billion digit groupings for the\n\t            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n\t            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n\t            grouping: [3]\n\t        };\n\t\n\t        context.updateLocale('en', engLocale);\n\t    }\n\t\n\t    // Run feature tests for `Number#toLocaleString`.\n\t    toLocaleStringWorks = featureTestToLocaleString();\n\t    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding();\n\t\n\t    // Initialize duration format on the global moment instance.\n\t    init(moment);\n\t\n\t    // Return the init function so that duration format can be\n\t    // initialized on other moment instances.\n\t    return init;\n\t});\n\n\n/***/ }),\n\n/***/ 38:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar require;/* WEBPACK VAR INJECTION */(function(module) {//! moment.js\n\t//! version : 2.20.1\n\t//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n\t//! license : MIT\n\t//! momentjs.com\n\t\n\t;(function (global, factory) {\n\t     true ? module.exports = factory() :\n\t    typeof define === 'function' && define.amd ? define(factory) :\n\t    global.moment = factory()\n\t}(this, (function () { 'use strict';\n\t\n\tvar hookCallback;\n\t\n\tfunction hooks () {\n\t    return hookCallback.apply(null, arguments);\n\t}\n\t\n\t// This is done to register the method called with moment()\n\t// without creating circular dependencies.\n\tfunction setHookCallback (callback) {\n\t    hookCallback = callback;\n\t}\n\t\n\tfunction isArray(input) {\n\t    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n\t}\n\t\n\tfunction isObject(input) {\n\t    // IE8 will treat undefined and null as object if it wasn't for\n\t    // input != null\n\t    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n\t}\n\t\n\tfunction isObjectEmpty(obj) {\n\t    if (Object.getOwnPropertyNames) {\n\t        return (Object.getOwnPropertyNames(obj).length === 0);\n\t    } else {\n\t        var k;\n\t        for (k in obj) {\n\t            if (obj.hasOwnProperty(k)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t}\n\t\n\tfunction isUndefined(input) {\n\t    return input === void 0;\n\t}\n\t\n\tfunction isNumber(input) {\n\t    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n\t}\n\t\n\tfunction isDate(input) {\n\t    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n\t}\n\t\n\tfunction map(arr, fn) {\n\t    var res = [], i;\n\t    for (i = 0; i < arr.length; ++i) {\n\t        res.push(fn(arr[i], i));\n\t    }\n\t    return res;\n\t}\n\t\n\tfunction hasOwnProp(a, b) {\n\t    return Object.prototype.hasOwnProperty.call(a, b);\n\t}\n\t\n\tfunction extend(a, b) {\n\t    for (var i in b) {\n\t        if (hasOwnProp(b, i)) {\n\t            a[i] = b[i];\n\t        }\n\t    }\n\t\n\t    if (hasOwnProp(b, 'toString')) {\n\t        a.toString = b.toString;\n\t    }\n\t\n\t    if (hasOwnProp(b, 'valueOf')) {\n\t        a.valueOf = b.valueOf;\n\t    }\n\t\n\t    return a;\n\t}\n\t\n\tfunction createUTC (input, format, locale, strict) {\n\t    return createLocalOrUTC(input, format, locale, strict, true).utc();\n\t}\n\t\n\tfunction defaultParsingFlags() {\n\t    // We need to deep clone this object.\n\t    return {\n\t        empty           : false,\n\t        unusedTokens    : [],\n\t        unusedInput     : [],\n\t        overflow        : -2,\n\t        charsLeftOver   : 0,\n\t        nullInput       : false,\n\t        invalidMonth    : null,\n\t        invalidFormat   : false,\n\t        userInvalidated : false,\n\t        iso             : false,\n\t        parsedDateParts : [],\n\t        meridiem        : null,\n\t        rfc2822         : false,\n\t        weekdayMismatch : false\n\t    };\n\t}\n\t\n\tfunction getParsingFlags(m) {\n\t    if (m._pf == null) {\n\t        m._pf = defaultParsingFlags();\n\t    }\n\t    return m._pf;\n\t}\n\t\n\tvar some;\n\tif (Array.prototype.some) {\n\t    some = Array.prototype.some;\n\t} else {\n\t    some = function (fun) {\n\t        var t = Object(this);\n\t        var len = t.length >>> 0;\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            if (i in t && fun.call(this, t[i], i, t)) {\n\t                return true;\n\t            }\n\t        }\n\t\n\t        return false;\n\t    };\n\t}\n\t\n\tfunction isValid(m) {\n\t    if (m._isValid == null) {\n\t        var flags = getParsingFlags(m);\n\t        var parsedParts = some.call(flags.parsedDateParts, function (i) {\n\t            return i != null;\n\t        });\n\t        var isNowValid = !isNaN(m._d.getTime()) &&\n\t            flags.overflow < 0 &&\n\t            !flags.empty &&\n\t            !flags.invalidMonth &&\n\t            !flags.invalidWeekday &&\n\t            !flags.weekdayMismatch &&\n\t            !flags.nullInput &&\n\t            !flags.invalidFormat &&\n\t            !flags.userInvalidated &&\n\t            (!flags.meridiem || (flags.meridiem && parsedParts));\n\t\n\t        if (m._strict) {\n\t            isNowValid = isNowValid &&\n\t                flags.charsLeftOver === 0 &&\n\t                flags.unusedTokens.length === 0 &&\n\t                flags.bigHour === undefined;\n\t        }\n\t\n\t        if (Object.isFrozen == null || !Object.isFrozen(m)) {\n\t            m._isValid = isNowValid;\n\t        }\n\t        else {\n\t            return isNowValid;\n\t        }\n\t    }\n\t    return m._isValid;\n\t}\n\t\n\tfunction createInvalid (flags) {\n\t    var m = createUTC(NaN);\n\t    if (flags != null) {\n\t        extend(getParsingFlags(m), flags);\n\t    }\n\t    else {\n\t        getParsingFlags(m).userInvalidated = true;\n\t    }\n\t\n\t    return m;\n\t}\n\t\n\t// Plugins that add properties should also add the key here (null value),\n\t// so we can properly clone ourselves.\n\tvar momentProperties = hooks.momentProperties = [];\n\t\n\tfunction copyConfig(to, from) {\n\t    var i, prop, val;\n\t\n\t    if (!isUndefined(from._isAMomentObject)) {\n\t        to._isAMomentObject = from._isAMomentObject;\n\t    }\n\t    if (!isUndefined(from._i)) {\n\t        to._i = from._i;\n\t    }\n\t    if (!isUndefined(from._f)) {\n\t        to._f = from._f;\n\t    }\n\t    if (!isUndefined(from._l)) {\n\t        to._l = from._l;\n\t    }\n\t    if (!isUndefined(from._strict)) {\n\t        to._strict = from._strict;\n\t    }\n\t    if (!isUndefined(from._tzm)) {\n\t        to._tzm = from._tzm;\n\t    }\n\t    if (!isUndefined(from._isUTC)) {\n\t        to._isUTC = from._isUTC;\n\t    }\n\t    if (!isUndefined(from._offset)) {\n\t        to._offset = from._offset;\n\t    }\n\t    if (!isUndefined(from._pf)) {\n\t        to._pf = getParsingFlags(from);\n\t    }\n\t    if (!isUndefined(from._locale)) {\n\t        to._locale = from._locale;\n\t    }\n\t\n\t    if (momentProperties.length > 0) {\n\t        for (i = 0; i < momentProperties.length; i++) {\n\t            prop = momentProperties[i];\n\t            val = from[prop];\n\t            if (!isUndefined(val)) {\n\t                to[prop] = val;\n\t            }\n\t        }\n\t    }\n\t\n\t    return to;\n\t}\n\t\n\tvar updateInProgress = false;\n\t\n\t// Moment prototype object\n\tfunction Moment(config) {\n\t    copyConfig(this, config);\n\t    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n\t    if (!this.isValid()) {\n\t        this._d = new Date(NaN);\n\t    }\n\t    // Prevent infinite loop in case updateOffset creates new moment\n\t    // objects.\n\t    if (updateInProgress === false) {\n\t        updateInProgress = true;\n\t        hooks.updateOffset(this);\n\t        updateInProgress = false;\n\t    }\n\t}\n\t\n\tfunction isMoment (obj) {\n\t    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n\t}\n\t\n\tfunction absFloor (number) {\n\t    if (number < 0) {\n\t        // -0 -> 0\n\t        return Math.ceil(number) || 0;\n\t    } else {\n\t        return Math.floor(number);\n\t    }\n\t}\n\t\n\tfunction toInt(argumentForCoercion) {\n\t    var coercedNumber = +argumentForCoercion,\n\t        value = 0;\n\t\n\t    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n\t        value = absFloor(coercedNumber);\n\t    }\n\t\n\t    return value;\n\t}\n\t\n\t// compare two arrays, return the number of differences\n\tfunction compareArrays(array1, array2, dontConvert) {\n\t    var len = Math.min(array1.length, array2.length),\n\t        lengthDiff = Math.abs(array1.length - array2.length),\n\t        diffs = 0,\n\t        i;\n\t    for (i = 0; i < len; i++) {\n\t        if ((dontConvert && array1[i] !== array2[i]) ||\n\t            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n\t            diffs++;\n\t        }\n\t    }\n\t    return diffs + lengthDiff;\n\t}\n\t\n\tfunction warn(msg) {\n\t    if (hooks.suppressDeprecationWarnings === false &&\n\t            (typeof console !==  'undefined') && console.warn) {\n\t        console.warn('Deprecation warning: ' + msg);\n\t    }\n\t}\n\t\n\tfunction deprecate(msg, fn) {\n\t    var firstTime = true;\n\t\n\t    return extend(function () {\n\t        if (hooks.deprecationHandler != null) {\n\t            hooks.deprecationHandler(null, msg);\n\t        }\n\t        if (firstTime) {\n\t            var args = [];\n\t            var arg;\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                arg = '';\n\t                if (typeof arguments[i] === 'object') {\n\t                    arg += '\\n[' + i + '] ';\n\t                    for (var key in arguments[0]) {\n\t                        arg += key + ': ' + arguments[0][key] + ', ';\n\t                    }\n\t                    arg = arg.slice(0, -2); // Remove trailing comma and space\n\t                } else {\n\t                    arg = arguments[i];\n\t                }\n\t                args.push(arg);\n\t            }\n\t            warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n\t            firstTime = false;\n\t        }\n\t        return fn.apply(this, arguments);\n\t    }, fn);\n\t}\n\t\n\tvar deprecations = {};\n\t\n\tfunction deprecateSimple(name, msg) {\n\t    if (hooks.deprecationHandler != null) {\n\t        hooks.deprecationHandler(name, msg);\n\t    }\n\t    if (!deprecations[name]) {\n\t        warn(msg);\n\t        deprecations[name] = true;\n\t    }\n\t}\n\t\n\thooks.suppressDeprecationWarnings = false;\n\thooks.deprecationHandler = null;\n\t\n\tfunction isFunction(input) {\n\t    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n\t}\n\t\n\tfunction set (config) {\n\t    var prop, i;\n\t    for (i in config) {\n\t        prop = config[i];\n\t        if (isFunction(prop)) {\n\t            this[i] = prop;\n\t        } else {\n\t            this['_' + i] = prop;\n\t        }\n\t    }\n\t    this._config = config;\n\t    // Lenient ordinal parsing accepts just a number in addition to\n\t    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n\t    // TODO: Remove \"ordinalParse\" fallback in next major release.\n\t    this._dayOfMonthOrdinalParseLenient = new RegExp(\n\t        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n\t            '|' + (/\\d{1,2}/).source);\n\t}\n\t\n\tfunction mergeConfigs(parentConfig, childConfig) {\n\t    var res = extend({}, parentConfig), prop;\n\t    for (prop in childConfig) {\n\t        if (hasOwnProp(childConfig, prop)) {\n\t            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n\t                res[prop] = {};\n\t                extend(res[prop], parentConfig[prop]);\n\t                extend(res[prop], childConfig[prop]);\n\t            } else if (childConfig[prop] != null) {\n\t                res[prop] = childConfig[prop];\n\t            } else {\n\t                delete res[prop];\n\t            }\n\t        }\n\t    }\n\t    for (prop in parentConfig) {\n\t        if (hasOwnProp(parentConfig, prop) &&\n\t                !hasOwnProp(childConfig, prop) &&\n\t                isObject(parentConfig[prop])) {\n\t            // make sure changes to properties don't modify parent config\n\t            res[prop] = extend({}, res[prop]);\n\t        }\n\t    }\n\t    return res;\n\t}\n\t\n\tfunction Locale(config) {\n\t    if (config != null) {\n\t        this.set(config);\n\t    }\n\t}\n\t\n\tvar keys;\n\t\n\tif (Object.keys) {\n\t    keys = Object.keys;\n\t} else {\n\t    keys = function (obj) {\n\t        var i, res = [];\n\t        for (i in obj) {\n\t            if (hasOwnProp(obj, i)) {\n\t                res.push(i);\n\t            }\n\t        }\n\t        return res;\n\t    };\n\t}\n\t\n\tvar defaultCalendar = {\n\t    sameDay : '[Today at] LT',\n\t    nextDay : '[Tomorrow at] LT',\n\t    nextWeek : 'dddd [at] LT',\n\t    lastDay : '[Yesterday at] LT',\n\t    lastWeek : '[Last] dddd [at] LT',\n\t    sameElse : 'L'\n\t};\n\t\n\tfunction calendar (key, mom, now) {\n\t    var output = this._calendar[key] || this._calendar['sameElse'];\n\t    return isFunction(output) ? output.call(mom, now) : output;\n\t}\n\t\n\tvar defaultLongDateFormat = {\n\t    LTS  : 'h:mm:ss A',\n\t    LT   : 'h:mm A',\n\t    L    : 'MM/DD/YYYY',\n\t    LL   : 'MMMM D, YYYY',\n\t    LLL  : 'MMMM D, YYYY h:mm A',\n\t    LLLL : 'dddd, MMMM D, YYYY h:mm A'\n\t};\n\t\n\tfunction longDateFormat (key) {\n\t    var format = this._longDateFormat[key],\n\t        formatUpper = this._longDateFormat[key.toUpperCase()];\n\t\n\t    if (format || !formatUpper) {\n\t        return format;\n\t    }\n\t\n\t    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n\t        return val.slice(1);\n\t    });\n\t\n\t    return this._longDateFormat[key];\n\t}\n\t\n\tvar defaultInvalidDate = 'Invalid date';\n\t\n\tfunction invalidDate () {\n\t    return this._invalidDate;\n\t}\n\t\n\tvar defaultOrdinal = '%d';\n\tvar defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\t\n\tfunction ordinal (number) {\n\t    return this._ordinal.replace('%d', number);\n\t}\n\t\n\tvar defaultRelativeTime = {\n\t    future : 'in %s',\n\t    past   : '%s ago',\n\t    s  : 'a few seconds',\n\t    ss : '%d seconds',\n\t    m  : 'a minute',\n\t    mm : '%d minutes',\n\t    h  : 'an hour',\n\t    hh : '%d hours',\n\t    d  : 'a day',\n\t    dd : '%d days',\n\t    M  : 'a month',\n\t    MM : '%d months',\n\t    y  : 'a year',\n\t    yy : '%d years'\n\t};\n\t\n\tfunction relativeTime (number, withoutSuffix, string, isFuture) {\n\t    var output = this._relativeTime[string];\n\t    return (isFunction(output)) ?\n\t        output(number, withoutSuffix, string, isFuture) :\n\t        output.replace(/%d/i, number);\n\t}\n\t\n\tfunction pastFuture (diff, output) {\n\t    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n\t    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n\t}\n\t\n\tvar aliases = {};\n\t\n\tfunction addUnitAlias (unit, shorthand) {\n\t    var lowerCase = unit.toLowerCase();\n\t    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n\t}\n\t\n\tfunction normalizeUnits(units) {\n\t    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n\t}\n\t\n\tfunction normalizeObjectUnits(inputObject) {\n\t    var normalizedInput = {},\n\t        normalizedProp,\n\t        prop;\n\t\n\t    for (prop in inputObject) {\n\t        if (hasOwnProp(inputObject, prop)) {\n\t            normalizedProp = normalizeUnits(prop);\n\t            if (normalizedProp) {\n\t                normalizedInput[normalizedProp] = inputObject[prop];\n\t            }\n\t        }\n\t    }\n\t\n\t    return normalizedInput;\n\t}\n\t\n\tvar priorities = {};\n\t\n\tfunction addUnitPriority(unit, priority) {\n\t    priorities[unit] = priority;\n\t}\n\t\n\tfunction getPrioritizedUnits(unitsObj) {\n\t    var units = [];\n\t    for (var u in unitsObj) {\n\t        units.push({unit: u, priority: priorities[u]});\n\t    }\n\t    units.sort(function (a, b) {\n\t        return a.priority - b.priority;\n\t    });\n\t    return units;\n\t}\n\t\n\tfunction zeroFill(number, targetLength, forceSign) {\n\t    var absNumber = '' + Math.abs(number),\n\t        zerosToFill = targetLength - absNumber.length,\n\t        sign = number >= 0;\n\t    return (sign ? (forceSign ? '+' : '') : '-') +\n\t        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n\t}\n\t\n\tvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\t\n\tvar localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\t\n\tvar formatFunctions = {};\n\t\n\tvar formatTokenFunctions = {};\n\t\n\t// token:    'M'\n\t// padded:   ['MM', 2]\n\t// ordinal:  'Mo'\n\t// callback: function () { this.month() + 1 }\n\tfunction addFormatToken (token, padded, ordinal, callback) {\n\t    var func = callback;\n\t    if (typeof callback === 'string') {\n\t        func = function () {\n\t            return this[callback]();\n\t        };\n\t    }\n\t    if (token) {\n\t        formatTokenFunctions[token] = func;\n\t    }\n\t    if (padded) {\n\t        formatTokenFunctions[padded[0]] = function () {\n\t            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n\t        };\n\t    }\n\t    if (ordinal) {\n\t        formatTokenFunctions[ordinal] = function () {\n\t            return this.localeData().ordinal(func.apply(this, arguments), token);\n\t        };\n\t    }\n\t}\n\t\n\tfunction removeFormattingTokens(input) {\n\t    if (input.match(/\\[[\\s\\S]/)) {\n\t        return input.replace(/^\\[|\\]$/g, '');\n\t    }\n\t    return input.replace(/\\\\/g, '');\n\t}\n\t\n\tfunction makeFormatFunction(format) {\n\t    var array = format.match(formattingTokens), i, length;\n\t\n\t    for (i = 0, length = array.length; i < length; i++) {\n\t        if (formatTokenFunctions[array[i]]) {\n\t            array[i] = formatTokenFunctions[array[i]];\n\t        } else {\n\t            array[i] = removeFormattingTokens(array[i]);\n\t        }\n\t    }\n\t\n\t    return function (mom) {\n\t        var output = '', i;\n\t        for (i = 0; i < length; i++) {\n\t            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n\t        }\n\t        return output;\n\t    };\n\t}\n\t\n\t// format date using native date object\n\tfunction formatMoment(m, format) {\n\t    if (!m.isValid()) {\n\t        return m.localeData().invalidDate();\n\t    }\n\t\n\t    format = expandFormat(format, m.localeData());\n\t    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\t\n\t    return formatFunctions[format](m);\n\t}\n\t\n\tfunction expandFormat(format, locale) {\n\t    var i = 5;\n\t\n\t    function replaceLongDateFormatTokens(input) {\n\t        return locale.longDateFormat(input) || input;\n\t    }\n\t\n\t    localFormattingTokens.lastIndex = 0;\n\t    while (i >= 0 && localFormattingTokens.test(format)) {\n\t        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n\t        localFormattingTokens.lastIndex = 0;\n\t        i -= 1;\n\t    }\n\t\n\t    return format;\n\t}\n\t\n\tvar match1         = /\\d/;            //       0 - 9\n\tvar match2         = /\\d\\d/;          //      00 - 99\n\tvar match3         = /\\d{3}/;         //     000 - 999\n\tvar match4         = /\\d{4}/;         //    0000 - 9999\n\tvar match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n\tvar match1to2      = /\\d\\d?/;         //       0 - 99\n\tvar match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n\tvar match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n\tvar match1to3      = /\\d{1,3}/;       //       0 - 999\n\tvar match1to4      = /\\d{1,4}/;       //       0 - 9999\n\tvar match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\t\n\tvar matchUnsigned  = /\\d+/;           //       0 - inf\n\tvar matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\t\n\tvar matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n\tvar matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\t\n\tvar matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\t\n\t// any word (or two) characters or numbers including two/three word month in arabic.\n\t// includes scottish gaelic two word and hyphenated months\n\tvar matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\t\n\t\n\tvar regexes = {};\n\t\n\tfunction addRegexToken (token, regex, strictRegex) {\n\t    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n\t        return (isStrict && strictRegex) ? strictRegex : regex;\n\t    };\n\t}\n\t\n\tfunction getParseRegexForToken (token, config) {\n\t    if (!hasOwnProp(regexes, token)) {\n\t        return new RegExp(unescapeFormat(token));\n\t    }\n\t\n\t    return regexes[token](config._strict, config._locale);\n\t}\n\t\n\t// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\tfunction unescapeFormat(s) {\n\t    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n\t        return p1 || p2 || p3 || p4;\n\t    }));\n\t}\n\t\n\tfunction regexEscape(s) {\n\t    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\t}\n\t\n\tvar tokens = {};\n\t\n\tfunction addParseToken (token, callback) {\n\t    var i, func = callback;\n\t    if (typeof token === 'string') {\n\t        token = [token];\n\t    }\n\t    if (isNumber(callback)) {\n\t        func = function (input, array) {\n\t            array[callback] = toInt(input);\n\t        };\n\t    }\n\t    for (i = 0; i < token.length; i++) {\n\t        tokens[token[i]] = func;\n\t    }\n\t}\n\t\n\tfunction addWeekParseToken (token, callback) {\n\t    addParseToken(token, function (input, array, config, token) {\n\t        config._w = config._w || {};\n\t        callback(input, config._w, config, token);\n\t    });\n\t}\n\t\n\tfunction addTimeToArrayFromToken(token, input, config) {\n\t    if (input != null && hasOwnProp(tokens, token)) {\n\t        tokens[token](input, config._a, config, token);\n\t    }\n\t}\n\t\n\tvar YEAR = 0;\n\tvar MONTH = 1;\n\tvar DATE = 2;\n\tvar HOUR = 3;\n\tvar MINUTE = 4;\n\tvar SECOND = 5;\n\tvar MILLISECOND = 6;\n\tvar WEEK = 7;\n\tvar WEEKDAY = 8;\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('Y', 0, 0, function () {\n\t    var y = this.year();\n\t    return y <= 9999 ? '' + y : '+' + y;\n\t});\n\t\n\taddFormatToken(0, ['YY', 2], 0, function () {\n\t    return this.year() % 100;\n\t});\n\t\n\taddFormatToken(0, ['YYYY',   4],       0, 'year');\n\taddFormatToken(0, ['YYYYY',  5],       0, 'year');\n\taddFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('year', 'y');\n\t\n\t// PRIORITIES\n\t\n\taddUnitPriority('year', 1);\n\t\n\t// PARSING\n\t\n\taddRegexToken('Y',      matchSigned);\n\taddRegexToken('YY',     match1to2, match2);\n\taddRegexToken('YYYY',   match1to4, match4);\n\taddRegexToken('YYYYY',  match1to6, match6);\n\taddRegexToken('YYYYYY', match1to6, match6);\n\t\n\taddParseToken(['YYYYY', 'YYYYYY'], YEAR);\n\taddParseToken('YYYY', function (input, array) {\n\t    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n\t});\n\taddParseToken('YY', function (input, array) {\n\t    array[YEAR] = hooks.parseTwoDigitYear(input);\n\t});\n\taddParseToken('Y', function (input, array) {\n\t    array[YEAR] = parseInt(input, 10);\n\t});\n\t\n\t// HELPERS\n\t\n\tfunction daysInYear(year) {\n\t    return isLeapYear(year) ? 366 : 365;\n\t}\n\t\n\tfunction isLeapYear(year) {\n\t    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n\t}\n\t\n\t// HOOKS\n\t\n\thooks.parseTwoDigitYear = function (input) {\n\t    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n\t};\n\t\n\t// MOMENTS\n\t\n\tvar getSetYear = makeGetSet('FullYear', true);\n\t\n\tfunction getIsLeapYear () {\n\t    return isLeapYear(this.year());\n\t}\n\t\n\tfunction makeGetSet (unit, keepTime) {\n\t    return function (value) {\n\t        if (value != null) {\n\t            set$1(this, unit, value);\n\t            hooks.updateOffset(this, keepTime);\n\t            return this;\n\t        } else {\n\t            return get(this, unit);\n\t        }\n\t    };\n\t}\n\t\n\tfunction get (mom, unit) {\n\t    return mom.isValid() ?\n\t        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n\t}\n\t\n\tfunction set$1 (mom, unit, value) {\n\t    if (mom.isValid() && !isNaN(value)) {\n\t        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n\t            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n\t        }\n\t        else {\n\t            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n\t        }\n\t    }\n\t}\n\t\n\t// MOMENTS\n\t\n\tfunction stringGet (units) {\n\t    units = normalizeUnits(units);\n\t    if (isFunction(this[units])) {\n\t        return this[units]();\n\t    }\n\t    return this;\n\t}\n\t\n\t\n\tfunction stringSet (units, value) {\n\t    if (typeof units === 'object') {\n\t        units = normalizeObjectUnits(units);\n\t        var prioritized = getPrioritizedUnits(units);\n\t        for (var i = 0; i < prioritized.length; i++) {\n\t            this[prioritized[i].unit](units[prioritized[i].unit]);\n\t        }\n\t    } else {\n\t        units = normalizeUnits(units);\n\t        if (isFunction(this[units])) {\n\t            return this[units](value);\n\t        }\n\t    }\n\t    return this;\n\t}\n\t\n\tfunction mod(n, x) {\n\t    return ((n % x) + x) % x;\n\t}\n\t\n\tvar indexOf;\n\t\n\tif (Array.prototype.indexOf) {\n\t    indexOf = Array.prototype.indexOf;\n\t} else {\n\t    indexOf = function (o) {\n\t        // I know\n\t        var i;\n\t        for (i = 0; i < this.length; ++i) {\n\t            if (this[i] === o) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t}\n\t\n\tfunction daysInMonth(year, month) {\n\t    if (isNaN(year) || isNaN(month)) {\n\t        return NaN;\n\t    }\n\t    var modMonth = mod(month, 12);\n\t    year += (month - modMonth) / 12;\n\t    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('M', ['MM', 2], 'Mo', function () {\n\t    return this.month() + 1;\n\t});\n\t\n\taddFormatToken('MMM', 0, 0, function (format) {\n\t    return this.localeData().monthsShort(this, format);\n\t});\n\t\n\taddFormatToken('MMMM', 0, 0, function (format) {\n\t    return this.localeData().months(this, format);\n\t});\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('month', 'M');\n\t\n\t// PRIORITY\n\t\n\taddUnitPriority('month', 8);\n\t\n\t// PARSING\n\t\n\taddRegexToken('M',    match1to2);\n\taddRegexToken('MM',   match1to2, match2);\n\taddRegexToken('MMM',  function (isStrict, locale) {\n\t    return locale.monthsShortRegex(isStrict);\n\t});\n\taddRegexToken('MMMM', function (isStrict, locale) {\n\t    return locale.monthsRegex(isStrict);\n\t});\n\t\n\taddParseToken(['M', 'MM'], function (input, array) {\n\t    array[MONTH] = toInt(input) - 1;\n\t});\n\t\n\taddParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n\t    var month = config._locale.monthsParse(input, token, config._strict);\n\t    // if we didn't find a month name, mark the date as invalid.\n\t    if (month != null) {\n\t        array[MONTH] = month;\n\t    } else {\n\t        getParsingFlags(config).invalidMonth = input;\n\t    }\n\t});\n\t\n\t// LOCALES\n\t\n\tvar MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n\tvar defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n\tfunction localeMonths (m, format) {\n\t    if (!m) {\n\t        return isArray(this._months) ? this._months :\n\t            this._months['standalone'];\n\t    }\n\t    return isArray(this._months) ? this._months[m.month()] :\n\t        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n\t}\n\t\n\tvar defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n\tfunction localeMonthsShort (m, format) {\n\t    if (!m) {\n\t        return isArray(this._monthsShort) ? this._monthsShort :\n\t            this._monthsShort['standalone'];\n\t    }\n\t    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n\t        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n\t}\n\t\n\tfunction handleStrictParse(monthName, format, strict) {\n\t    var i, ii, mom, llc = monthName.toLocaleLowerCase();\n\t    if (!this._monthsParse) {\n\t        // this is not used\n\t        this._monthsParse = [];\n\t        this._longMonthsParse = [];\n\t        this._shortMonthsParse = [];\n\t        for (i = 0; i < 12; ++i) {\n\t            mom = createUTC([2000, i]);\n\t            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n\t            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n\t        }\n\t    }\n\t\n\t    if (strict) {\n\t        if (format === 'MMM') {\n\t            ii = indexOf.call(this._shortMonthsParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        } else {\n\t            ii = indexOf.call(this._longMonthsParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        }\n\t    } else {\n\t        if (format === 'MMM') {\n\t            ii = indexOf.call(this._shortMonthsParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._longMonthsParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        } else {\n\t            ii = indexOf.call(this._longMonthsParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._shortMonthsParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        }\n\t    }\n\t}\n\t\n\tfunction localeMonthsParse (monthName, format, strict) {\n\t    var i, mom, regex;\n\t\n\t    if (this._monthsParseExact) {\n\t        return handleStrictParse.call(this, monthName, format, strict);\n\t    }\n\t\n\t    if (!this._monthsParse) {\n\t        this._monthsParse = [];\n\t        this._longMonthsParse = [];\n\t        this._shortMonthsParse = [];\n\t    }\n\t\n\t    // TODO: add sorting\n\t    // Sorting makes sure if one month (or abbr) is a prefix of another\n\t    // see sorting in computeMonthsParse\n\t    for (i = 0; i < 12; i++) {\n\t        // make the regex if we don't have it already\n\t        mom = createUTC([2000, i]);\n\t        if (strict && !this._longMonthsParse[i]) {\n\t            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n\t            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n\t        }\n\t        if (!strict && !this._monthsParse[i]) {\n\t            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n\t            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n\t        }\n\t        // test the regex\n\t        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n\t            return i;\n\t        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n\t            return i;\n\t        } else if (!strict && this._monthsParse[i].test(monthName)) {\n\t            return i;\n\t        }\n\t    }\n\t}\n\t\n\t// MOMENTS\n\t\n\tfunction setMonth (mom, value) {\n\t    var dayOfMonth;\n\t\n\t    if (!mom.isValid()) {\n\t        // No op\n\t        return mom;\n\t    }\n\t\n\t    if (typeof value === 'string') {\n\t        if (/^\\d+$/.test(value)) {\n\t            value = toInt(value);\n\t        } else {\n\t            value = mom.localeData().monthsParse(value);\n\t            // TODO: Another silent failure?\n\t            if (!isNumber(value)) {\n\t                return mom;\n\t            }\n\t        }\n\t    }\n\t\n\t    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n\t    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n\t    return mom;\n\t}\n\t\n\tfunction getSetMonth (value) {\n\t    if (value != null) {\n\t        setMonth(this, value);\n\t        hooks.updateOffset(this, true);\n\t        return this;\n\t    } else {\n\t        return get(this, 'Month');\n\t    }\n\t}\n\t\n\tfunction getDaysInMonth () {\n\t    return daysInMonth(this.year(), this.month());\n\t}\n\t\n\tvar defaultMonthsShortRegex = matchWord;\n\tfunction monthsShortRegex (isStrict) {\n\t    if (this._monthsParseExact) {\n\t        if (!hasOwnProp(this, '_monthsRegex')) {\n\t            computeMonthsParse.call(this);\n\t        }\n\t        if (isStrict) {\n\t            return this._monthsShortStrictRegex;\n\t        } else {\n\t            return this._monthsShortRegex;\n\t        }\n\t    } else {\n\t        if (!hasOwnProp(this, '_monthsShortRegex')) {\n\t            this._monthsShortRegex = defaultMonthsShortRegex;\n\t        }\n\t        return this._monthsShortStrictRegex && isStrict ?\n\t            this._monthsShortStrictRegex : this._monthsShortRegex;\n\t    }\n\t}\n\t\n\tvar defaultMonthsRegex = matchWord;\n\tfunction monthsRegex (isStrict) {\n\t    if (this._monthsParseExact) {\n\t        if (!hasOwnProp(this, '_monthsRegex')) {\n\t            computeMonthsParse.call(this);\n\t        }\n\t        if (isStrict) {\n\t            return this._monthsStrictRegex;\n\t        } else {\n\t            return this._monthsRegex;\n\t        }\n\t    } else {\n\t        if (!hasOwnProp(this, '_monthsRegex')) {\n\t            this._monthsRegex = defaultMonthsRegex;\n\t        }\n\t        return this._monthsStrictRegex && isStrict ?\n\t            this._monthsStrictRegex : this._monthsRegex;\n\t    }\n\t}\n\t\n\tfunction computeMonthsParse () {\n\t    function cmpLenRev(a, b) {\n\t        return b.length - a.length;\n\t    }\n\t\n\t    var shortPieces = [], longPieces = [], mixedPieces = [],\n\t        i, mom;\n\t    for (i = 0; i < 12; i++) {\n\t        // make the regex if we don't have it already\n\t        mom = createUTC([2000, i]);\n\t        shortPieces.push(this.monthsShort(mom, ''));\n\t        longPieces.push(this.months(mom, ''));\n\t        mixedPieces.push(this.months(mom, ''));\n\t        mixedPieces.push(this.monthsShort(mom, ''));\n\t    }\n\t    // Sorting makes sure if one month (or abbr) is a prefix of another it\n\t    // will match the longer piece.\n\t    shortPieces.sort(cmpLenRev);\n\t    longPieces.sort(cmpLenRev);\n\t    mixedPieces.sort(cmpLenRev);\n\t    for (i = 0; i < 12; i++) {\n\t        shortPieces[i] = regexEscape(shortPieces[i]);\n\t        longPieces[i] = regexEscape(longPieces[i]);\n\t    }\n\t    for (i = 0; i < 24; i++) {\n\t        mixedPieces[i] = regexEscape(mixedPieces[i]);\n\t    }\n\t\n\t    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n\t    this._monthsShortRegex = this._monthsRegex;\n\t    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n\t    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n\t}\n\t\n\tfunction createDate (y, m, d, h, M, s, ms) {\n\t    // can't just apply() to create a date:\n\t    // https://stackoverflow.com/q/181348\n\t    var date = new Date(y, m, d, h, M, s, ms);\n\t\n\t    // the date constructor remaps years 0-99 to 1900-1999\n\t    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n\t        date.setFullYear(y);\n\t    }\n\t    return date;\n\t}\n\t\n\tfunction createUTCDate (y) {\n\t    var date = new Date(Date.UTC.apply(null, arguments));\n\t\n\t    // the Date.UTC function remaps years 0-99 to 1900-1999\n\t    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n\t        date.setUTCFullYear(y);\n\t    }\n\t    return date;\n\t}\n\t\n\t// start-of-first-week - start-of-year\n\tfunction firstWeekOffset(year, dow, doy) {\n\t    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n\t        fwd = 7 + dow - doy,\n\t        // first-week day local weekday -- which local weekday is fwd\n\t        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\t\n\t    return -fwdlw + fwd - 1;\n\t}\n\t\n\t// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n\tfunction dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n\t    var localWeekday = (7 + weekday - dow) % 7,\n\t        weekOffset = firstWeekOffset(year, dow, doy),\n\t        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n\t        resYear, resDayOfYear;\n\t\n\t    if (dayOfYear <= 0) {\n\t        resYear = year - 1;\n\t        resDayOfYear = daysInYear(resYear) + dayOfYear;\n\t    } else if (dayOfYear > daysInYear(year)) {\n\t        resYear = year + 1;\n\t        resDayOfYear = dayOfYear - daysInYear(year);\n\t    } else {\n\t        resYear = year;\n\t        resDayOfYear = dayOfYear;\n\t    }\n\t\n\t    return {\n\t        year: resYear,\n\t        dayOfYear: resDayOfYear\n\t    };\n\t}\n\t\n\tfunction weekOfYear(mom, dow, doy) {\n\t    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n\t        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n\t        resWeek, resYear;\n\t\n\t    if (week < 1) {\n\t        resYear = mom.year() - 1;\n\t        resWeek = week + weeksInYear(resYear, dow, doy);\n\t    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n\t        resWeek = week - weeksInYear(mom.year(), dow, doy);\n\t        resYear = mom.year() + 1;\n\t    } else {\n\t        resYear = mom.year();\n\t        resWeek = week;\n\t    }\n\t\n\t    return {\n\t        week: resWeek,\n\t        year: resYear\n\t    };\n\t}\n\t\n\tfunction weeksInYear(year, dow, doy) {\n\t    var weekOffset = firstWeekOffset(year, dow, doy),\n\t        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n\t    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('w', ['ww', 2], 'wo', 'week');\n\taddFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('week', 'w');\n\taddUnitAlias('isoWeek', 'W');\n\t\n\t// PRIORITIES\n\t\n\taddUnitPriority('week', 5);\n\taddUnitPriority('isoWeek', 5);\n\t\n\t// PARSING\n\t\n\taddRegexToken('w',  match1to2);\n\taddRegexToken('ww', match1to2, match2);\n\taddRegexToken('W',  match1to2);\n\taddRegexToken('WW', match1to2, match2);\n\t\n\taddWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n\t    week[token.substr(0, 1)] = toInt(input);\n\t});\n\t\n\t// HELPERS\n\t\n\t// LOCALES\n\t\n\tfunction localeWeek (mom) {\n\t    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n\t}\n\t\n\tvar defaultLocaleWeek = {\n\t    dow : 0, // Sunday is the first day of the week.\n\t    doy : 6  // The week that contains Jan 1st is the first week of the year.\n\t};\n\t\n\tfunction localeFirstDayOfWeek () {\n\t    return this._week.dow;\n\t}\n\t\n\tfunction localeFirstDayOfYear () {\n\t    return this._week.doy;\n\t}\n\t\n\t// MOMENTS\n\t\n\tfunction getSetWeek (input) {\n\t    var week = this.localeData().week(this);\n\t    return input == null ? week : this.add((input - week) * 7, 'd');\n\t}\n\t\n\tfunction getSetISOWeek (input) {\n\t    var week = weekOfYear(this, 1, 4).week;\n\t    return input == null ? week : this.add((input - week) * 7, 'd');\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('d', 0, 'do', 'day');\n\t\n\taddFormatToken('dd', 0, 0, function (format) {\n\t    return this.localeData().weekdaysMin(this, format);\n\t});\n\t\n\taddFormatToken('ddd', 0, 0, function (format) {\n\t    return this.localeData().weekdaysShort(this, format);\n\t});\n\t\n\taddFormatToken('dddd', 0, 0, function (format) {\n\t    return this.localeData().weekdays(this, format);\n\t});\n\t\n\taddFormatToken('e', 0, 0, 'weekday');\n\taddFormatToken('E', 0, 0, 'isoWeekday');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('day', 'd');\n\taddUnitAlias('weekday', 'e');\n\taddUnitAlias('isoWeekday', 'E');\n\t\n\t// PRIORITY\n\taddUnitPriority('day', 11);\n\taddUnitPriority('weekday', 11);\n\taddUnitPriority('isoWeekday', 11);\n\t\n\t// PARSING\n\t\n\taddRegexToken('d',    match1to2);\n\taddRegexToken('e',    match1to2);\n\taddRegexToken('E',    match1to2);\n\taddRegexToken('dd',   function (isStrict, locale) {\n\t    return locale.weekdaysMinRegex(isStrict);\n\t});\n\taddRegexToken('ddd',   function (isStrict, locale) {\n\t    return locale.weekdaysShortRegex(isStrict);\n\t});\n\taddRegexToken('dddd',   function (isStrict, locale) {\n\t    return locale.weekdaysRegex(isStrict);\n\t});\n\t\n\taddWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n\t    var weekday = config._locale.weekdaysParse(input, token, config._strict);\n\t    // if we didn't get a weekday name, mark the date as invalid\n\t    if (weekday != null) {\n\t        week.d = weekday;\n\t    } else {\n\t        getParsingFlags(config).invalidWeekday = input;\n\t    }\n\t});\n\t\n\taddWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n\t    week[token] = toInt(input);\n\t});\n\t\n\t// HELPERS\n\t\n\tfunction parseWeekday(input, locale) {\n\t    if (typeof input !== 'string') {\n\t        return input;\n\t    }\n\t\n\t    if (!isNaN(input)) {\n\t        return parseInt(input, 10);\n\t    }\n\t\n\t    input = locale.weekdaysParse(input);\n\t    if (typeof input === 'number') {\n\t        return input;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\tfunction parseIsoWeekday(input, locale) {\n\t    if (typeof input === 'string') {\n\t        return locale.weekdaysParse(input) % 7 || 7;\n\t    }\n\t    return isNaN(input) ? null : input;\n\t}\n\t\n\t// LOCALES\n\t\n\tvar defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n\tfunction localeWeekdays (m, format) {\n\t    if (!m) {\n\t        return isArray(this._weekdays) ? this._weekdays :\n\t            this._weekdays['standalone'];\n\t    }\n\t    return isArray(this._weekdays) ? this._weekdays[m.day()] :\n\t        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n\t}\n\t\n\tvar defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n\tfunction localeWeekdaysShort (m) {\n\t    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n\t}\n\t\n\tvar defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n\tfunction localeWeekdaysMin (m) {\n\t    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n\t}\n\t\n\tfunction handleStrictParse$1(weekdayName, format, strict) {\n\t    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n\t    if (!this._weekdaysParse) {\n\t        this._weekdaysParse = [];\n\t        this._shortWeekdaysParse = [];\n\t        this._minWeekdaysParse = [];\n\t\n\t        for (i = 0; i < 7; ++i) {\n\t            mom = createUTC([2000, 1]).day(i);\n\t            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n\t            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n\t            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n\t        }\n\t    }\n\t\n\t    if (strict) {\n\t        if (format === 'dddd') {\n\t            ii = indexOf.call(this._weekdaysParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        } else if (format === 'ddd') {\n\t            ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        } else {\n\t            ii = indexOf.call(this._minWeekdaysParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        }\n\t    } else {\n\t        if (format === 'dddd') {\n\t            ii = indexOf.call(this._weekdaysParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._minWeekdaysParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        } else if (format === 'ddd') {\n\t            ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._weekdaysParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._minWeekdaysParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        } else {\n\t            ii = indexOf.call(this._minWeekdaysParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._weekdaysParse, llc);\n\t            if (ii !== -1) {\n\t                return ii;\n\t            }\n\t            ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t            return ii !== -1 ? ii : null;\n\t        }\n\t    }\n\t}\n\t\n\tfunction localeWeekdaysParse (weekdayName, format, strict) {\n\t    var i, mom, regex;\n\t\n\t    if (this._weekdaysParseExact) {\n\t        return handleStrictParse$1.call(this, weekdayName, format, strict);\n\t    }\n\t\n\t    if (!this._weekdaysParse) {\n\t        this._weekdaysParse = [];\n\t        this._minWeekdaysParse = [];\n\t        this._shortWeekdaysParse = [];\n\t        this._fullWeekdaysParse = [];\n\t    }\n\t\n\t    for (i = 0; i < 7; i++) {\n\t        // make the regex if we don't have it already\n\t\n\t        mom = createUTC([2000, 1]).day(i);\n\t        if (strict && !this._fullWeekdaysParse[i]) {\n\t            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n\t            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n\t            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n\t        }\n\t        if (!this._weekdaysParse[i]) {\n\t            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n\t            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n\t        }\n\t        // test the regex\n\t        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n\t            return i;\n\t        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n\t            return i;\n\t        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n\t            return i;\n\t        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n\t            return i;\n\t        }\n\t    }\n\t}\n\t\n\t// MOMENTS\n\t\n\tfunction getSetDayOfWeek (input) {\n\t    if (!this.isValid()) {\n\t        return input != null ? this : NaN;\n\t    }\n\t    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n\t    if (input != null) {\n\t        input = parseWeekday(input, this.localeData());\n\t        return this.add(input - day, 'd');\n\t    } else {\n\t        return day;\n\t    }\n\t}\n\t\n\tfunction getSetLocaleDayOfWeek (input) {\n\t    if (!this.isValid()) {\n\t        return input != null ? this : NaN;\n\t    }\n\t    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n\t    return input == null ? weekday : this.add(input - weekday, 'd');\n\t}\n\t\n\tfunction getSetISODayOfWeek (input) {\n\t    if (!this.isValid()) {\n\t        return input != null ? this : NaN;\n\t    }\n\t\n\t    // behaves the same as moment#day except\n\t    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n\t    // as a setter, sunday should belong to the previous week.\n\t\n\t    if (input != null) {\n\t        var weekday = parseIsoWeekday(input, this.localeData());\n\t        return this.day(this.day() % 7 ? weekday : weekday - 7);\n\t    } else {\n\t        return this.day() || 7;\n\t    }\n\t}\n\t\n\tvar defaultWeekdaysRegex = matchWord;\n\tfunction weekdaysRegex (isStrict) {\n\t    if (this._weekdaysParseExact) {\n\t        if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t            computeWeekdaysParse.call(this);\n\t        }\n\t        if (isStrict) {\n\t            return this._weekdaysStrictRegex;\n\t        } else {\n\t            return this._weekdaysRegex;\n\t        }\n\t    } else {\n\t        if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t            this._weekdaysRegex = defaultWeekdaysRegex;\n\t        }\n\t        return this._weekdaysStrictRegex && isStrict ?\n\t            this._weekdaysStrictRegex : this._weekdaysRegex;\n\t    }\n\t}\n\t\n\tvar defaultWeekdaysShortRegex = matchWord;\n\tfunction weekdaysShortRegex (isStrict) {\n\t    if (this._weekdaysParseExact) {\n\t        if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t            computeWeekdaysParse.call(this);\n\t        }\n\t        if (isStrict) {\n\t            return this._weekdaysShortStrictRegex;\n\t        } else {\n\t            return this._weekdaysShortRegex;\n\t        }\n\t    } else {\n\t        if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n\t            this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n\t        }\n\t        return this._weekdaysShortStrictRegex && isStrict ?\n\t            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n\t    }\n\t}\n\t\n\tvar defaultWeekdaysMinRegex = matchWord;\n\tfunction weekdaysMinRegex (isStrict) {\n\t    if (this._weekdaysParseExact) {\n\t        if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t            computeWeekdaysParse.call(this);\n\t        }\n\t        if (isStrict) {\n\t            return this._weekdaysMinStrictRegex;\n\t        } else {\n\t            return this._weekdaysMinRegex;\n\t        }\n\t    } else {\n\t        if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n\t            this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n\t        }\n\t        return this._weekdaysMinStrictRegex && isStrict ?\n\t            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n\t    }\n\t}\n\t\n\t\n\tfunction computeWeekdaysParse () {\n\t    function cmpLenRev(a, b) {\n\t        return b.length - a.length;\n\t    }\n\t\n\t    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n\t        i, mom, minp, shortp, longp;\n\t    for (i = 0; i < 7; i++) {\n\t        // make the regex if we don't have it already\n\t        mom = createUTC([2000, 1]).day(i);\n\t        minp = this.weekdaysMin(mom, '');\n\t        shortp = this.weekdaysShort(mom, '');\n\t        longp = this.weekdays(mom, '');\n\t        minPieces.push(minp);\n\t        shortPieces.push(shortp);\n\t        longPieces.push(longp);\n\t        mixedPieces.push(minp);\n\t        mixedPieces.push(shortp);\n\t        mixedPieces.push(longp);\n\t    }\n\t    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n\t    // will match the longer piece.\n\t    minPieces.sort(cmpLenRev);\n\t    shortPieces.sort(cmpLenRev);\n\t    longPieces.sort(cmpLenRev);\n\t    mixedPieces.sort(cmpLenRev);\n\t    for (i = 0; i < 7; i++) {\n\t        shortPieces[i] = regexEscape(shortPieces[i]);\n\t        longPieces[i] = regexEscape(longPieces[i]);\n\t        mixedPieces[i] = regexEscape(mixedPieces[i]);\n\t    }\n\t\n\t    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n\t    this._weekdaysShortRegex = this._weekdaysRegex;\n\t    this._weekdaysMinRegex = this._weekdaysRegex;\n\t\n\t    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n\t    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n\t    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n\t}\n\t\n\t// FORMATTING\n\t\n\tfunction hFormat() {\n\t    return this.hours() % 12 || 12;\n\t}\n\t\n\tfunction kFormat() {\n\t    return this.hours() || 24;\n\t}\n\t\n\taddFormatToken('H', ['HH', 2], 0, 'hour');\n\taddFormatToken('h', ['hh', 2], 0, hFormat);\n\taddFormatToken('k', ['kk', 2], 0, kFormat);\n\t\n\taddFormatToken('hmm', 0, 0, function () {\n\t    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n\t});\n\t\n\taddFormatToken('hmmss', 0, 0, function () {\n\t    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n\t        zeroFill(this.seconds(), 2);\n\t});\n\t\n\taddFormatToken('Hmm', 0, 0, function () {\n\t    return '' + this.hours() + zeroFill(this.minutes(), 2);\n\t});\n\t\n\taddFormatToken('Hmmss', 0, 0, function () {\n\t    return '' + this.hours() + zeroFill(this.minutes(), 2) +\n\t        zeroFill(this.seconds(), 2);\n\t});\n\t\n\tfunction meridiem (token, lowercase) {\n\t    addFormatToken(token, 0, 0, function () {\n\t        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n\t    });\n\t}\n\t\n\tmeridiem('a', true);\n\tmeridiem('A', false);\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('hour', 'h');\n\t\n\t// PRIORITY\n\taddUnitPriority('hour', 13);\n\t\n\t// PARSING\n\t\n\tfunction matchMeridiem (isStrict, locale) {\n\t    return locale._meridiemParse;\n\t}\n\t\n\taddRegexToken('a',  matchMeridiem);\n\taddRegexToken('A',  matchMeridiem);\n\taddRegexToken('H',  match1to2);\n\taddRegexToken('h',  match1to2);\n\taddRegexToken('k',  match1to2);\n\taddRegexToken('HH', match1to2, match2);\n\taddRegexToken('hh', match1to2, match2);\n\taddRegexToken('kk', match1to2, match2);\n\t\n\taddRegexToken('hmm', match3to4);\n\taddRegexToken('hmmss', match5to6);\n\taddRegexToken('Hmm', match3to4);\n\taddRegexToken('Hmmss', match5to6);\n\t\n\taddParseToken(['H', 'HH'], HOUR);\n\taddParseToken(['k', 'kk'], function (input, array, config) {\n\t    var kInput = toInt(input);\n\t    array[HOUR] = kInput === 24 ? 0 : kInput;\n\t});\n\taddParseToken(['a', 'A'], function (input, array, config) {\n\t    config._isPm = config._locale.isPM(input);\n\t    config._meridiem = input;\n\t});\n\taddParseToken(['h', 'hh'], function (input, array, config) {\n\t    array[HOUR] = toInt(input);\n\t    getParsingFlags(config).bigHour = true;\n\t});\n\taddParseToken('hmm', function (input, array, config) {\n\t    var pos = input.length - 2;\n\t    array[HOUR] = toInt(input.substr(0, pos));\n\t    array[MINUTE] = toInt(input.substr(pos));\n\t    getParsingFlags(config).bigHour = true;\n\t});\n\taddParseToken('hmmss', function (input, array, config) {\n\t    var pos1 = input.length - 4;\n\t    var pos2 = input.length - 2;\n\t    array[HOUR] = toInt(input.substr(0, pos1));\n\t    array[MINUTE] = toInt(input.substr(pos1, 2));\n\t    array[SECOND] = toInt(input.substr(pos2));\n\t    getParsingFlags(config).bigHour = true;\n\t});\n\taddParseToken('Hmm', function (input, array, config) {\n\t    var pos = input.length - 2;\n\t    array[HOUR] = toInt(input.substr(0, pos));\n\t    array[MINUTE] = toInt(input.substr(pos));\n\t});\n\taddParseToken('Hmmss', function (input, array, config) {\n\t    var pos1 = input.length - 4;\n\t    var pos2 = input.length - 2;\n\t    array[HOUR] = toInt(input.substr(0, pos1));\n\t    array[MINUTE] = toInt(input.substr(pos1, 2));\n\t    array[SECOND] = toInt(input.substr(pos2));\n\t});\n\t\n\t// LOCALES\n\t\n\tfunction localeIsPM (input) {\n\t    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n\t    // Using charAt should be more compatible.\n\t    return ((input + '').toLowerCase().charAt(0) === 'p');\n\t}\n\t\n\tvar defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n\tfunction localeMeridiem (hours, minutes, isLower) {\n\t    if (hours > 11) {\n\t        return isLower ? 'pm' : 'PM';\n\t    } else {\n\t        return isLower ? 'am' : 'AM';\n\t    }\n\t}\n\t\n\t\n\t// MOMENTS\n\t\n\t// Setting the hour should keep the time, because the user explicitly\n\t// specified which hour he wants. So trying to maintain the same hour (in\n\t// a new timezone) makes sense. Adding/subtracting hours does not follow\n\t// this rule.\n\tvar getSetHour = makeGetSet('Hours', true);\n\t\n\t// months\n\t// week\n\t// weekdays\n\t// meridiem\n\tvar baseConfig = {\n\t    calendar: defaultCalendar,\n\t    longDateFormat: defaultLongDateFormat,\n\t    invalidDate: defaultInvalidDate,\n\t    ordinal: defaultOrdinal,\n\t    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n\t    relativeTime: defaultRelativeTime,\n\t\n\t    months: defaultLocaleMonths,\n\t    monthsShort: defaultLocaleMonthsShort,\n\t\n\t    week: defaultLocaleWeek,\n\t\n\t    weekdays: defaultLocaleWeekdays,\n\t    weekdaysMin: defaultLocaleWeekdaysMin,\n\t    weekdaysShort: defaultLocaleWeekdaysShort,\n\t\n\t    meridiemParse: defaultLocaleMeridiemParse\n\t};\n\t\n\t// internal storage for locale config files\n\tvar locales = {};\n\tvar localeFamilies = {};\n\tvar globalLocale;\n\t\n\tfunction normalizeLocale(key) {\n\t    return key ? key.toLowerCase().replace('_', '-') : key;\n\t}\n\t\n\t// pick the locale from the array\n\t// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n\t// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n\tfunction chooseLocale(names) {\n\t    var i = 0, j, next, locale, split;\n\t\n\t    while (i < names.length) {\n\t        split = normalizeLocale(names[i]).split('-');\n\t        j = split.length;\n\t        next = normalizeLocale(names[i + 1]);\n\t        next = next ? next.split('-') : null;\n\t        while (j > 0) {\n\t            locale = loadLocale(split.slice(0, j).join('-'));\n\t            if (locale) {\n\t                return locale;\n\t            }\n\t            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n\t                //the next array item is better than a shallower substring of this one\n\t                break;\n\t            }\n\t            j--;\n\t        }\n\t        i++;\n\t    }\n\t    return null;\n\t}\n\t\n\tfunction loadLocale(name) {\n\t    var oldLocale = null;\n\t    // TODO: Find a better way to register and load all the locales in Node\n\t    if (!locales[name] && (typeof module !== 'undefined') &&\n\t            module && module.exports) {\n\t        try {\n\t            oldLocale = globalLocale._abbr;\n\t            var aliasedRequire = require;\n\t            !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"./locale\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\t            getSetGlobalLocale(oldLocale);\n\t        } catch (e) {}\n\t    }\n\t    return locales[name];\n\t}\n\t\n\t// This function will load locale and then set the global locale.  If\n\t// no arguments are passed in, it will simply return the current global\n\t// locale key.\n\tfunction getSetGlobalLocale (key, values) {\n\t    var data;\n\t    if (key) {\n\t        if (isUndefined(values)) {\n\t            data = getLocale(key);\n\t        }\n\t        else {\n\t            data = defineLocale(key, values);\n\t        }\n\t\n\t        if (data) {\n\t            // moment.duration._locale = moment._locale = data;\n\t            globalLocale = data;\n\t        }\n\t    }\n\t\n\t    return globalLocale._abbr;\n\t}\n\t\n\tfunction defineLocale (name, config) {\n\t    if (config !== null) {\n\t        var parentConfig = baseConfig;\n\t        config.abbr = name;\n\t        if (locales[name] != null) {\n\t            deprecateSimple('defineLocaleOverride',\n\t                    'use moment.updateLocale(localeName, config) to change ' +\n\t                    'an existing locale. moment.defineLocale(localeName, ' +\n\t                    'config) should only be used for creating a new locale ' +\n\t                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n\t            parentConfig = locales[name]._config;\n\t        } else if (config.parentLocale != null) {\n\t            if (locales[config.parentLocale] != null) {\n\t                parentConfig = locales[config.parentLocale]._config;\n\t            } else {\n\t                if (!localeFamilies[config.parentLocale]) {\n\t                    localeFamilies[config.parentLocale] = [];\n\t                }\n\t                localeFamilies[config.parentLocale].push({\n\t                    name: name,\n\t                    config: config\n\t                });\n\t                return null;\n\t            }\n\t        }\n\t        locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\t\n\t        if (localeFamilies[name]) {\n\t            localeFamilies[name].forEach(function (x) {\n\t                defineLocale(x.name, x.config);\n\t            });\n\t        }\n\t\n\t        // backwards compat for now: also set the locale\n\t        // make sure we set the locale AFTER all child locales have been\n\t        // created, so we won't end up with the child locale set.\n\t        getSetGlobalLocale(name);\n\t\n\t\n\t        return locales[name];\n\t    } else {\n\t        // useful for testing\n\t        delete locales[name];\n\t        return null;\n\t    }\n\t}\n\t\n\tfunction updateLocale(name, config) {\n\t    if (config != null) {\n\t        var locale, tmpLocale, parentConfig = baseConfig;\n\t        // MERGE\n\t        tmpLocale = loadLocale(name);\n\t        if (tmpLocale != null) {\n\t            parentConfig = tmpLocale._config;\n\t        }\n\t        config = mergeConfigs(parentConfig, config);\n\t        locale = new Locale(config);\n\t        locale.parentLocale = locales[name];\n\t        locales[name] = locale;\n\t\n\t        // backwards compat for now: also set the locale\n\t        getSetGlobalLocale(name);\n\t    } else {\n\t        // pass null for config to unupdate, useful for tests\n\t        if (locales[name] != null) {\n\t            if (locales[name].parentLocale != null) {\n\t                locales[name] = locales[name].parentLocale;\n\t            } else if (locales[name] != null) {\n\t                delete locales[name];\n\t            }\n\t        }\n\t    }\n\t    return locales[name];\n\t}\n\t\n\t// returns locale data\n\tfunction getLocale (key) {\n\t    var locale;\n\t\n\t    if (key && key._locale && key._locale._abbr) {\n\t        key = key._locale._abbr;\n\t    }\n\t\n\t    if (!key) {\n\t        return globalLocale;\n\t    }\n\t\n\t    if (!isArray(key)) {\n\t        //short-circuit everything else\n\t        locale = loadLocale(key);\n\t        if (locale) {\n\t            return locale;\n\t        }\n\t        key = [key];\n\t    }\n\t\n\t    return chooseLocale(key);\n\t}\n\t\n\tfunction listLocales() {\n\t    return keys(locales);\n\t}\n\t\n\tfunction checkOverflow (m) {\n\t    var overflow;\n\t    var a = m._a;\n\t\n\t    if (a && getParsingFlags(m).overflow === -2) {\n\t        overflow =\n\t            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n\t            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n\t            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n\t            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n\t            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n\t            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n\t            -1;\n\t\n\t        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n\t            overflow = DATE;\n\t        }\n\t        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n\t            overflow = WEEK;\n\t        }\n\t        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n\t            overflow = WEEKDAY;\n\t        }\n\t\n\t        getParsingFlags(m).overflow = overflow;\n\t    }\n\t\n\t    return m;\n\t}\n\t\n\t// Pick the first defined of two or three arguments.\n\tfunction defaults(a, b, c) {\n\t    if (a != null) {\n\t        return a;\n\t    }\n\t    if (b != null) {\n\t        return b;\n\t    }\n\t    return c;\n\t}\n\t\n\tfunction currentDateArray(config) {\n\t    // hooks is actually the exported moment object\n\t    var nowValue = new Date(hooks.now());\n\t    if (config._useUTC) {\n\t        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n\t    }\n\t    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n\t}\n\t\n\t// convert an array to a date.\n\t// the array should mirror the parameters below\n\t// note: all values past the year are optional and will default to the lowest possible value.\n\t// [year, month, day , hour, minute, second, millisecond]\n\tfunction configFromArray (config) {\n\t    var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\t\n\t    if (config._d) {\n\t        return;\n\t    }\n\t\n\t    currentDate = currentDateArray(config);\n\t\n\t    //compute day of the year from weeks and weekdays\n\t    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n\t        dayOfYearFromWeekInfo(config);\n\t    }\n\t\n\t    //if the day of the year is set, figure out what it is\n\t    if (config._dayOfYear != null) {\n\t        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\t\n\t        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n\t            getParsingFlags(config)._overflowDayOfYear = true;\n\t        }\n\t\n\t        date = createUTCDate(yearToUse, 0, config._dayOfYear);\n\t        config._a[MONTH] = date.getUTCMonth();\n\t        config._a[DATE] = date.getUTCDate();\n\t    }\n\t\n\t    // Default to current date.\n\t    // * if no year, month, day of month are given, default to today\n\t    // * if day of month is given, default month and year\n\t    // * if month is given, default only year\n\t    // * if year is given, don't default anything\n\t    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n\t        config._a[i] = input[i] = currentDate[i];\n\t    }\n\t\n\t    // Zero out whatever was not defaulted, including time\n\t    for (; i < 7; i++) {\n\t        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n\t    }\n\t\n\t    // Check for 24:00:00.000\n\t    if (config._a[HOUR] === 24 &&\n\t            config._a[MINUTE] === 0 &&\n\t            config._a[SECOND] === 0 &&\n\t            config._a[MILLISECOND] === 0) {\n\t        config._nextDay = true;\n\t        config._a[HOUR] = 0;\n\t    }\n\t\n\t    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n\t    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\t\n\t    // Apply timezone offset from input. The actual utcOffset can be changed\n\t    // with parseZone.\n\t    if (config._tzm != null) {\n\t        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\t    }\n\t\n\t    if (config._nextDay) {\n\t        config._a[HOUR] = 24;\n\t    }\n\t\n\t    // check for mismatching day of week\n\t    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n\t        getParsingFlags(config).weekdayMismatch = true;\n\t    }\n\t}\n\t\n\tfunction dayOfYearFromWeekInfo(config) {\n\t    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\t\n\t    w = config._w;\n\t    if (w.GG != null || w.W != null || w.E != null) {\n\t        dow = 1;\n\t        doy = 4;\n\t\n\t        // TODO: We need to take the current isoWeekYear, but that depends on\n\t        // how we interpret now (local, utc, fixed offset). So create\n\t        // a now version of current config (take local/utc/offset flags, and\n\t        // create now).\n\t        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n\t        week = defaults(w.W, 1);\n\t        weekday = defaults(w.E, 1);\n\t        if (weekday < 1 || weekday > 7) {\n\t            weekdayOverflow = true;\n\t        }\n\t    } else {\n\t        dow = config._locale._week.dow;\n\t        doy = config._locale._week.doy;\n\t\n\t        var curWeek = weekOfYear(createLocal(), dow, doy);\n\t\n\t        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\t\n\t        // Default to current week.\n\t        week = defaults(w.w, curWeek.week);\n\t\n\t        if (w.d != null) {\n\t            // weekday -- low day numbers are considered next week\n\t            weekday = w.d;\n\t            if (weekday < 0 || weekday > 6) {\n\t                weekdayOverflow = true;\n\t            }\n\t        } else if (w.e != null) {\n\t            // local weekday -- counting starts from begining of week\n\t            weekday = w.e + dow;\n\t            if (w.e < 0 || w.e > 6) {\n\t                weekdayOverflow = true;\n\t            }\n\t        } else {\n\t            // default to begining of week\n\t            weekday = dow;\n\t        }\n\t    }\n\t    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n\t        getParsingFlags(config)._overflowWeeks = true;\n\t    } else if (weekdayOverflow != null) {\n\t        getParsingFlags(config)._overflowWeekday = true;\n\t    } else {\n\t        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n\t        config._a[YEAR] = temp.year;\n\t        config._dayOfYear = temp.dayOfYear;\n\t    }\n\t}\n\t\n\t// iso 8601 regex\n\t// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n\tvar extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\tvar basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\t\n\tvar tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\t\n\tvar isoDates = [\n\t    ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n\t    ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n\t    ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n\t    ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n\t    ['YYYY-DDD', /\\d{4}-\\d{3}/],\n\t    ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n\t    ['YYYYYYMMDD', /[+-]\\d{10}/],\n\t    ['YYYYMMDD', /\\d{8}/],\n\t    // YYYYMM is NOT allowed by the standard\n\t    ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n\t    ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n\t    ['YYYYDDD', /\\d{7}/]\n\t];\n\t\n\t// iso time formats and regexes\n\tvar isoTimes = [\n\t    ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n\t    ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n\t    ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n\t    ['HH:mm', /\\d\\d:\\d\\d/],\n\t    ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n\t    ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n\t    ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n\t    ['HHmm', /\\d\\d\\d\\d/],\n\t    ['HH', /\\d\\d/]\n\t];\n\t\n\tvar aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\t\n\t// date from iso format\n\tfunction configFromISO(config) {\n\t    var i, l,\n\t        string = config._i,\n\t        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n\t        allowTime, dateFormat, timeFormat, tzFormat;\n\t\n\t    if (match) {\n\t        getParsingFlags(config).iso = true;\n\t\n\t        for (i = 0, l = isoDates.length; i < l; i++) {\n\t            if (isoDates[i][1].exec(match[1])) {\n\t                dateFormat = isoDates[i][0];\n\t                allowTime = isoDates[i][2] !== false;\n\t                break;\n\t            }\n\t        }\n\t        if (dateFormat == null) {\n\t            config._isValid = false;\n\t            return;\n\t        }\n\t        if (match[3]) {\n\t            for (i = 0, l = isoTimes.length; i < l; i++) {\n\t                if (isoTimes[i][1].exec(match[3])) {\n\t                    // match[2] should be 'T' or space\n\t                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\n\t                    break;\n\t                }\n\t            }\n\t            if (timeFormat == null) {\n\t                config._isValid = false;\n\t                return;\n\t            }\n\t        }\n\t        if (!allowTime && timeFormat != null) {\n\t            config._isValid = false;\n\t            return;\n\t        }\n\t        if (match[4]) {\n\t            if (tzRegex.exec(match[4])) {\n\t                tzFormat = 'Z';\n\t            } else {\n\t                config._isValid = false;\n\t                return;\n\t            }\n\t        }\n\t        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n\t        configFromStringAndFormat(config);\n\t    } else {\n\t        config._isValid = false;\n\t    }\n\t}\n\t\n\t// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n\tvar rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\t\n\tfunction extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n\t    var result = [\n\t        untruncateYear(yearStr),\n\t        defaultLocaleMonthsShort.indexOf(monthStr),\n\t        parseInt(dayStr, 10),\n\t        parseInt(hourStr, 10),\n\t        parseInt(minuteStr, 10)\n\t    ];\n\t\n\t    if (secondStr) {\n\t        result.push(parseInt(secondStr, 10));\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction untruncateYear(yearStr) {\n\t    var year = parseInt(yearStr, 10);\n\t    if (year <= 49) {\n\t        return 2000 + year;\n\t    } else if (year <= 999) {\n\t        return 1900 + year;\n\t    }\n\t    return year;\n\t}\n\t\n\tfunction preprocessRFC2822(s) {\n\t    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n\t    return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').trim();\n\t}\n\t\n\tfunction checkWeekday(weekdayStr, parsedInput, config) {\n\t    if (weekdayStr) {\n\t        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n\t        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n\t            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n\t        if (weekdayProvided !== weekdayActual) {\n\t            getParsingFlags(config).weekdayMismatch = true;\n\t            config._isValid = false;\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tvar obsOffsets = {\n\t    UT: 0,\n\t    GMT: 0,\n\t    EDT: -4 * 60,\n\t    EST: -5 * 60,\n\t    CDT: -5 * 60,\n\t    CST: -6 * 60,\n\t    MDT: -6 * 60,\n\t    MST: -7 * 60,\n\t    PDT: -7 * 60,\n\t    PST: -8 * 60\n\t};\n\t\n\tfunction calculateOffset(obsOffset, militaryOffset, numOffset) {\n\t    if (obsOffset) {\n\t        return obsOffsets[obsOffset];\n\t    } else if (militaryOffset) {\n\t        // the only allowed military tz is Z\n\t        return 0;\n\t    } else {\n\t        var hm = parseInt(numOffset, 10);\n\t        var m = hm % 100, h = (hm - m) / 100;\n\t        return h * 60 + m;\n\t    }\n\t}\n\t\n\t// date and time from ref 2822 format\n\tfunction configFromRFC2822(config) {\n\t    var match = rfc2822.exec(preprocessRFC2822(config._i));\n\t    if (match) {\n\t        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n\t        if (!checkWeekday(match[1], parsedArray, config)) {\n\t            return;\n\t        }\n\t\n\t        config._a = parsedArray;\n\t        config._tzm = calculateOffset(match[8], match[9], match[10]);\n\t\n\t        config._d = createUTCDate.apply(null, config._a);\n\t        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\t\n\t        getParsingFlags(config).rfc2822 = true;\n\t    } else {\n\t        config._isValid = false;\n\t    }\n\t}\n\t\n\t// date from iso format or fallback\n\tfunction configFromString(config) {\n\t    var matched = aspNetJsonRegex.exec(config._i);\n\t\n\t    if (matched !== null) {\n\t        config._d = new Date(+matched[1]);\n\t        return;\n\t    }\n\t\n\t    configFromISO(config);\n\t    if (config._isValid === false) {\n\t        delete config._isValid;\n\t    } else {\n\t        return;\n\t    }\n\t\n\t    configFromRFC2822(config);\n\t    if (config._isValid === false) {\n\t        delete config._isValid;\n\t    } else {\n\t        return;\n\t    }\n\t\n\t    // Final attempt, use Input Fallback\n\t    hooks.createFromInputFallback(config);\n\t}\n\t\n\thooks.createFromInputFallback = deprecate(\n\t    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n\t    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n\t    'discouraged and will be removed in an upcoming major release. Please refer to ' +\n\t    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n\t    function (config) {\n\t        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n\t    }\n\t);\n\t\n\t// constant that refers to the ISO standard\n\thooks.ISO_8601 = function () {};\n\t\n\t// constant that refers to the RFC 2822 form\n\thooks.RFC_2822 = function () {};\n\t\n\t// date from string and format string\n\tfunction configFromStringAndFormat(config) {\n\t    // TODO: Move this to another part of the creation flow to prevent circular deps\n\t    if (config._f === hooks.ISO_8601) {\n\t        configFromISO(config);\n\t        return;\n\t    }\n\t    if (config._f === hooks.RFC_2822) {\n\t        configFromRFC2822(config);\n\t        return;\n\t    }\n\t    config._a = [];\n\t    getParsingFlags(config).empty = true;\n\t\n\t    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\t    var string = '' + config._i,\n\t        i, parsedInput, tokens, token, skipped,\n\t        stringLength = string.length,\n\t        totalParsedInputLength = 0;\n\t\n\t    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\t\n\t    for (i = 0; i < tokens.length; i++) {\n\t        token = tokens[i];\n\t        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n\t        // console.log('token', token, 'parsedInput', parsedInput,\n\t        //         'regex', getParseRegexForToken(token, config));\n\t        if (parsedInput) {\n\t            skipped = string.substr(0, string.indexOf(parsedInput));\n\t            if (skipped.length > 0) {\n\t                getParsingFlags(config).unusedInput.push(skipped);\n\t            }\n\t            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n\t            totalParsedInputLength += parsedInput.length;\n\t        }\n\t        // don't parse if it's not a known token\n\t        if (formatTokenFunctions[token]) {\n\t            if (parsedInput) {\n\t                getParsingFlags(config).empty = false;\n\t            }\n\t            else {\n\t                getParsingFlags(config).unusedTokens.push(token);\n\t            }\n\t            addTimeToArrayFromToken(token, parsedInput, config);\n\t        }\n\t        else if (config._strict && !parsedInput) {\n\t            getParsingFlags(config).unusedTokens.push(token);\n\t        }\n\t    }\n\t\n\t    // add remaining unparsed input length to the string\n\t    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\t    if (string.length > 0) {\n\t        getParsingFlags(config).unusedInput.push(string);\n\t    }\n\t\n\t    // clear _12h flag if hour is <= 12\n\t    if (config._a[HOUR] <= 12 &&\n\t        getParsingFlags(config).bigHour === true &&\n\t        config._a[HOUR] > 0) {\n\t        getParsingFlags(config).bigHour = undefined;\n\t    }\n\t\n\t    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n\t    getParsingFlags(config).meridiem = config._meridiem;\n\t    // handle meridiem\n\t    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\t\n\t    configFromArray(config);\n\t    checkOverflow(config);\n\t}\n\t\n\t\n\tfunction meridiemFixWrap (locale, hour, meridiem) {\n\t    var isPm;\n\t\n\t    if (meridiem == null) {\n\t        // nothing to do\n\t        return hour;\n\t    }\n\t    if (locale.meridiemHour != null) {\n\t        return locale.meridiemHour(hour, meridiem);\n\t    } else if (locale.isPM != null) {\n\t        // Fallback\n\t        isPm = locale.isPM(meridiem);\n\t        if (isPm && hour < 12) {\n\t            hour += 12;\n\t        }\n\t        if (!isPm && hour === 12) {\n\t            hour = 0;\n\t        }\n\t        return hour;\n\t    } else {\n\t        // this is not supposed to happen\n\t        return hour;\n\t    }\n\t}\n\t\n\t// date from string and array of format strings\n\tfunction configFromStringAndArray(config) {\n\t    var tempConfig,\n\t        bestMoment,\n\t\n\t        scoreToBeat,\n\t        i,\n\t        currentScore;\n\t\n\t    if (config._f.length === 0) {\n\t        getParsingFlags(config).invalidFormat = true;\n\t        config._d = new Date(NaN);\n\t        return;\n\t    }\n\t\n\t    for (i = 0; i < config._f.length; i++) {\n\t        currentScore = 0;\n\t        tempConfig = copyConfig({}, config);\n\t        if (config._useUTC != null) {\n\t            tempConfig._useUTC = config._useUTC;\n\t        }\n\t        tempConfig._f = config._f[i];\n\t        configFromStringAndFormat(tempConfig);\n\t\n\t        if (!isValid(tempConfig)) {\n\t            continue;\n\t        }\n\t\n\t        // if there is any input that was not parsed add a penalty for that format\n\t        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\t\n\t        //or tokens\n\t        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\t\n\t        getParsingFlags(tempConfig).score = currentScore;\n\t\n\t        if (scoreToBeat == null || currentScore < scoreToBeat) {\n\t            scoreToBeat = currentScore;\n\t            bestMoment = tempConfig;\n\t        }\n\t    }\n\t\n\t    extend(config, bestMoment || tempConfig);\n\t}\n\t\n\tfunction configFromObject(config) {\n\t    if (config._d) {\n\t        return;\n\t    }\n\t\n\t    var i = normalizeObjectUnits(config._i);\n\t    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n\t        return obj && parseInt(obj, 10);\n\t    });\n\t\n\t    configFromArray(config);\n\t}\n\t\n\tfunction createFromConfig (config) {\n\t    var res = new Moment(checkOverflow(prepareConfig(config)));\n\t    if (res._nextDay) {\n\t        // Adding is smart enough around DST\n\t        res.add(1, 'd');\n\t        res._nextDay = undefined;\n\t    }\n\t\n\t    return res;\n\t}\n\t\n\tfunction prepareConfig (config) {\n\t    var input = config._i,\n\t        format = config._f;\n\t\n\t    config._locale = config._locale || getLocale(config._l);\n\t\n\t    if (input === null || (format === undefined && input === '')) {\n\t        return createInvalid({nullInput: true});\n\t    }\n\t\n\t    if (typeof input === 'string') {\n\t        config._i = input = config._locale.preparse(input);\n\t    }\n\t\n\t    if (isMoment(input)) {\n\t        return new Moment(checkOverflow(input));\n\t    } else if (isDate(input)) {\n\t        config._d = input;\n\t    } else if (isArray(format)) {\n\t        configFromStringAndArray(config);\n\t    } else if (format) {\n\t        configFromStringAndFormat(config);\n\t    }  else {\n\t        configFromInput(config);\n\t    }\n\t\n\t    if (!isValid(config)) {\n\t        config._d = null;\n\t    }\n\t\n\t    return config;\n\t}\n\t\n\tfunction configFromInput(config) {\n\t    var input = config._i;\n\t    if (isUndefined(input)) {\n\t        config._d = new Date(hooks.now());\n\t    } else if (isDate(input)) {\n\t        config._d = new Date(input.valueOf());\n\t    } else if (typeof input === 'string') {\n\t        configFromString(config);\n\t    } else if (isArray(input)) {\n\t        config._a = map(input.slice(0), function (obj) {\n\t            return parseInt(obj, 10);\n\t        });\n\t        configFromArray(config);\n\t    } else if (isObject(input)) {\n\t        configFromObject(config);\n\t    } else if (isNumber(input)) {\n\t        // from milliseconds\n\t        config._d = new Date(input);\n\t    } else {\n\t        hooks.createFromInputFallback(config);\n\t    }\n\t}\n\t\n\tfunction createLocalOrUTC (input, format, locale, strict, isUTC) {\n\t    var c = {};\n\t\n\t    if (locale === true || locale === false) {\n\t        strict = locale;\n\t        locale = undefined;\n\t    }\n\t\n\t    if ((isObject(input) && isObjectEmpty(input)) ||\n\t            (isArray(input) && input.length === 0)) {\n\t        input = undefined;\n\t    }\n\t    // object construction must be done this way.\n\t    // https://github.com/moment/moment/issues/1423\n\t    c._isAMomentObject = true;\n\t    c._useUTC = c._isUTC = isUTC;\n\t    c._l = locale;\n\t    c._i = input;\n\t    c._f = format;\n\t    c._strict = strict;\n\t\n\t    return createFromConfig(c);\n\t}\n\t\n\tfunction createLocal (input, format, locale, strict) {\n\t    return createLocalOrUTC(input, format, locale, strict, false);\n\t}\n\t\n\tvar prototypeMin = deprecate(\n\t    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n\t    function () {\n\t        var other = createLocal.apply(null, arguments);\n\t        if (this.isValid() && other.isValid()) {\n\t            return other < this ? this : other;\n\t        } else {\n\t            return createInvalid();\n\t        }\n\t    }\n\t);\n\t\n\tvar prototypeMax = deprecate(\n\t    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n\t    function () {\n\t        var other = createLocal.apply(null, arguments);\n\t        if (this.isValid() && other.isValid()) {\n\t            return other > this ? this : other;\n\t        } else {\n\t            return createInvalid();\n\t        }\n\t    }\n\t);\n\t\n\t// Pick a moment m from moments so that m[fn](other) is true for all\n\t// other. This relies on the function fn to be transitive.\n\t//\n\t// moments should either be an array of moment objects or an array, whose\n\t// first element is an array of moment objects.\n\tfunction pickBy(fn, moments) {\n\t    var res, i;\n\t    if (moments.length === 1 && isArray(moments[0])) {\n\t        moments = moments[0];\n\t    }\n\t    if (!moments.length) {\n\t        return createLocal();\n\t    }\n\t    res = moments[0];\n\t    for (i = 1; i < moments.length; ++i) {\n\t        if (!moments[i].isValid() || moments[i][fn](res)) {\n\t            res = moments[i];\n\t        }\n\t    }\n\t    return res;\n\t}\n\t\n\t// TODO: Use [].sort instead?\n\tfunction min () {\n\t    var args = [].slice.call(arguments, 0);\n\t\n\t    return pickBy('isBefore', args);\n\t}\n\t\n\tfunction max () {\n\t    var args = [].slice.call(arguments, 0);\n\t\n\t    return pickBy('isAfter', args);\n\t}\n\t\n\tvar now = function () {\n\t    return Date.now ? Date.now() : +(new Date());\n\t};\n\t\n\tvar ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\t\n\tfunction isDurationValid(m) {\n\t    for (var key in m) {\n\t        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    var unitHasDecimal = false;\n\t    for (var i = 0; i < ordering.length; ++i) {\n\t        if (m[ordering[i]]) {\n\t            if (unitHasDecimal) {\n\t                return false; // only allow non-integers for smallest unit\n\t            }\n\t            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n\t                unitHasDecimal = true;\n\t            }\n\t        }\n\t    }\n\t\n\t    return true;\n\t}\n\t\n\tfunction isValid$1() {\n\t    return this._isValid;\n\t}\n\t\n\tfunction createInvalid$1() {\n\t    return createDuration(NaN);\n\t}\n\t\n\tfunction Duration (duration) {\n\t    var normalizedInput = normalizeObjectUnits(duration),\n\t        years = normalizedInput.year || 0,\n\t        quarters = normalizedInput.quarter || 0,\n\t        months = normalizedInput.month || 0,\n\t        weeks = normalizedInput.week || 0,\n\t        days = normalizedInput.day || 0,\n\t        hours = normalizedInput.hour || 0,\n\t        minutes = normalizedInput.minute || 0,\n\t        seconds = normalizedInput.second || 0,\n\t        milliseconds = normalizedInput.millisecond || 0;\n\t\n\t    this._isValid = isDurationValid(normalizedInput);\n\t\n\t    // representation for dateAddRemove\n\t    this._milliseconds = +milliseconds +\n\t        seconds * 1e3 + // 1000\n\t        minutes * 6e4 + // 1000 * 60\n\t        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n\t    // Because of dateAddRemove treats 24 hours as different from a\n\t    // day when working around DST, we need to store them separately\n\t    this._days = +days +\n\t        weeks * 7;\n\t    // It is impossible to translate months into days without knowing\n\t    // which months you are are talking about, so we have to store\n\t    // it separately.\n\t    this._months = +months +\n\t        quarters * 3 +\n\t        years * 12;\n\t\n\t    this._data = {};\n\t\n\t    this._locale = getLocale();\n\t\n\t    this._bubble();\n\t}\n\t\n\tfunction isDuration (obj) {\n\t    return obj instanceof Duration;\n\t}\n\t\n\tfunction absRound (number) {\n\t    if (number < 0) {\n\t        return Math.round(-1 * number) * -1;\n\t    } else {\n\t        return Math.round(number);\n\t    }\n\t}\n\t\n\t// FORMATTING\n\t\n\tfunction offset (token, separator) {\n\t    addFormatToken(token, 0, 0, function () {\n\t        var offset = this.utcOffset();\n\t        var sign = '+';\n\t        if (offset < 0) {\n\t            offset = -offset;\n\t            sign = '-';\n\t        }\n\t        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n\t    });\n\t}\n\t\n\toffset('Z', ':');\n\toffset('ZZ', '');\n\t\n\t// PARSING\n\t\n\taddRegexToken('Z',  matchShortOffset);\n\taddRegexToken('ZZ', matchShortOffset);\n\taddParseToken(['Z', 'ZZ'], function (input, array, config) {\n\t    config._useUTC = true;\n\t    config._tzm = offsetFromString(matchShortOffset, input);\n\t});\n\t\n\t// HELPERS\n\t\n\t// timezone chunker\n\t// '+10:00' > ['10',  '00']\n\t// '-1530'  > ['-15', '30']\n\tvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\t\n\tfunction offsetFromString(matcher, string) {\n\t    var matches = (string || '').match(matcher);\n\t\n\t    if (matches === null) {\n\t        return null;\n\t    }\n\t\n\t    var chunk   = matches[matches.length - 1] || [];\n\t    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n\t    var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\t\n\t    return minutes === 0 ?\n\t      0 :\n\t      parts[0] === '+' ? minutes : -minutes;\n\t}\n\t\n\t// Return a moment from input, that is local/utc/zone equivalent to model.\n\tfunction cloneWithOffset(input, model) {\n\t    var res, diff;\n\t    if (model._isUTC) {\n\t        res = model.clone();\n\t        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n\t        // Use low-level api, because this fn is low-level api.\n\t        res._d.setTime(res._d.valueOf() + diff);\n\t        hooks.updateOffset(res, false);\n\t        return res;\n\t    } else {\n\t        return createLocal(input).local();\n\t    }\n\t}\n\t\n\tfunction getDateOffset (m) {\n\t    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n\t    // https://github.com/moment/moment/pull/1871\n\t    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n\t}\n\t\n\t// HOOKS\n\t\n\t// This function will be called whenever a moment is mutated.\n\t// It is intended to keep the offset in sync with the timezone.\n\thooks.updateOffset = function () {};\n\t\n\t// MOMENTS\n\t\n\t// keepLocalTime = true means only change the timezone, without\n\t// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n\t// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n\t// +0200, so we adjust the time as needed, to be valid.\n\t//\n\t// Keeping the time actually adds/subtracts (one hour)\n\t// from the actual represented time. That is why we call updateOffset\n\t// a second time. In case it wants us to change the offset again\n\t// _changeInProgress == true case, then we have to adjust, because\n\t// there is no such time in the given timezone.\n\tfunction getSetOffset (input, keepLocalTime, keepMinutes) {\n\t    var offset = this._offset || 0,\n\t        localAdjust;\n\t    if (!this.isValid()) {\n\t        return input != null ? this : NaN;\n\t    }\n\t    if (input != null) {\n\t        if (typeof input === 'string') {\n\t            input = offsetFromString(matchShortOffset, input);\n\t            if (input === null) {\n\t                return this;\n\t            }\n\t        } else if (Math.abs(input) < 16 && !keepMinutes) {\n\t            input = input * 60;\n\t        }\n\t        if (!this._isUTC && keepLocalTime) {\n\t            localAdjust = getDateOffset(this);\n\t        }\n\t        this._offset = input;\n\t        this._isUTC = true;\n\t        if (localAdjust != null) {\n\t            this.add(localAdjust, 'm');\n\t        }\n\t        if (offset !== input) {\n\t            if (!keepLocalTime || this._changeInProgress) {\n\t                addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n\t            } else if (!this._changeInProgress) {\n\t                this._changeInProgress = true;\n\t                hooks.updateOffset(this, true);\n\t                this._changeInProgress = null;\n\t            }\n\t        }\n\t        return this;\n\t    } else {\n\t        return this._isUTC ? offset : getDateOffset(this);\n\t    }\n\t}\n\t\n\tfunction getSetZone (input, keepLocalTime) {\n\t    if (input != null) {\n\t        if (typeof input !== 'string') {\n\t            input = -input;\n\t        }\n\t\n\t        this.utcOffset(input, keepLocalTime);\n\t\n\t        return this;\n\t    } else {\n\t        return -this.utcOffset();\n\t    }\n\t}\n\t\n\tfunction setOffsetToUTC (keepLocalTime) {\n\t    return this.utcOffset(0, keepLocalTime);\n\t}\n\t\n\tfunction setOffsetToLocal (keepLocalTime) {\n\t    if (this._isUTC) {\n\t        this.utcOffset(0, keepLocalTime);\n\t        this._isUTC = false;\n\t\n\t        if (keepLocalTime) {\n\t            this.subtract(getDateOffset(this), 'm');\n\t        }\n\t    }\n\t    return this;\n\t}\n\t\n\tfunction setOffsetToParsedOffset () {\n\t    if (this._tzm != null) {\n\t        this.utcOffset(this._tzm, false, true);\n\t    } else if (typeof this._i === 'string') {\n\t        var tZone = offsetFromString(matchOffset, this._i);\n\t        if (tZone != null) {\n\t            this.utcOffset(tZone);\n\t        }\n\t        else {\n\t            this.utcOffset(0, true);\n\t        }\n\t    }\n\t    return this;\n\t}\n\t\n\tfunction hasAlignedHourOffset (input) {\n\t    if (!this.isValid()) {\n\t        return false;\n\t    }\n\t    input = input ? createLocal(input).utcOffset() : 0;\n\t\n\t    return (this.utcOffset() - input) % 60 === 0;\n\t}\n\t\n\tfunction isDaylightSavingTime () {\n\t    return (\n\t        this.utcOffset() > this.clone().month(0).utcOffset() ||\n\t        this.utcOffset() > this.clone().month(5).utcOffset()\n\t    );\n\t}\n\t\n\tfunction isDaylightSavingTimeShifted () {\n\t    if (!isUndefined(this._isDSTShifted)) {\n\t        return this._isDSTShifted;\n\t    }\n\t\n\t    var c = {};\n\t\n\t    copyConfig(c, this);\n\t    c = prepareConfig(c);\n\t\n\t    if (c._a) {\n\t        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n\t        this._isDSTShifted = this.isValid() &&\n\t            compareArrays(c._a, other.toArray()) > 0;\n\t    } else {\n\t        this._isDSTShifted = false;\n\t    }\n\t\n\t    return this._isDSTShifted;\n\t}\n\t\n\tfunction isLocal () {\n\t    return this.isValid() ? !this._isUTC : false;\n\t}\n\t\n\tfunction isUtcOffset () {\n\t    return this.isValid() ? this._isUTC : false;\n\t}\n\t\n\tfunction isUtc () {\n\t    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n\t}\n\t\n\t// ASP.NET json date format regex\n\tvar aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\t\n\t// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n\t// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n\t// and further modified to allow for strings containing both week and day\n\tvar isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\t\n\tfunction createDuration (input, key) {\n\t    var duration = input,\n\t        // matching against regexp is expensive, do it on demand\n\t        match = null,\n\t        sign,\n\t        ret,\n\t        diffRes;\n\t\n\t    if (isDuration(input)) {\n\t        duration = {\n\t            ms : input._milliseconds,\n\t            d  : input._days,\n\t            M  : input._months\n\t        };\n\t    } else if (isNumber(input)) {\n\t        duration = {};\n\t        if (key) {\n\t            duration[key] = input;\n\t        } else {\n\t            duration.milliseconds = input;\n\t        }\n\t    } else if (!!(match = aspNetRegex.exec(input))) {\n\t        sign = (match[1] === '-') ? -1 : 1;\n\t        duration = {\n\t            y  : 0,\n\t            d  : toInt(match[DATE])                         * sign,\n\t            h  : toInt(match[HOUR])                         * sign,\n\t            m  : toInt(match[MINUTE])                       * sign,\n\t            s  : toInt(match[SECOND])                       * sign,\n\t            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n\t        };\n\t    } else if (!!(match = isoRegex.exec(input))) {\n\t        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n\t        duration = {\n\t            y : parseIso(match[2], sign),\n\t            M : parseIso(match[3], sign),\n\t            w : parseIso(match[4], sign),\n\t            d : parseIso(match[5], sign),\n\t            h : parseIso(match[6], sign),\n\t            m : parseIso(match[7], sign),\n\t            s : parseIso(match[8], sign)\n\t        };\n\t    } else if (duration == null) {// checks for null or undefined\n\t        duration = {};\n\t    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n\t        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\t\n\t        duration = {};\n\t        duration.ms = diffRes.milliseconds;\n\t        duration.M = diffRes.months;\n\t    }\n\t\n\t    ret = new Duration(duration);\n\t\n\t    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n\t        ret._locale = input._locale;\n\t    }\n\t\n\t    return ret;\n\t}\n\t\n\tcreateDuration.fn = Duration.prototype;\n\tcreateDuration.invalid = createInvalid$1;\n\t\n\tfunction parseIso (inp, sign) {\n\t    // We'd normally use ~~inp for this, but unfortunately it also\n\t    // converts floats to ints.\n\t    // inp may be undefined, so careful calling replace on it.\n\t    var res = inp && parseFloat(inp.replace(',', '.'));\n\t    // apply sign while we're at it\n\t    return (isNaN(res) ? 0 : res) * sign;\n\t}\n\t\n\tfunction positiveMomentsDifference(base, other) {\n\t    var res = {milliseconds: 0, months: 0};\n\t\n\t    res.months = other.month() - base.month() +\n\t        (other.year() - base.year()) * 12;\n\t    if (base.clone().add(res.months, 'M').isAfter(other)) {\n\t        --res.months;\n\t    }\n\t\n\t    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\t\n\t    return res;\n\t}\n\t\n\tfunction momentsDifference(base, other) {\n\t    var res;\n\t    if (!(base.isValid() && other.isValid())) {\n\t        return {milliseconds: 0, months: 0};\n\t    }\n\t\n\t    other = cloneWithOffset(other, base);\n\t    if (base.isBefore(other)) {\n\t        res = positiveMomentsDifference(base, other);\n\t    } else {\n\t        res = positiveMomentsDifference(other, base);\n\t        res.milliseconds = -res.milliseconds;\n\t        res.months = -res.months;\n\t    }\n\t\n\t    return res;\n\t}\n\t\n\t// TODO: remove 'name' arg after deprecation is removed\n\tfunction createAdder(direction, name) {\n\t    return function (val, period) {\n\t        var dur, tmp;\n\t        //invert the arguments, but complain about it\n\t        if (period !== null && !isNaN(+period)) {\n\t            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n\t            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n\t            tmp = val; val = period; period = tmp;\n\t        }\n\t\n\t        val = typeof val === 'string' ? +val : val;\n\t        dur = createDuration(val, period);\n\t        addSubtract(this, dur, direction);\n\t        return this;\n\t    };\n\t}\n\t\n\tfunction addSubtract (mom, duration, isAdding, updateOffset) {\n\t    var milliseconds = duration._milliseconds,\n\t        days = absRound(duration._days),\n\t        months = absRound(duration._months);\n\t\n\t    if (!mom.isValid()) {\n\t        // No op\n\t        return;\n\t    }\n\t\n\t    updateOffset = updateOffset == null ? true : updateOffset;\n\t\n\t    if (months) {\n\t        setMonth(mom, get(mom, 'Month') + months * isAdding);\n\t    }\n\t    if (days) {\n\t        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n\t    }\n\t    if (milliseconds) {\n\t        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n\t    }\n\t    if (updateOffset) {\n\t        hooks.updateOffset(mom, days || months);\n\t    }\n\t}\n\t\n\tvar add      = createAdder(1, 'add');\n\tvar subtract = createAdder(-1, 'subtract');\n\t\n\tfunction getCalendarFormat(myMoment, now) {\n\t    var diff = myMoment.diff(now, 'days', true);\n\t    return diff < -6 ? 'sameElse' :\n\t            diff < -1 ? 'lastWeek' :\n\t            diff < 0 ? 'lastDay' :\n\t            diff < 1 ? 'sameDay' :\n\t            diff < 2 ? 'nextDay' :\n\t            diff < 7 ? 'nextWeek' : 'sameElse';\n\t}\n\t\n\tfunction calendar$1 (time, formats) {\n\t    // We want to compare the start of today, vs this.\n\t    // Getting start-of-today depends on whether we're local/utc/offset or not.\n\t    var now = time || createLocal(),\n\t        sod = cloneWithOffset(now, this).startOf('day'),\n\t        format = hooks.calendarFormat(this, sod) || 'sameElse';\n\t\n\t    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\t\n\t    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n\t}\n\t\n\tfunction clone () {\n\t    return new Moment(this);\n\t}\n\t\n\tfunction isAfter (input, units) {\n\t    var localInput = isMoment(input) ? input : createLocal(input);\n\t    if (!(this.isValid() && localInput.isValid())) {\n\t        return false;\n\t    }\n\t    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n\t    if (units === 'millisecond') {\n\t        return this.valueOf() > localInput.valueOf();\n\t    } else {\n\t        return localInput.valueOf() < this.clone().startOf(units).valueOf();\n\t    }\n\t}\n\t\n\tfunction isBefore (input, units) {\n\t    var localInput = isMoment(input) ? input : createLocal(input);\n\t    if (!(this.isValid() && localInput.isValid())) {\n\t        return false;\n\t    }\n\t    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n\t    if (units === 'millisecond') {\n\t        return this.valueOf() < localInput.valueOf();\n\t    } else {\n\t        return this.clone().endOf(units).valueOf() < localInput.valueOf();\n\t    }\n\t}\n\t\n\tfunction isBetween (from, to, units, inclusivity) {\n\t    inclusivity = inclusivity || '()';\n\t    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n\t        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n\t}\n\t\n\tfunction isSame (input, units) {\n\t    var localInput = isMoment(input) ? input : createLocal(input),\n\t        inputMs;\n\t    if (!(this.isValid() && localInput.isValid())) {\n\t        return false;\n\t    }\n\t    units = normalizeUnits(units || 'millisecond');\n\t    if (units === 'millisecond') {\n\t        return this.valueOf() === localInput.valueOf();\n\t    } else {\n\t        inputMs = localInput.valueOf();\n\t        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n\t    }\n\t}\n\t\n\tfunction isSameOrAfter (input, units) {\n\t    return this.isSame(input, units) || this.isAfter(input,units);\n\t}\n\t\n\tfunction isSameOrBefore (input, units) {\n\t    return this.isSame(input, units) || this.isBefore(input,units);\n\t}\n\t\n\tfunction diff (input, units, asFloat) {\n\t    var that,\n\t        zoneDelta,\n\t        delta, output;\n\t\n\t    if (!this.isValid()) {\n\t        return NaN;\n\t    }\n\t\n\t    that = cloneWithOffset(input, this);\n\t\n\t    if (!that.isValid()) {\n\t        return NaN;\n\t    }\n\t\n\t    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\t\n\t    units = normalizeUnits(units);\n\t\n\t    switch (units) {\n\t        case 'year': output = monthDiff(this, that) / 12; break;\n\t        case 'month': output = monthDiff(this, that); break;\n\t        case 'quarter': output = monthDiff(this, that) / 3; break;\n\t        case 'second': output = (this - that) / 1e3; break; // 1000\n\t        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n\t        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n\t        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n\t        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n\t        default: output = this - that;\n\t    }\n\t\n\t    return asFloat ? output : absFloor(output);\n\t}\n\t\n\tfunction monthDiff (a, b) {\n\t    // difference in months\n\t    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n\t        // b is in (anchor - 1 month, anchor + 1 month)\n\t        anchor = a.clone().add(wholeMonthDiff, 'months'),\n\t        anchor2, adjust;\n\t\n\t    if (b - anchor < 0) {\n\t        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n\t        // linear across the month\n\t        adjust = (b - anchor) / (anchor - anchor2);\n\t    } else {\n\t        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n\t        // linear across the month\n\t        adjust = (b - anchor) / (anchor2 - anchor);\n\t    }\n\t\n\t    //check for negative zero, return zero if negative zero\n\t    return -(wholeMonthDiff + adjust) || 0;\n\t}\n\t\n\thooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n\thooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\t\n\tfunction toString () {\n\t    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n\t}\n\t\n\tfunction toISOString(keepOffset) {\n\t    if (!this.isValid()) {\n\t        return null;\n\t    }\n\t    var utc = keepOffset !== true;\n\t    var m = utc ? this.clone().utc() : this;\n\t    if (m.year() < 0 || m.year() > 9999) {\n\t        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n\t    }\n\t    if (isFunction(Date.prototype.toISOString)) {\n\t        // native implementation is ~50x faster, use it when we can\n\t        if (utc) {\n\t            return this.toDate().toISOString();\n\t        } else {\n\t            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));\n\t        }\n\t    }\n\t    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n\t}\n\t\n\t/**\n\t * Return a human readable representation of a moment that can\n\t * also be evaluated to get a new moment which is the same\n\t *\n\t * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n\t */\n\tfunction inspect () {\n\t    if (!this.isValid()) {\n\t        return 'moment.invalid(/* ' + this._i + ' */)';\n\t    }\n\t    var func = 'moment';\n\t    var zone = '';\n\t    if (!this.isLocal()) {\n\t        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n\t        zone = 'Z';\n\t    }\n\t    var prefix = '[' + func + '(\"]';\n\t    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n\t    var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n\t    var suffix = zone + '[\")]';\n\t\n\t    return this.format(prefix + year + datetime + suffix);\n\t}\n\t\n\tfunction format (inputString) {\n\t    if (!inputString) {\n\t        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n\t    }\n\t    var output = formatMoment(this, inputString);\n\t    return this.localeData().postformat(output);\n\t}\n\t\n\tfunction from (time, withoutSuffix) {\n\t    if (this.isValid() &&\n\t            ((isMoment(time) && time.isValid()) ||\n\t             createLocal(time).isValid())) {\n\t        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n\t    } else {\n\t        return this.localeData().invalidDate();\n\t    }\n\t}\n\t\n\tfunction fromNow (withoutSuffix) {\n\t    return this.from(createLocal(), withoutSuffix);\n\t}\n\t\n\tfunction to (time, withoutSuffix) {\n\t    if (this.isValid() &&\n\t            ((isMoment(time) && time.isValid()) ||\n\t             createLocal(time).isValid())) {\n\t        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n\t    } else {\n\t        return this.localeData().invalidDate();\n\t    }\n\t}\n\t\n\tfunction toNow (withoutSuffix) {\n\t    return this.to(createLocal(), withoutSuffix);\n\t}\n\t\n\t// If passed a locale key, it will set the locale for this\n\t// instance.  Otherwise, it will return the locale configuration\n\t// variables for this instance.\n\tfunction locale (key) {\n\t    var newLocaleData;\n\t\n\t    if (key === undefined) {\n\t        return this._locale._abbr;\n\t    } else {\n\t        newLocaleData = getLocale(key);\n\t        if (newLocaleData != null) {\n\t            this._locale = newLocaleData;\n\t        }\n\t        return this;\n\t    }\n\t}\n\t\n\tvar lang = deprecate(\n\t    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n\t    function (key) {\n\t        if (key === undefined) {\n\t            return this.localeData();\n\t        } else {\n\t            return this.locale(key);\n\t        }\n\t    }\n\t);\n\t\n\tfunction localeData () {\n\t    return this._locale;\n\t}\n\t\n\tfunction startOf (units) {\n\t    units = normalizeUnits(units);\n\t    // the following switch intentionally omits break keywords\n\t    // to utilize falling through the cases.\n\t    switch (units) {\n\t        case 'year':\n\t            this.month(0);\n\t            /* falls through */\n\t        case 'quarter':\n\t        case 'month':\n\t            this.date(1);\n\t            /* falls through */\n\t        case 'week':\n\t        case 'isoWeek':\n\t        case 'day':\n\t        case 'date':\n\t            this.hours(0);\n\t            /* falls through */\n\t        case 'hour':\n\t            this.minutes(0);\n\t            /* falls through */\n\t        case 'minute':\n\t            this.seconds(0);\n\t            /* falls through */\n\t        case 'second':\n\t            this.milliseconds(0);\n\t    }\n\t\n\t    // weeks are a special case\n\t    if (units === 'week') {\n\t        this.weekday(0);\n\t    }\n\t    if (units === 'isoWeek') {\n\t        this.isoWeekday(1);\n\t    }\n\t\n\t    // quarters are also special\n\t    if (units === 'quarter') {\n\t        this.month(Math.floor(this.month() / 3) * 3);\n\t    }\n\t\n\t    return this;\n\t}\n\t\n\tfunction endOf (units) {\n\t    units = normalizeUnits(units);\n\t    if (units === undefined || units === 'millisecond') {\n\t        return this;\n\t    }\n\t\n\t    // 'date' is an alias for 'day', so it should be considered as such.\n\t    if (units === 'date') {\n\t        units = 'day';\n\t    }\n\t\n\t    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n\t}\n\t\n\tfunction valueOf () {\n\t    return this._d.valueOf() - ((this._offset || 0) * 60000);\n\t}\n\t\n\tfunction unix () {\n\t    return Math.floor(this.valueOf() / 1000);\n\t}\n\t\n\tfunction toDate () {\n\t    return new Date(this.valueOf());\n\t}\n\t\n\tfunction toArray () {\n\t    var m = this;\n\t    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n\t}\n\t\n\tfunction toObject () {\n\t    var m = this;\n\t    return {\n\t        years: m.year(),\n\t        months: m.month(),\n\t        date: m.date(),\n\t        hours: m.hours(),\n\t        minutes: m.minutes(),\n\t        seconds: m.seconds(),\n\t        milliseconds: m.milliseconds()\n\t    };\n\t}\n\t\n\tfunction toJSON () {\n\t    // new Date(NaN).toJSON() === null\n\t    return this.isValid() ? this.toISOString() : null;\n\t}\n\t\n\tfunction isValid$2 () {\n\t    return isValid(this);\n\t}\n\t\n\tfunction parsingFlags () {\n\t    return extend({}, getParsingFlags(this));\n\t}\n\t\n\tfunction invalidAt () {\n\t    return getParsingFlags(this).overflow;\n\t}\n\t\n\tfunction creationData() {\n\t    return {\n\t        input: this._i,\n\t        format: this._f,\n\t        locale: this._locale,\n\t        isUTC: this._isUTC,\n\t        strict: this._strict\n\t    };\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken(0, ['gg', 2], 0, function () {\n\t    return this.weekYear() % 100;\n\t});\n\t\n\taddFormatToken(0, ['GG', 2], 0, function () {\n\t    return this.isoWeekYear() % 100;\n\t});\n\t\n\tfunction addWeekYearFormatToken (token, getter) {\n\t    addFormatToken(0, [token, token.length], 0, getter);\n\t}\n\t\n\taddWeekYearFormatToken('gggg',     'weekYear');\n\taddWeekYearFormatToken('ggggg',    'weekYear');\n\taddWeekYearFormatToken('GGGG',  'isoWeekYear');\n\taddWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('weekYear', 'gg');\n\taddUnitAlias('isoWeekYear', 'GG');\n\t\n\t// PRIORITY\n\t\n\taddUnitPriority('weekYear', 1);\n\taddUnitPriority('isoWeekYear', 1);\n\t\n\t\n\t// PARSING\n\t\n\taddRegexToken('G',      matchSigned);\n\taddRegexToken('g',      matchSigned);\n\taddRegexToken('GG',     match1to2, match2);\n\taddRegexToken('gg',     match1to2, match2);\n\taddRegexToken('GGGG',   match1to4, match4);\n\taddRegexToken('gggg',   match1to4, match4);\n\taddRegexToken('GGGGG',  match1to6, match6);\n\taddRegexToken('ggggg',  match1to6, match6);\n\t\n\taddWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n\t    week[token.substr(0, 2)] = toInt(input);\n\t});\n\t\n\taddWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n\t    week[token] = hooks.parseTwoDigitYear(input);\n\t});\n\t\n\t// MOMENTS\n\t\n\tfunction getSetWeekYear (input) {\n\t    return getSetWeekYearHelper.call(this,\n\t            input,\n\t            this.week(),\n\t            this.weekday(),\n\t            this.localeData()._week.dow,\n\t            this.localeData()._week.doy);\n\t}\n\t\n\tfunction getSetISOWeekYear (input) {\n\t    return getSetWeekYearHelper.call(this,\n\t            input, this.isoWeek(), this.isoWeekday(), 1, 4);\n\t}\n\t\n\tfunction getISOWeeksInYear () {\n\t    return weeksInYear(this.year(), 1, 4);\n\t}\n\t\n\tfunction getWeeksInYear () {\n\t    var weekInfo = this.localeData()._week;\n\t    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n\t}\n\t\n\tfunction getSetWeekYearHelper(input, week, weekday, dow, doy) {\n\t    var weeksTarget;\n\t    if (input == null) {\n\t        return weekOfYear(this, dow, doy).year;\n\t    } else {\n\t        weeksTarget = weeksInYear(input, dow, doy);\n\t        if (week > weeksTarget) {\n\t            week = weeksTarget;\n\t        }\n\t        return setWeekAll.call(this, input, week, weekday, dow, doy);\n\t    }\n\t}\n\t\n\tfunction setWeekAll(weekYear, week, weekday, dow, doy) {\n\t    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n\t        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\t\n\t    this.year(date.getUTCFullYear());\n\t    this.month(date.getUTCMonth());\n\t    this.date(date.getUTCDate());\n\t    return this;\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('Q', 0, 'Qo', 'quarter');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('quarter', 'Q');\n\t\n\t// PRIORITY\n\t\n\taddUnitPriority('quarter', 7);\n\t\n\t// PARSING\n\t\n\taddRegexToken('Q', match1);\n\taddParseToken('Q', function (input, array) {\n\t    array[MONTH] = (toInt(input) - 1) * 3;\n\t});\n\t\n\t// MOMENTS\n\t\n\tfunction getSetQuarter (input) {\n\t    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('D', ['DD', 2], 'Do', 'date');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('date', 'D');\n\t\n\t// PRIOROITY\n\taddUnitPriority('date', 9);\n\t\n\t// PARSING\n\t\n\taddRegexToken('D',  match1to2);\n\taddRegexToken('DD', match1to2, match2);\n\taddRegexToken('Do', function (isStrict, locale) {\n\t    // TODO: Remove \"ordinalParse\" fallback in next major release.\n\t    return isStrict ?\n\t      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n\t      locale._dayOfMonthOrdinalParseLenient;\n\t});\n\t\n\taddParseToken(['D', 'DD'], DATE);\n\taddParseToken('Do', function (input, array) {\n\t    array[DATE] = toInt(input.match(match1to2)[0]);\n\t});\n\t\n\t// MOMENTS\n\t\n\tvar getSetDayOfMonth = makeGetSet('Date', true);\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('dayOfYear', 'DDD');\n\t\n\t// PRIORITY\n\taddUnitPriority('dayOfYear', 4);\n\t\n\t// PARSING\n\t\n\taddRegexToken('DDD',  match1to3);\n\taddRegexToken('DDDD', match3);\n\taddParseToken(['DDD', 'DDDD'], function (input, array, config) {\n\t    config._dayOfYear = toInt(input);\n\t});\n\t\n\t// HELPERS\n\t\n\t// MOMENTS\n\t\n\tfunction getSetDayOfYear (input) {\n\t    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n\t    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n\t}\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('m', ['mm', 2], 0, 'minute');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('minute', 'm');\n\t\n\t// PRIORITY\n\t\n\taddUnitPriority('minute', 14);\n\t\n\t// PARSING\n\t\n\taddRegexToken('m',  match1to2);\n\taddRegexToken('mm', match1to2, match2);\n\taddParseToken(['m', 'mm'], MINUTE);\n\t\n\t// MOMENTS\n\t\n\tvar getSetMinute = makeGetSet('Minutes', false);\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('s', ['ss', 2], 0, 'second');\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('second', 's');\n\t\n\t// PRIORITY\n\t\n\taddUnitPriority('second', 15);\n\t\n\t// PARSING\n\t\n\taddRegexToken('s',  match1to2);\n\taddRegexToken('ss', match1to2, match2);\n\taddParseToken(['s', 'ss'], SECOND);\n\t\n\t// MOMENTS\n\t\n\tvar getSetSecond = makeGetSet('Seconds', false);\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('S', 0, 0, function () {\n\t    return ~~(this.millisecond() / 100);\n\t});\n\t\n\taddFormatToken(0, ['SS', 2], 0, function () {\n\t    return ~~(this.millisecond() / 10);\n\t});\n\t\n\taddFormatToken(0, ['SSS', 3], 0, 'millisecond');\n\taddFormatToken(0, ['SSSS', 4], 0, function () {\n\t    return this.millisecond() * 10;\n\t});\n\taddFormatToken(0, ['SSSSS', 5], 0, function () {\n\t    return this.millisecond() * 100;\n\t});\n\taddFormatToken(0, ['SSSSSS', 6], 0, function () {\n\t    return this.millisecond() * 1000;\n\t});\n\taddFormatToken(0, ['SSSSSSS', 7], 0, function () {\n\t    return this.millisecond() * 10000;\n\t});\n\taddFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n\t    return this.millisecond() * 100000;\n\t});\n\taddFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n\t    return this.millisecond() * 1000000;\n\t});\n\t\n\t\n\t// ALIASES\n\t\n\taddUnitAlias('millisecond', 'ms');\n\t\n\t// PRIORITY\n\t\n\taddUnitPriority('millisecond', 16);\n\t\n\t// PARSING\n\t\n\taddRegexToken('S',    match1to3, match1);\n\taddRegexToken('SS',   match1to3, match2);\n\taddRegexToken('SSS',  match1to3, match3);\n\t\n\tvar token;\n\tfor (token = 'SSSS'; token.length <= 9; token += 'S') {\n\t    addRegexToken(token, matchUnsigned);\n\t}\n\t\n\tfunction parseMs(input, array) {\n\t    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n\t}\n\t\n\tfor (token = 'S'; token.length <= 9; token += 'S') {\n\t    addParseToken(token, parseMs);\n\t}\n\t// MOMENTS\n\t\n\tvar getSetMillisecond = makeGetSet('Milliseconds', false);\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('z',  0, 0, 'zoneAbbr');\n\taddFormatToken('zz', 0, 0, 'zoneName');\n\t\n\t// MOMENTS\n\t\n\tfunction getZoneAbbr () {\n\t    return this._isUTC ? 'UTC' : '';\n\t}\n\t\n\tfunction getZoneName () {\n\t    return this._isUTC ? 'Coordinated Universal Time' : '';\n\t}\n\t\n\tvar proto = Moment.prototype;\n\t\n\tproto.add               = add;\n\tproto.calendar          = calendar$1;\n\tproto.clone             = clone;\n\tproto.diff              = diff;\n\tproto.endOf             = endOf;\n\tproto.format            = format;\n\tproto.from              = from;\n\tproto.fromNow           = fromNow;\n\tproto.to                = to;\n\tproto.toNow             = toNow;\n\tproto.get               = stringGet;\n\tproto.invalidAt         = invalidAt;\n\tproto.isAfter           = isAfter;\n\tproto.isBefore          = isBefore;\n\tproto.isBetween         = isBetween;\n\tproto.isSame            = isSame;\n\tproto.isSameOrAfter     = isSameOrAfter;\n\tproto.isSameOrBefore    = isSameOrBefore;\n\tproto.isValid           = isValid$2;\n\tproto.lang              = lang;\n\tproto.locale            = locale;\n\tproto.localeData        = localeData;\n\tproto.max               = prototypeMax;\n\tproto.min               = prototypeMin;\n\tproto.parsingFlags      = parsingFlags;\n\tproto.set               = stringSet;\n\tproto.startOf           = startOf;\n\tproto.subtract          = subtract;\n\tproto.toArray           = toArray;\n\tproto.toObject          = toObject;\n\tproto.toDate            = toDate;\n\tproto.toISOString       = toISOString;\n\tproto.inspect           = inspect;\n\tproto.toJSON            = toJSON;\n\tproto.toString          = toString;\n\tproto.unix              = unix;\n\tproto.valueOf           = valueOf;\n\tproto.creationData      = creationData;\n\t\n\t// Year\n\tproto.year       = getSetYear;\n\tproto.isLeapYear = getIsLeapYear;\n\t\n\t// Week Year\n\tproto.weekYear    = getSetWeekYear;\n\tproto.isoWeekYear = getSetISOWeekYear;\n\t\n\t// Quarter\n\tproto.quarter = proto.quarters = getSetQuarter;\n\t\n\t// Month\n\tproto.month       = getSetMonth;\n\tproto.daysInMonth = getDaysInMonth;\n\t\n\t// Week\n\tproto.week           = proto.weeks        = getSetWeek;\n\tproto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n\tproto.weeksInYear    = getWeeksInYear;\n\tproto.isoWeeksInYear = getISOWeeksInYear;\n\t\n\t// Day\n\tproto.date       = getSetDayOfMonth;\n\tproto.day        = proto.days             = getSetDayOfWeek;\n\tproto.weekday    = getSetLocaleDayOfWeek;\n\tproto.isoWeekday = getSetISODayOfWeek;\n\tproto.dayOfYear  = getSetDayOfYear;\n\t\n\t// Hour\n\tproto.hour = proto.hours = getSetHour;\n\t\n\t// Minute\n\tproto.minute = proto.minutes = getSetMinute;\n\t\n\t// Second\n\tproto.second = proto.seconds = getSetSecond;\n\t\n\t// Millisecond\n\tproto.millisecond = proto.milliseconds = getSetMillisecond;\n\t\n\t// Offset\n\tproto.utcOffset            = getSetOffset;\n\tproto.utc                  = setOffsetToUTC;\n\tproto.local                = setOffsetToLocal;\n\tproto.parseZone            = setOffsetToParsedOffset;\n\tproto.hasAlignedHourOffset = hasAlignedHourOffset;\n\tproto.isDST                = isDaylightSavingTime;\n\tproto.isLocal              = isLocal;\n\tproto.isUtcOffset          = isUtcOffset;\n\tproto.isUtc                = isUtc;\n\tproto.isUTC                = isUtc;\n\t\n\t// Timezone\n\tproto.zoneAbbr = getZoneAbbr;\n\tproto.zoneName = getZoneName;\n\t\n\t// Deprecations\n\tproto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n\tproto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n\tproto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n\tproto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n\tproto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\t\n\tfunction createUnix (input) {\n\t    return createLocal(input * 1000);\n\t}\n\t\n\tfunction createInZone () {\n\t    return createLocal.apply(null, arguments).parseZone();\n\t}\n\t\n\tfunction preParsePostFormat (string) {\n\t    return string;\n\t}\n\t\n\tvar proto$1 = Locale.prototype;\n\t\n\tproto$1.calendar        = calendar;\n\tproto$1.longDateFormat  = longDateFormat;\n\tproto$1.invalidDate     = invalidDate;\n\tproto$1.ordinal         = ordinal;\n\tproto$1.preparse        = preParsePostFormat;\n\tproto$1.postformat      = preParsePostFormat;\n\tproto$1.relativeTime    = relativeTime;\n\tproto$1.pastFuture      = pastFuture;\n\tproto$1.set             = set;\n\t\n\t// Month\n\tproto$1.months            =        localeMonths;\n\tproto$1.monthsShort       =        localeMonthsShort;\n\tproto$1.monthsParse       =        localeMonthsParse;\n\tproto$1.monthsRegex       = monthsRegex;\n\tproto$1.monthsShortRegex  = monthsShortRegex;\n\t\n\t// Week\n\tproto$1.week = localeWeek;\n\tproto$1.firstDayOfYear = localeFirstDayOfYear;\n\tproto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\t\n\t// Day of Week\n\tproto$1.weekdays       =        localeWeekdays;\n\tproto$1.weekdaysMin    =        localeWeekdaysMin;\n\tproto$1.weekdaysShort  =        localeWeekdaysShort;\n\tproto$1.weekdaysParse  =        localeWeekdaysParse;\n\t\n\tproto$1.weekdaysRegex       =        weekdaysRegex;\n\tproto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n\tproto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\t\n\t// Hours\n\tproto$1.isPM = localeIsPM;\n\tproto$1.meridiem = localeMeridiem;\n\t\n\tfunction get$1 (format, index, field, setter) {\n\t    var locale = getLocale();\n\t    var utc = createUTC().set(setter, index);\n\t    return locale[field](utc, format);\n\t}\n\t\n\tfunction listMonthsImpl (format, index, field) {\n\t    if (isNumber(format)) {\n\t        index = format;\n\t        format = undefined;\n\t    }\n\t\n\t    format = format || '';\n\t\n\t    if (index != null) {\n\t        return get$1(format, index, field, 'month');\n\t    }\n\t\n\t    var i;\n\t    var out = [];\n\t    for (i = 0; i < 12; i++) {\n\t        out[i] = get$1(format, i, field, 'month');\n\t    }\n\t    return out;\n\t}\n\t\n\t// ()\n\t// (5)\n\t// (fmt, 5)\n\t// (fmt)\n\t// (true)\n\t// (true, 5)\n\t// (true, fmt, 5)\n\t// (true, fmt)\n\tfunction listWeekdaysImpl (localeSorted, format, index, field) {\n\t    if (typeof localeSorted === 'boolean') {\n\t        if (isNumber(format)) {\n\t            index = format;\n\t            format = undefined;\n\t        }\n\t\n\t        format = format || '';\n\t    } else {\n\t        format = localeSorted;\n\t        index = format;\n\t        localeSorted = false;\n\t\n\t        if (isNumber(format)) {\n\t            index = format;\n\t            format = undefined;\n\t        }\n\t\n\t        format = format || '';\n\t    }\n\t\n\t    var locale = getLocale(),\n\t        shift = localeSorted ? locale._week.dow : 0;\n\t\n\t    if (index != null) {\n\t        return get$1(format, (index + shift) % 7, field, 'day');\n\t    }\n\t\n\t    var i;\n\t    var out = [];\n\t    for (i = 0; i < 7; i++) {\n\t        out[i] = get$1(format, (i + shift) % 7, field, 'day');\n\t    }\n\t    return out;\n\t}\n\t\n\tfunction listMonths (format, index) {\n\t    return listMonthsImpl(format, index, 'months');\n\t}\n\t\n\tfunction listMonthsShort (format, index) {\n\t    return listMonthsImpl(format, index, 'monthsShort');\n\t}\n\t\n\tfunction listWeekdays (localeSorted, format, index) {\n\t    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n\t}\n\t\n\tfunction listWeekdaysShort (localeSorted, format, index) {\n\t    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n\t}\n\t\n\tfunction listWeekdaysMin (localeSorted, format, index) {\n\t    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n\t}\n\t\n\tgetSetGlobalLocale('en', {\n\t    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n\t    ordinal : function (number) {\n\t        var b = number % 10,\n\t            output = (toInt(number % 100 / 10) === 1) ? 'th' :\n\t            (b === 1) ? 'st' :\n\t            (b === 2) ? 'nd' :\n\t            (b === 3) ? 'rd' : 'th';\n\t        return number + output;\n\t    }\n\t});\n\t\n\t// Side effect imports\n\thooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n\thooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\t\n\tvar mathAbs = Math.abs;\n\t\n\tfunction abs () {\n\t    var data           = this._data;\n\t\n\t    this._milliseconds = mathAbs(this._milliseconds);\n\t    this._days         = mathAbs(this._days);\n\t    this._months       = mathAbs(this._months);\n\t\n\t    data.milliseconds  = mathAbs(data.milliseconds);\n\t    data.seconds       = mathAbs(data.seconds);\n\t    data.minutes       = mathAbs(data.minutes);\n\t    data.hours         = mathAbs(data.hours);\n\t    data.months        = mathAbs(data.months);\n\t    data.years         = mathAbs(data.years);\n\t\n\t    return this;\n\t}\n\t\n\tfunction addSubtract$1 (duration, input, value, direction) {\n\t    var other = createDuration(input, value);\n\t\n\t    duration._milliseconds += direction * other._milliseconds;\n\t    duration._days         += direction * other._days;\n\t    duration._months       += direction * other._months;\n\t\n\t    return duration._bubble();\n\t}\n\t\n\t// supports only 2.0-style add(1, 's') or add(duration)\n\tfunction add$1 (input, value) {\n\t    return addSubtract$1(this, input, value, 1);\n\t}\n\t\n\t// supports only 2.0-style subtract(1, 's') or subtract(duration)\n\tfunction subtract$1 (input, value) {\n\t    return addSubtract$1(this, input, value, -1);\n\t}\n\t\n\tfunction absCeil (number) {\n\t    if (number < 0) {\n\t        return Math.floor(number);\n\t    } else {\n\t        return Math.ceil(number);\n\t    }\n\t}\n\t\n\tfunction bubble () {\n\t    var milliseconds = this._milliseconds;\n\t    var days         = this._days;\n\t    var months       = this._months;\n\t    var data         = this._data;\n\t    var seconds, minutes, hours, years, monthsFromDays;\n\t\n\t    // if we have a mix of positive and negative values, bubble down first\n\t    // check: https://github.com/moment/moment/issues/2166\n\t    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n\t            (milliseconds <= 0 && days <= 0 && months <= 0))) {\n\t        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n\t        days = 0;\n\t        months = 0;\n\t    }\n\t\n\t    // The following code bubbles up values, see the tests for\n\t    // examples of what that means.\n\t    data.milliseconds = milliseconds % 1000;\n\t\n\t    seconds           = absFloor(milliseconds / 1000);\n\t    data.seconds      = seconds % 60;\n\t\n\t    minutes           = absFloor(seconds / 60);\n\t    data.minutes      = minutes % 60;\n\t\n\t    hours             = absFloor(minutes / 60);\n\t    data.hours        = hours % 24;\n\t\n\t    days += absFloor(hours / 24);\n\t\n\t    // convert days to months\n\t    monthsFromDays = absFloor(daysToMonths(days));\n\t    months += monthsFromDays;\n\t    days -= absCeil(monthsToDays(monthsFromDays));\n\t\n\t    // 12 months -> 1 year\n\t    years = absFloor(months / 12);\n\t    months %= 12;\n\t\n\t    data.days   = days;\n\t    data.months = months;\n\t    data.years  = years;\n\t\n\t    return this;\n\t}\n\t\n\tfunction daysToMonths (days) {\n\t    // 400 years have 146097 days (taking into account leap year rules)\n\t    // 400 years have 12 months === 4800\n\t    return days * 4800 / 146097;\n\t}\n\t\n\tfunction monthsToDays (months) {\n\t    // the reverse of daysToMonths\n\t    return months * 146097 / 4800;\n\t}\n\t\n\tfunction as (units) {\n\t    if (!this.isValid()) {\n\t        return NaN;\n\t    }\n\t    var days;\n\t    var months;\n\t    var milliseconds = this._milliseconds;\n\t\n\t    units = normalizeUnits(units);\n\t\n\t    if (units === 'month' || units === 'year') {\n\t        days   = this._days   + milliseconds / 864e5;\n\t        months = this._months + daysToMonths(days);\n\t        return units === 'month' ? months : months / 12;\n\t    } else {\n\t        // handle milliseconds separately because of floating point math errors (issue #1867)\n\t        days = this._days + Math.round(monthsToDays(this._months));\n\t        switch (units) {\n\t            case 'week'   : return days / 7     + milliseconds / 6048e5;\n\t            case 'day'    : return days         + milliseconds / 864e5;\n\t            case 'hour'   : return days * 24    + milliseconds / 36e5;\n\t            case 'minute' : return days * 1440  + milliseconds / 6e4;\n\t            case 'second' : return days * 86400 + milliseconds / 1000;\n\t            // Math.floor prevents floating point math errors here\n\t            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n\t            default: throw new Error('Unknown unit ' + units);\n\t        }\n\t    }\n\t}\n\t\n\t// TODO: Use this.as('ms')?\n\tfunction valueOf$1 () {\n\t    if (!this.isValid()) {\n\t        return NaN;\n\t    }\n\t    return (\n\t        this._milliseconds +\n\t        this._days * 864e5 +\n\t        (this._months % 12) * 2592e6 +\n\t        toInt(this._months / 12) * 31536e6\n\t    );\n\t}\n\t\n\tfunction makeAs (alias) {\n\t    return function () {\n\t        return this.as(alias);\n\t    };\n\t}\n\t\n\tvar asMilliseconds = makeAs('ms');\n\tvar asSeconds      = makeAs('s');\n\tvar asMinutes      = makeAs('m');\n\tvar asHours        = makeAs('h');\n\tvar asDays         = makeAs('d');\n\tvar asWeeks        = makeAs('w');\n\tvar asMonths       = makeAs('M');\n\tvar asYears        = makeAs('y');\n\t\n\tfunction clone$1 () {\n\t    return createDuration(this);\n\t}\n\t\n\tfunction get$2 (units) {\n\t    units = normalizeUnits(units);\n\t    return this.isValid() ? this[units + 's']() : NaN;\n\t}\n\t\n\tfunction makeGetter(name) {\n\t    return function () {\n\t        return this.isValid() ? this._data[name] : NaN;\n\t    };\n\t}\n\t\n\tvar milliseconds = makeGetter('milliseconds');\n\tvar seconds      = makeGetter('seconds');\n\tvar minutes      = makeGetter('minutes');\n\tvar hours        = makeGetter('hours');\n\tvar days         = makeGetter('days');\n\tvar months       = makeGetter('months');\n\tvar years        = makeGetter('years');\n\t\n\tfunction weeks () {\n\t    return absFloor(this.days() / 7);\n\t}\n\t\n\tvar round = Math.round;\n\tvar thresholds = {\n\t    ss: 44,         // a few seconds to seconds\n\t    s : 45,         // seconds to minute\n\t    m : 45,         // minutes to hour\n\t    h : 22,         // hours to day\n\t    d : 26,         // days to month\n\t    M : 11          // months to year\n\t};\n\t\n\t// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n\tfunction substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n\t    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n\t}\n\t\n\tfunction relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n\t    var duration = createDuration(posNegDuration).abs();\n\t    var seconds  = round(duration.as('s'));\n\t    var minutes  = round(duration.as('m'));\n\t    var hours    = round(duration.as('h'));\n\t    var days     = round(duration.as('d'));\n\t    var months   = round(duration.as('M'));\n\t    var years    = round(duration.as('y'));\n\t\n\t    var a = seconds <= thresholds.ss && ['s', seconds]  ||\n\t            seconds < thresholds.s   && ['ss', seconds] ||\n\t            minutes <= 1             && ['m']           ||\n\t            minutes < thresholds.m   && ['mm', minutes] ||\n\t            hours   <= 1             && ['h']           ||\n\t            hours   < thresholds.h   && ['hh', hours]   ||\n\t            days    <= 1             && ['d']           ||\n\t            days    < thresholds.d   && ['dd', days]    ||\n\t            months  <= 1             && ['M']           ||\n\t            months  < thresholds.M   && ['MM', months]  ||\n\t            years   <= 1             && ['y']           || ['yy', years];\n\t\n\t    a[2] = withoutSuffix;\n\t    a[3] = +posNegDuration > 0;\n\t    a[4] = locale;\n\t    return substituteTimeAgo.apply(null, a);\n\t}\n\t\n\t// This function allows you to set the rounding function for relative time strings\n\tfunction getSetRelativeTimeRounding (roundingFunction) {\n\t    if (roundingFunction === undefined) {\n\t        return round;\n\t    }\n\t    if (typeof(roundingFunction) === 'function') {\n\t        round = roundingFunction;\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t// This function allows you to set a threshold for relative time strings\n\tfunction getSetRelativeTimeThreshold (threshold, limit) {\n\t    if (thresholds[threshold] === undefined) {\n\t        return false;\n\t    }\n\t    if (limit === undefined) {\n\t        return thresholds[threshold];\n\t    }\n\t    thresholds[threshold] = limit;\n\t    if (threshold === 's') {\n\t        thresholds.ss = limit - 1;\n\t    }\n\t    return true;\n\t}\n\t\n\tfunction humanize (withSuffix) {\n\t    if (!this.isValid()) {\n\t        return this.localeData().invalidDate();\n\t    }\n\t\n\t    var locale = this.localeData();\n\t    var output = relativeTime$1(this, !withSuffix, locale);\n\t\n\t    if (withSuffix) {\n\t        output = locale.pastFuture(+this, output);\n\t    }\n\t\n\t    return locale.postformat(output);\n\t}\n\t\n\tvar abs$1 = Math.abs;\n\t\n\tfunction sign(x) {\n\t    return ((x > 0) - (x < 0)) || +x;\n\t}\n\t\n\tfunction toISOString$1() {\n\t    // for ISO strings we do not use the normal bubbling rules:\n\t    //  * milliseconds bubble up until they become hours\n\t    //  * days do not bubble at all\n\t    //  * months bubble up until they become years\n\t    // This is because there is no context-free conversion between hours and days\n\t    // (think of clock changes)\n\t    // and also not between days and months (28-31 days per month)\n\t    if (!this.isValid()) {\n\t        return this.localeData().invalidDate();\n\t    }\n\t\n\t    var seconds = abs$1(this._milliseconds) / 1000;\n\t    var days         = abs$1(this._days);\n\t    var months       = abs$1(this._months);\n\t    var minutes, hours, years;\n\t\n\t    // 3600 seconds -> 60 minutes -> 1 hour\n\t    minutes           = absFloor(seconds / 60);\n\t    hours             = absFloor(minutes / 60);\n\t    seconds %= 60;\n\t    minutes %= 60;\n\t\n\t    // 12 months -> 1 year\n\t    years  = absFloor(months / 12);\n\t    months %= 12;\n\t\n\t\n\t    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n\t    var Y = years;\n\t    var M = months;\n\t    var D = days;\n\t    var h = hours;\n\t    var m = minutes;\n\t    var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n\t    var total = this.asSeconds();\n\t\n\t    if (!total) {\n\t        // this is the same as C#'s (Noda) and python (isodate)...\n\t        // but not other JS (goog.date)\n\t        return 'P0D';\n\t    }\n\t\n\t    var totalSign = total < 0 ? '-' : '';\n\t    var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n\t    var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n\t    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\t\n\t    return totalSign + 'P' +\n\t        (Y ? ymSign + Y + 'Y' : '') +\n\t        (M ? ymSign + M + 'M' : '') +\n\t        (D ? daysSign + D + 'D' : '') +\n\t        ((h || m || s) ? 'T' : '') +\n\t        (h ? hmsSign + h + 'H' : '') +\n\t        (m ? hmsSign + m + 'M' : '') +\n\t        (s ? hmsSign + s + 'S' : '');\n\t}\n\t\n\tvar proto$2 = Duration.prototype;\n\t\n\tproto$2.isValid        = isValid$1;\n\tproto$2.abs            = abs;\n\tproto$2.add            = add$1;\n\tproto$2.subtract       = subtract$1;\n\tproto$2.as             = as;\n\tproto$2.asMilliseconds = asMilliseconds;\n\tproto$2.asSeconds      = asSeconds;\n\tproto$2.asMinutes      = asMinutes;\n\tproto$2.asHours        = asHours;\n\tproto$2.asDays         = asDays;\n\tproto$2.asWeeks        = asWeeks;\n\tproto$2.asMonths       = asMonths;\n\tproto$2.asYears        = asYears;\n\tproto$2.valueOf        = valueOf$1;\n\tproto$2._bubble        = bubble;\n\tproto$2.clone          = clone$1;\n\tproto$2.get            = get$2;\n\tproto$2.milliseconds   = milliseconds;\n\tproto$2.seconds        = seconds;\n\tproto$2.minutes        = minutes;\n\tproto$2.hours          = hours;\n\tproto$2.days           = days;\n\tproto$2.weeks          = weeks;\n\tproto$2.months         = months;\n\tproto$2.years          = years;\n\tproto$2.humanize       = humanize;\n\tproto$2.toISOString    = toISOString$1;\n\tproto$2.toString       = toISOString$1;\n\tproto$2.toJSON         = toISOString$1;\n\tproto$2.locale         = locale;\n\tproto$2.localeData     = localeData;\n\t\n\t// Deprecations\n\tproto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n\tproto$2.lang = lang;\n\t\n\t// Side effect imports\n\t\n\t// FORMATTING\n\t\n\taddFormatToken('X', 0, 0, 'unix');\n\taddFormatToken('x', 0, 0, 'valueOf');\n\t\n\t// PARSING\n\t\n\taddRegexToken('x', matchSigned);\n\taddRegexToken('X', matchTimestamp);\n\taddParseToken('X', function (input, array, config) {\n\t    config._d = new Date(parseFloat(input, 10) * 1000);\n\t});\n\taddParseToken('x', function (input, array, config) {\n\t    config._d = new Date(toInt(input));\n\t});\n\t\n\t// Side effect imports\n\t\n\t\n\thooks.version = '2.20.1';\n\t\n\tsetHookCallback(createLocal);\n\t\n\thooks.fn                    = proto;\n\thooks.min                   = min;\n\thooks.max                   = max;\n\thooks.now                   = now;\n\thooks.utc                   = createUTC;\n\thooks.unix                  = createUnix;\n\thooks.months                = listMonths;\n\thooks.isDate                = isDate;\n\thooks.locale                = getSetGlobalLocale;\n\thooks.invalid               = createInvalid;\n\thooks.duration              = createDuration;\n\thooks.isMoment              = isMoment;\n\thooks.weekdays              = listWeekdays;\n\thooks.parseZone             = createInZone;\n\thooks.localeData            = getLocale;\n\thooks.isDuration            = isDuration;\n\thooks.monthsShort           = listMonthsShort;\n\thooks.weekdaysMin           = listWeekdaysMin;\n\thooks.defineLocale          = defineLocale;\n\thooks.updateLocale          = updateLocale;\n\thooks.locales               = listLocales;\n\thooks.weekdaysShort         = listWeekdaysShort;\n\thooks.normalizeUnits        = normalizeUnits;\n\thooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n\thooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n\thooks.calendarFormat        = getCalendarFormat;\n\thooks.prototype             = proto;\n\t\n\t// currently HTML5 input type only supports 24-hour formats\n\thooks.HTML5_FMT = {\n\t    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n\t    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n\t    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n\t    DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n\t    TIME: 'HH:mm',                                  // <input type=\"time\" />\n\t    TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n\t    TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n\t    WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n\t    MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n\t};\n\t\n\treturn hooks;\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)(module)))\n\n/***/ }),\n\n/***/ 274:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _templateObject = _taggedTemplateLiteralLoose(['\\n  display: flex;\\n  justify-content: space-between;\\n  margin-top: 4rem;\\n\\n  section {\\n    ', ';\\n  }\\n\\n  p {\\n    font-weight: 300;\\n    line-height: 2rem;\\n  }\\n\\n  aside {\\n  }\\n\\n  h3 {\\n    font-size: 2rem;\\n  }\\n\\n  h4 {\\n    text-transform: uppercase;\\n    color: #278cd6;\\n    font-size: 0.8rem;\\n    margin-bottom: 0;\\n  }\\n\\n  time {\\n    font-size: 2rem;\\n    letter-spacing: 0.2rem;\\n  }\\n\\n  a:link,\\n  a:visited {\\n    background-color: #278cd6;\\n    color: #fff;\\n    border: none;\\n    border-radius: 48px;\\n    text-transform: uppercase;\\n    font-weight: bold;\\n    font-size: 0.8rem;\\n    padding: 12px 24px;\\n    letter-spacing: 0.1rem;\\n\\n    &:link,\\n    &:visited {\\n      text-decoration: none;\\n    }\\n  }\\n\\n  form {\\n    border: thin solid #278cd6;\\n    border-radius: 3rem;\\n    height: 3rem;\\n    display: flex;\\n\\n    input {\\n      flex: 1;\\n      border: none;\\n      margin-left: 1.5rem;\\n      font-family: \\'Open Sans\\';\\n      font-weight: 300;\\n\\n      input::placeholder {\\n        opacity: 0.34;\\n        font-size: 0.8rem;\\n      }\\n\\n      &:focus {\\n        outline: none;\\n      }\\n    }\\n\\n    button {\\n      color: #fff;\\n      background-color: #278cd6;\\n      border: none;\\n      border-radius: 3rem;\\n      padding: 0 2rem;\\n      text-transform: uppercase;\\n      font-size: 0.8rem;\\n      font-weight: 700;\\n    }\\n  }\\n\\n  @media (max-width: 640px) {\\n    flex-direction: column;\\n    align-items: center;\\n  }\\n'], ['\\n  display: flex;\\n  justify-content: space-between;\\n  margin-top: 4rem;\\n\\n  section {\\n    ', ';\\n  }\\n\\n  p {\\n    font-weight: 300;\\n    line-height: 2rem;\\n  }\\n\\n  aside {\\n  }\\n\\n  h3 {\\n    font-size: 2rem;\\n  }\\n\\n  h4 {\\n    text-transform: uppercase;\\n    color: #278cd6;\\n    font-size: 0.8rem;\\n    margin-bottom: 0;\\n  }\\n\\n  time {\\n    font-size: 2rem;\\n    letter-spacing: 0.2rem;\\n  }\\n\\n  a:link,\\n  a:visited {\\n    background-color: #278cd6;\\n    color: #fff;\\n    border: none;\\n    border-radius: 48px;\\n    text-transform: uppercase;\\n    font-weight: bold;\\n    font-size: 0.8rem;\\n    padding: 12px 24px;\\n    letter-spacing: 0.1rem;\\n\\n    &:link,\\n    &:visited {\\n      text-decoration: none;\\n    }\\n  }\\n\\n  form {\\n    border: thin solid #278cd6;\\n    border-radius: 3rem;\\n    height: 3rem;\\n    display: flex;\\n\\n    input {\\n      flex: 1;\\n      border: none;\\n      margin-left: 1.5rem;\\n      font-family: \\'Open Sans\\';\\n      font-weight: 300;\\n\\n      input::placeholder {\\n        opacity: 0.34;\\n        font-size: 0.8rem;\\n      }\\n\\n      &:focus {\\n        outline: none;\\n      }\\n    }\\n\\n    button {\\n      color: #fff;\\n      background-color: #278cd6;\\n      border: none;\\n      border-radius: 3rem;\\n      padding: 0 2rem;\\n      text-transform: uppercase;\\n      font-size: 0.8rem;\\n      font-weight: 700;\\n    }\\n  }\\n\\n  @media (max-width: 640px) {\\n    flex-direction: column;\\n    align-items: center;\\n  }\\n']),\n\t    _templateObject2 = _taggedTemplateLiteralLoose(['\\n  background-color: #f7f7f9;\\n  padding-top: 100px;\\n  position: relative;\\n\\n  &:before {\\n    background: #fff;\\n    height: 200px;\\n    clip-path: ellipse(100% 50% at 50% -40%);\\n    width: 100%;\\n    content: \\'\\';\\n    display: block;\\n    position: absolute;\\n    top: 0;\\n    z-index: 1;\\n  }\\n\\n  h2 {\\n    text-align: center;\\n    margin-bottom: 4rem;\\n    font-size: 2rem;\\n  }\\n\\n  section {\\n    display: flex;\\n    justify-content: space-between;\\n  }\\n\\n  h3 {\\n    font-family: \\'Open Sans\\';\\n    font-weight: 700;\\n    font-size: 0.9rem;\\n    text-align: center;\\n  }\\n\\n  aside {\\n    font-size: 0.8rem;\\n    flex-basis: calc(50% - 1rem);\\n  }\\n\\n  table {\\n    font-size: 0.8rem;\\n  }\\n\\n  img {\\n    margin: 0 1rem;\\n    width: calc(100% - 2rem);\\n  }\\n\\n  @media (max-width: 640px) {\\n    section {\\n      flex-direction: column;\\n    }\\n\\n    aside {\\n      flex-basis: 100%;\\n      margin-bottom: 2rem;\\n    }\\n  }\\n'], ['\\n  background-color: #f7f7f9;\\n  padding-top: 100px;\\n  position: relative;\\n\\n  &:before {\\n    background: #fff;\\n    height: 200px;\\n    clip-path: ellipse(100% 50% at 50% -40%);\\n    width: 100%;\\n    content: \\'\\';\\n    display: block;\\n    position: absolute;\\n    top: 0;\\n    z-index: 1;\\n  }\\n\\n  h2 {\\n    text-align: center;\\n    margin-bottom: 4rem;\\n    font-size: 2rem;\\n  }\\n\\n  section {\\n    display: flex;\\n    justify-content: space-between;\\n  }\\n\\n  h3 {\\n    font-family: \\'Open Sans\\';\\n    font-weight: 700;\\n    font-size: 0.9rem;\\n    text-align: center;\\n  }\\n\\n  aside {\\n    font-size: 0.8rem;\\n    flex-basis: calc(50% - 1rem);\\n  }\\n\\n  table {\\n    font-size: 0.8rem;\\n  }\\n\\n  img {\\n    margin: 0 1rem;\\n    width: calc(100% - 2rem);\\n  }\\n\\n  @media (max-width: 640px) {\\n    section {\\n      flex-direction: column;\\n    }\\n\\n    aside {\\n      flex-basis: 100%;\\n      margin-bottom: 2rem;\\n    }\\n  }\\n']),\n\t    _templateObject3 = _taggedTemplateLiteralLoose(['\\n  text-align: center;\\n  h2 {\\n    margin: 4rem auto;\\n    font-size: 2rem;\\n  }\\n\\n  img {\\n    margin: 4rem;\\n    max-width: 540px;\\n  }\\n'], ['\\n  text-align: center;\\n  h2 {\\n    margin: 4rem auto;\\n    font-size: 2rem;\\n  }\\n\\n  img {\\n    margin: 4rem;\\n    max-width: 540px;\\n  }\\n']);\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _styledComponents = __webpack_require__(5);\n\t\n\tvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\t\n\tvar _container = __webpack_require__(10);\n\t\n\tvar _container2 = _interopRequireDefault(_container);\n\t\n\tvar _sectionHeader = __webpack_require__(29);\n\t\n\tvar _sectionHeader2 = _interopRequireDefault(_sectionHeader);\n\t\n\tvar _timeline = __webpack_require__(682);\n\t\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\t\n\tvar _ill_allocation = __webpack_require__(653);\n\t\n\tvar _ill_allocation2 = _interopRequireDefault(_ill_allocation);\n\t\n\tvar _timer = __webpack_require__(106);\n\t\n\tvar _timer2 = _interopRequireDefault(_timer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\n\t\n\tvar Header = _styledComponents2.default.header(_templateObject, '' /* max-width: 420px; */);\n\t\n\tvar CrowdsaleInfo = _styledComponents2.default.div(_templateObject2);\n\t\n\tvar Timeline = _styledComponents2.default.div(_templateObject3);\n\t\n\tvar Presale = function (_React$Component) {\n\t  _inherits(Presale, _React$Component);\n\t\n\t  function Presale() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, Presale);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n\t      thanks: false,\n\t      email: ''\n\t    }, _this._submit = function (event) {\n\t      event.preventDefault();\n\t      var email = encodeURIComponent(_this.state.email);\n\t      var url = 'https://script.google.com/a/suncoast.io/macros/s/AKfycbx5j3f48_i0layRQ8mKhBwVo-wJSuu-XHNMXc77kKPC9pGhob5P/exec?email=' + email;\n\t      window.fetch(url, { method: 'GET' });\n\t      _this.setState({ thanks: true, email: '' });\n\t    }, _this._change = function (event) {\n\t      _this.setState({ email: event.target.value });\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  Presale.prototype.render = function render() {\n\t    return _react2.default.createElement(\n\t      'div',\n\t      null,\n\t      _react2.default.createElement(\n\t        _container2.default,\n\t        null,\n\t        _react2.default.createElement(\n\t          _sectionHeader2.default,\n\t          null,\n\t          'Presale'\n\t        ),\n\t        _react2.default.createElement(\n\t          Header,\n\t          null,\n\t          this.state.thanks ? _react2.default.createElement(\n\t            'div',\n\t            null,\n\t            _react2.default.createElement(\n\t              'h3',\n\t              null,\n\t              _react2.default.createElement(\n\t                'strong',\n\t                null,\n\t                'Thanks'\n\t              ),\n\t              ', we\\'ll be in touch.'\n\t            )\n\t          ) : _react2.default.createElement(\n\t            'section',\n\t            null,\n\t            _react2.default.createElement(\n\t              'h3',\n\t              null,\n\t              'The presale is open until April 26',\n\t              _react2.default.createElement(\n\t                'sup',\n\t                null,\n\t                'th'\n\t              ),\n\t              '.'\n\t            ),\n\t            _react2.default.createElement(\n\t              'p',\n\t              null,\n\t              'To purchase VRS, create your wallet and exchange NEO or ETH for VRS:'\n\t            ),\n\t            _react2.default.createElement(\n\t              'p',\n\t              null,\n\t              _react2.default.createElement(\n\t                'a',\n\t                { href: 'https://ico.verisfoundation.com/' },\n\t                'Get Started'\n\t              )\n\t            ),\n\t            _react2.default.createElement(\n\t              'p',\n\t              null,\n\t              'Stay informed about Veris:'\n\t            ),\n\t            _react2.default.createElement(\n\t              'form',\n\t              { action: '', onSubmit: this._submit },\n\t              _react2.default.createElement('input', { required: true, type: 'email', placeholder: 'Enter Your Email', onChange: this._change }),\n\t              _react2.default.createElement(\n\t                'button',\n\t                { type: 'submit' },\n\t                'Submit'\n\t              )\n\t            )\n\t          )\n\t        )\n\t      ),\n\t      _react2.default.createElement(\n\t        CrowdsaleInfo,\n\t        null,\n\t        _react2.default.createElement(\n\t          _container2.default,\n\t          null,\n\t          _react2.default.createElement(\n\t            'h2',\n\t            null,\n\t            'Veris Foundation Crowdsale Info'\n\t          ),\n\t          _react2.default.createElement(\n\t            'section',\n\t            null,\n\t            _react2.default.createElement(\n\t              'aside',\n\t              null,\n\t              _react2.default.createElement(\n\t                'h3',\n\t                null,\n\t                'Overview'\n\t              ),\n\t              _react2.default.createElement(\n\t                'table',\n\t                null,\n\t                _react2.default.createElement(\n\t                  'tbody',\n\t                  null,\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'Presale Timeline'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      'Mar 19th, 2018 - Apr 26, 2018'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'ICO Timeline'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      'Apr 30th, 2018 - Jul 30, 2018'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'VRS Total Supply'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      '50,000,000'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'Presale + ICO Allocation'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      '30,000,000'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'Presale Price (25% bonus)'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      '1 NEO = 100 VRS',\n\t                      _react2.default.createElement('br', null),\n\t                      '1 ETH = (ETH-USD/NEO-USD) * 100 VRS'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'ICO Price'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      '1 NEO = 80 VRS',\n\t                      _react2.default.createElement('br', null),\n\t                      '1 ETH = (ETH-USD/NEO-USD) * 80 VRS'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'Minimum Cap'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      '9,000 ETH / 28,000 NEO'\n\t                    )\n\t                  ),\n\t                  _react2.default.createElement(\n\t                    'tr',\n\t                    null,\n\t                    _react2.default.createElement(\n\t                      'th',\n\t                      null,\n\t                      'Maximum Cap'\n\t                    ),\n\t                    _react2.default.createElement(\n\t                      'td',\n\t                      null,\n\t                      '90,000 ETH / 270,000 NEO'\n\t                    )\n\t                  )\n\t                )\n\t              )\n\t            ),\n\t            _react2.default.createElement(\n\t              'aside',\n\t              null,\n\t              _react2.default.createElement(\n\t                'h3',\n\t                null,\n\t                'Allocation'\n\t              ),\n\t              _react2.default.createElement('img', { src: _ill_allocation2.default, width: '400' })\n\t            )\n\t          )\n\t        )\n\t      ),\n\t      _react2.default.createElement(\n\t        Timeline,\n\t        null,\n\t        _react2.default.createElement(\n\t          _container2.default,\n\t          null,\n\t          _react2.default.createElement(\n\t            'h2',\n\t            null,\n\t            'Veris Project Timeline'\n\t          ),\n\t          _react2.default.createElement('img', { src: _timeline2.default })\n\t        )\n\t      )\n\t    );\n\t  };\n\t\n\t  return Presale;\n\t}(_react2.default.Component);\n\t\n\texports.default = Presale;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 106:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _moment = __webpack_require__(38);\n\t\n\tvar _moment2 = _interopRequireDefault(_moment);\n\t\n\tvar _momentDurationFormat = __webpack_require__(170);\n\t\n\tvar _momentDurationFormat2 = _interopRequireDefault(_momentDurationFormat);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t(0, _momentDurationFormat2.default)(_moment2.default);\n\t\n\tvar Timer = function (_React$Component) {\n\t  _inherits(Timer, _React$Component);\n\t\n\t  function Timer() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, Timer);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n\t      remaining: _moment2.default.duration(0)\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  Timer.prototype.componentWillMount = function componentWillMount() {\n\t    var _this2 = this;\n\t\n\t    this.tick();\n\t    this.timer = setInterval(function () {\n\t      return _this2.tick();\n\t    }, 1000);\n\t  };\n\t\n\t  Timer.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    clearInterval(this.timer);\n\t  };\n\t\n\t  Timer.prototype.tick = function tick() {\n\t    var remaining = _moment2.default.duration(-1 * (0, _moment2.default)().diff(this.props.to));\n\t    this.setState({ remaining: remaining });\n\t  };\n\t\n\t  Timer.prototype.render = function render() {\n\t    var remaining = this.state.remaining;\n\t\n\t    return _react2.default.createElement(\n\t      'time',\n\t      null,\n\t      remaining.format('DD:HH:mm:ss', { trim: false })\n\t    );\n\t  };\n\t\n\t  return Timer;\n\t}(_react2.default.Component);\n\t\n\texports.default = Timer;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 653:\n/***/ (function(module, exports) {\n\n\tmodule.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMi4wLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA0MDAgNjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDojQ0EwMDAwO30NCgkuc3Qxe2ZpbGw6I0NEMDBDQTt9DQoJLnN0MntmaWxsOiMxODAwMDE7fQ0KCS5zdDN7ZmlsbDojMDBCRDVDO30NCgkuc3Q0e2ZpbGw6IzI3OENENjt9DQoJLnN0NXtmaWxsOiMwRjM1NTI7fQ0KCS5zdDZ7Zm9udC1mYW1pbHk6J09wZW5TYW5zJzt9DQoJLnN0N3tmb250LXNpemU6MTRweDt9DQo8L3N0eWxlPg0KPGc+DQoJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE5Mi40LDEwNUMxOTIuNSwxMDUsMTkyLjUsMTA1LDE5Mi40LDEwNWwwLjEtNTUuM2MtNS45LDAtMTIuNSwwLjUtMTguMywxLjNsNy43LDU0LjYNCgkJQzE4NS4zLDEwNS4yLDE4OC45LDEwNSwxOTIuNCwxMDV6Ii8+DQoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTE3Ny41LDg5LjJsLTUuMy0zNy45Yy0xMiwxLjctMjEuMiw0LjItMzIuNCw4LjdsMjAuNiw1MWM2LjItMi40LDEyLjctNC4xLDE5LjUtNS4xTDE3Ny41LDg5LjJ6Ii8+DQoJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIxNzIuMiw1MS4zIDE3Mi4yLDUxLjMgMTc3LjUsODkuMiAJIi8+DQoJPHBhdGggY2xhc3M9InN0MyIgZD0iTTE1OC41LDExMS43bC0yMC42LTUxYy0yMy4xLDkuNS00MS4zLDIzLTU3LjIsNDIuM2w0Mi44LDM0LjdDMTMyLjgsMTI2LjQsMTQ0LjgsMTE3LjQsMTU4LjUsMTExLjd6Ii8+DQoJPHBhdGggY2xhc3M9InN0NCIgZD0iTTEwMy40LDE5NGMwLTIwLjYsNy0zOS42LDE4LjktNTQuN2wtNDIuOC0zNC43Yy0xLjYsMi0yLjMsMy00LDUuM0MyOC40LDE3NC43LDQyLjYsMjY1LjcsMTA3LDMxMy4ybDMzLjktNDYuNw0KCQlDMTE4LjIsMjUwLjMsMTAzLjQsMjIzLjgsMTAzLjQsMTk0eiIvPg0KCTxwYXRoIGNsYXNzPSJzdDUiIGQ9Ik0yODEuNCwxOTRjMCw0OS4xLTM5LjksODktODksODljLTE4LjUsMC0zNS43LTUuNy01MC0xNS40bC0zMy45LDQ2LjdjMjUuOSwxOC42LDUzLDI3LjMsODUsMjcuMw0KCQljODAuNSwwLDE0NS45LTY1LjUsMTQ1LjktMTQ1LjljMC04MC4xLTY0LjktMTQ1LjQtMTQ0LjktMTQ1LjlWMTA1QzI0Mi42LDEwNi4xLDI4MS40LDE0NS42LDI4MS40LDE5NHoiLz4NCjwvZz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDE1LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+UHVibGljIENvbnRyaWJ1dG9yczwvdGV4dD4NCjxjaXJjbGUgY2xhc3M9InN0NSIgY3g9IjE5LjciIGN5PSI0MTkiIHI9IjkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDM1LjY2NykiIGNsYXNzPSJzdDYgc3Q3Ij4zMG0gVlJTIC8gNjAlIDwvdGV4dD4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDc2LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+VmVyaXMgRm91bmRhdGlvbjwvdGV4dD4NCjxjaXJjbGUgY2xhc3M9InN0NCIgY3g9IjE5LjciIGN5PSI0ODAiIHI9IjkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDk2LjY2NykiIGNsYXNzPSJzdDYgc3Q3Ij4xM20gVlJTIC8gMjYlIDwvdGV4dD4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNTM4LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+VmVyaXMgQ29yZSBUZWFtPC90ZXh0Pg0KPGNpcmNsZSBjbGFzcz0ic3QzIiBjeD0iMTkuNyIgY3k9IjU0MiIgcj0iOSIvPg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAzOS42NiA1NTguNjY3KSIgY2xhc3M9InN0NiBzdDciPjRtIFZSUyAvIDglIDwvdGV4dD4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjQzLjY2IDQxNS42Mzk2KSIgY2xhc3M9InN0NiBzdDciPlBhcnRuZXJzaGlwICZhbXA7IEFkdmlzb3J5PC90ZXh0Pg0KPGNpcmNsZSBjbGFzcz0ic3QxIiBjeD0iMjIzLjciIGN5PSI0MTkiIHI9IjkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjQzLjY2IDQzNS42NjcpIiBjbGFzcz0ic3Q2IHN0NyI+Mm0gVlJTIC8gNCUgPC90ZXh0Pg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNDMuNjYgNDc2LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+Qm91bnRpZXM8L3RleHQ+DQo8Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSIyMjMuNyIgY3k9IjQ4MCIgcj0iOSIvPg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNDMuNjYgNDk2LjY2NykiIGNsYXNzPSJzdDYgc3Q3Ij4xbSBWUlMgLyAyJSA8L3RleHQ+DQo8L3N2Zz4NCg==\"\n\n/***/ }),\n\n/***/ 682:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/timeline.c5db9b43.svg\";\n\n/***/ }),\n\n/***/ 284:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _whitepaper = __webpack_require__(74);\n\t\n\tvar _whitepaper2 = _interopRequireDefault(_whitepaper);\n\t\n\tvar _presale = __webpack_require__(274);\n\t\n\tvar _presale2 = _interopRequireDefault(_presale);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function () {\n\t  return _react2.default.createElement(\n\t    'div',\n\t    null,\n\t    _react2.default.createElement(_presale2.default, null),\n\t    _react2.default.createElement(_whitepaper2.default, null)\n\t  );\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-presale-js-43de458729672c028a91.js","/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `toLocaleString` for formatting.\n    // `userLocale` option is passed through to `toLocaleString`.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (!toLocaleStringRoundingWorks) {\n                var roundingOptions = extend({}, options);\n                roundingOptions.useGrouping = false;\n                roundingOptions.decimalSeparator = \".\";\n                number = parseFloat(formatNumber(number, roundingOptions), 10);\n            }\n\n            return number.toLocaleString(userLocale, localeStringOptions);\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestToLocaleStringRounding() {\n        return (3.55).toLocaleString(\"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestToLocaleString() {\n        var passed = true;\n\n        // Test locale.\n        passed = passed && toLocaleStringSupportsLocales();\n        if (!passed) { return false; }\n\n        // Test minimumIntegerDigits.\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && toLocaleStringWorks;\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    toLocaleStringWorks = featureTestToLocaleString();\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding();\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/moment-duration-format/lib/moment-duration-format.js\n// module id = 170\n// module chunks = 35783957827783 115261235868047","//! moment.js\n//! version : 2.20.1\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\nvar hookCallback;\n\nfunction hooks () {\n    return hookCallback.apply(null, arguments);\n}\n\n// This is done to register the method called with moment()\n// without creating circular dependencies.\nfunction setHookCallback (callback) {\n    hookCallback = callback;\n}\n\nfunction isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n}\n\nfunction isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n}\n\nfunction isObjectEmpty(obj) {\n    if (Object.getOwnPropertyNames) {\n        return (Object.getOwnPropertyNames(obj).length === 0);\n    } else {\n        var k;\n        for (k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nfunction isUndefined(input) {\n    return input === void 0;\n}\n\nfunction isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n}\n\nfunction isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n}\n\nfunction map(arr, fn) {\n    var res = [], i;\n    for (i = 0; i < arr.length; ++i) {\n        res.push(fn(arr[i], i));\n    }\n    return res;\n}\n\nfunction hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n}\n\nfunction extend(a, b) {\n    for (var i in b) {\n        if (hasOwnProp(b, i)) {\n            a[i] = b[i];\n        }\n    }\n\n    if (hasOwnProp(b, 'toString')) {\n        a.toString = b.toString;\n    }\n\n    if (hasOwnProp(b, 'valueOf')) {\n        a.valueOf = b.valueOf;\n    }\n\n    return a;\n}\n\nfunction createUTC (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n}\n\nfunction defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n        empty           : false,\n        unusedTokens    : [],\n        unusedInput     : [],\n        overflow        : -2,\n        charsLeftOver   : 0,\n        nullInput       : false,\n        invalidMonth    : null,\n        invalidFormat   : false,\n        userInvalidated : false,\n        iso             : false,\n        parsedDateParts : [],\n        meridiem        : null,\n        rfc2822         : false,\n        weekdayMismatch : false\n    };\n}\n\nfunction getParsingFlags(m) {\n    if (m._pf == null) {\n        m._pf = defaultParsingFlags();\n    }\n    return m._pf;\n}\n\nvar some;\nif (Array.prototype.some) {\n    some = Array.prototype.some;\n} else {\n    some = function (fun) {\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        for (var i = 0; i < len; i++) {\n            if (i in t && fun.call(this, t[i], i, t)) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n}\n\nfunction isValid(m) {\n    if (m._isValid == null) {\n        var flags = getParsingFlags(m);\n        var parsedParts = some.call(flags.parsedDateParts, function (i) {\n            return i != null;\n        });\n        var isNowValid = !isNaN(m._d.getTime()) &&\n            flags.overflow < 0 &&\n            !flags.empty &&\n            !flags.invalidMonth &&\n            !flags.invalidWeekday &&\n            !flags.weekdayMismatch &&\n            !flags.nullInput &&\n            !flags.invalidFormat &&\n            !flags.userInvalidated &&\n            (!flags.meridiem || (flags.meridiem && parsedParts));\n\n        if (m._strict) {\n            isNowValid = isNowValid &&\n                flags.charsLeftOver === 0 &&\n                flags.unusedTokens.length === 0 &&\n                flags.bigHour === undefined;\n        }\n\n        if (Object.isFrozen == null || !Object.isFrozen(m)) {\n            m._isValid = isNowValid;\n        }\n        else {\n            return isNowValid;\n        }\n    }\n    return m._isValid;\n}\n\nfunction createInvalid (flags) {\n    var m = createUTC(NaN);\n    if (flags != null) {\n        extend(getParsingFlags(m), flags);\n    }\n    else {\n        getParsingFlags(m).userInvalidated = true;\n    }\n\n    return m;\n}\n\n// Plugins that add properties should also add the key here (null value),\n// so we can properly clone ourselves.\nvar momentProperties = hooks.momentProperties = [];\n\nfunction copyConfig(to, from) {\n    var i, prop, val;\n\n    if (!isUndefined(from._isAMomentObject)) {\n        to._isAMomentObject = from._isAMomentObject;\n    }\n    if (!isUndefined(from._i)) {\n        to._i = from._i;\n    }\n    if (!isUndefined(from._f)) {\n        to._f = from._f;\n    }\n    if (!isUndefined(from._l)) {\n        to._l = from._l;\n    }\n    if (!isUndefined(from._strict)) {\n        to._strict = from._strict;\n    }\n    if (!isUndefined(from._tzm)) {\n        to._tzm = from._tzm;\n    }\n    if (!isUndefined(from._isUTC)) {\n        to._isUTC = from._isUTC;\n    }\n    if (!isUndefined(from._offset)) {\n        to._offset = from._offset;\n    }\n    if (!isUndefined(from._pf)) {\n        to._pf = getParsingFlags(from);\n    }\n    if (!isUndefined(from._locale)) {\n        to._locale = from._locale;\n    }\n\n    if (momentProperties.length > 0) {\n        for (i = 0; i < momentProperties.length; i++) {\n            prop = momentProperties[i];\n            val = from[prop];\n            if (!isUndefined(val)) {\n                to[prop] = val;\n            }\n        }\n    }\n\n    return to;\n}\n\nvar updateInProgress = false;\n\n// Moment prototype object\nfunction Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n    if (!this.isValid()) {\n        this._d = new Date(NaN);\n    }\n    // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n    if (updateInProgress === false) {\n        updateInProgress = true;\n        hooks.updateOffset(this);\n        updateInProgress = false;\n    }\n}\n\nfunction isMoment (obj) {\n    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n}\n\nfunction absFloor (number) {\n    if (number < 0) {\n        // -0 -> 0\n        return Math.ceil(number) || 0;\n    } else {\n        return Math.floor(number);\n    }\n}\n\nfunction toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n    }\n\n    return value;\n}\n\n// compare two arrays, return the number of differences\nfunction compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n    for (i = 0; i < len; i++) {\n        if ((dontConvert && array1[i] !== array2[i]) ||\n            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n            diffs++;\n        }\n    }\n    return diffs + lengthDiff;\n}\n\nfunction warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false &&\n            (typeof console !==  'undefined') && console.warn) {\n        console.warn('Deprecation warning: ' + msg);\n    }\n}\n\nfunction deprecate(msg, fn) {\n    var firstTime = true;\n\n    return extend(function () {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(null, msg);\n        }\n        if (firstTime) {\n            var args = [];\n            var arg;\n            for (var i = 0; i < arguments.length; i++) {\n                arg = '';\n                if (typeof arguments[i] === 'object') {\n                    arg += '\\n[' + i + '] ';\n                    for (var key in arguments[0]) {\n                        arg += key + ': ' + arguments[0][key] + ', ';\n                    }\n                    arg = arg.slice(0, -2); // Remove trailing comma and space\n                } else {\n                    arg = arguments[i];\n                }\n                args.push(arg);\n            }\n            warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n            firstTime = false;\n        }\n        return fn.apply(this, arguments);\n    }, fn);\n}\n\nvar deprecations = {};\n\nfunction deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(name, msg);\n    }\n    if (!deprecations[name]) {\n        warn(msg);\n        deprecations[name] = true;\n    }\n}\n\nhooks.suppressDeprecationWarnings = false;\nhooks.deprecationHandler = null;\n\nfunction isFunction(input) {\n    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n}\n\nfunction set (config) {\n    var prop, i;\n    for (i in config) {\n        prop = config[i];\n        if (isFunction(prop)) {\n            this[i] = prop;\n        } else {\n            this['_' + i] = prop;\n        }\n    }\n    this._config = config;\n    // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    this._dayOfMonthOrdinalParseLenient = new RegExp(\n        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n            '|' + (/\\d{1,2}/).source);\n}\n\nfunction mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig), prop;\n    for (prop in childConfig) {\n        if (hasOwnProp(childConfig, prop)) {\n            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                res[prop] = {};\n                extend(res[prop], parentConfig[prop]);\n                extend(res[prop], childConfig[prop]);\n            } else if (childConfig[prop] != null) {\n                res[prop] = childConfig[prop];\n            } else {\n                delete res[prop];\n            }\n        }\n    }\n    for (prop in parentConfig) {\n        if (hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])) {\n            // make sure changes to properties don't modify parent config\n            res[prop] = extend({}, res[prop]);\n        }\n    }\n    return res;\n}\n\nfunction Locale(config) {\n    if (config != null) {\n        this.set(config);\n    }\n}\n\nvar keys;\n\nif (Object.keys) {\n    keys = Object.keys;\n} else {\n    keys = function (obj) {\n        var i, res = [];\n        for (i in obj) {\n            if (hasOwnProp(obj, i)) {\n                res.push(i);\n            }\n        }\n        return res;\n    };\n}\n\nvar defaultCalendar = {\n    sameDay : '[Today at] LT',\n    nextDay : '[Tomorrow at] LT',\n    nextWeek : 'dddd [at] LT',\n    lastDay : '[Yesterday at] LT',\n    lastWeek : '[Last] dddd [at] LT',\n    sameElse : 'L'\n};\n\nfunction calendar (key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n}\n\nvar defaultLongDateFormat = {\n    LTS  : 'h:mm:ss A',\n    LT   : 'h:mm A',\n    L    : 'MM/DD/YYYY',\n    LL   : 'MMMM D, YYYY',\n    LLL  : 'MMMM D, YYYY h:mm A',\n    LLLL : 'dddd, MMMM D, YYYY h:mm A'\n};\n\nfunction longDateFormat (key) {\n    var format = this._longDateFormat[key],\n        formatUpper = this._longDateFormat[key.toUpperCase()];\n\n    if (format || !formatUpper) {\n        return format;\n    }\n\n    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n        return val.slice(1);\n    });\n\n    return this._longDateFormat[key];\n}\n\nvar defaultInvalidDate = 'Invalid date';\n\nfunction invalidDate () {\n    return this._invalidDate;\n}\n\nvar defaultOrdinal = '%d';\nvar defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\nfunction ordinal (number) {\n    return this._ordinal.replace('%d', number);\n}\n\nvar defaultRelativeTime = {\n    future : 'in %s',\n    past   : '%s ago',\n    s  : 'a few seconds',\n    ss : '%d seconds',\n    m  : 'a minute',\n    mm : '%d minutes',\n    h  : 'an hour',\n    hh : '%d hours',\n    d  : 'a day',\n    dd : '%d days',\n    M  : 'a month',\n    MM : '%d months',\n    y  : 'a year',\n    yy : '%d years'\n};\n\nfunction relativeTime (number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return (isFunction(output)) ?\n        output(number, withoutSuffix, string, isFuture) :\n        output.replace(/%d/i, number);\n}\n\nfunction pastFuture (diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n}\n\nvar aliases = {};\n\nfunction addUnitAlias (unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n}\n\nfunction normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n}\n\nfunction normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop;\n\n    for (prop in inputObject) {\n        if (hasOwnProp(inputObject, prop)) {\n            normalizedProp = normalizeUnits(prop);\n            if (normalizedProp) {\n                normalizedInput[normalizedProp] = inputObject[prop];\n            }\n        }\n    }\n\n    return normalizedInput;\n}\n\nvar priorities = {};\n\nfunction addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n}\n\nfunction getPrioritizedUnits(unitsObj) {\n    var units = [];\n    for (var u in unitsObj) {\n        units.push({unit: u, priority: priorities[u]});\n    }\n    units.sort(function (a, b) {\n        return a.priority - b.priority;\n    });\n    return units;\n}\n\nfunction zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n        zerosToFill = targetLength - absNumber.length,\n        sign = number >= 0;\n    return (sign ? (forceSign ? '+' : '') : '-') +\n        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n}\n\nvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\nvar localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\nvar formatFunctions = {};\n\nvar formatTokenFunctions = {};\n\n// token:    'M'\n// padded:   ['MM', 2]\n// ordinal:  'Mo'\n// callback: function () { this.month() + 1 }\nfunction addFormatToken (token, padded, ordinal, callback) {\n    var func = callback;\n    if (typeof callback === 'string') {\n        func = function () {\n            return this[callback]();\n        };\n    }\n    if (token) {\n        formatTokenFunctions[token] = func;\n    }\n    if (padded) {\n        formatTokenFunctions[padded[0]] = function () {\n            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n        };\n    }\n    if (ordinal) {\n        formatTokenFunctions[ordinal] = function () {\n            return this.localeData().ordinal(func.apply(this, arguments), token);\n        };\n    }\n}\n\nfunction removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n        return input.replace(/^\\[|\\]$/g, '');\n    }\n    return input.replace(/\\\\/g, '');\n}\n\nfunction makeFormatFunction(format) {\n    var array = format.match(formattingTokens), i, length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n        if (formatTokenFunctions[array[i]]) {\n            array[i] = formatTokenFunctions[array[i]];\n        } else {\n            array[i] = removeFormattingTokens(array[i]);\n        }\n    }\n\n    return function (mom) {\n        var output = '', i;\n        for (i = 0; i < length; i++) {\n            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n        }\n        return output;\n    };\n}\n\n// format date using native date object\nfunction formatMoment(m, format) {\n    if (!m.isValid()) {\n        return m.localeData().invalidDate();\n    }\n\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n    return formatFunctions[format](m);\n}\n\nfunction expandFormat(format, locale) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n        return locale.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n    while (i >= 0 && localFormattingTokens.test(format)) {\n        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n        localFormattingTokens.lastIndex = 0;\n        i -= 1;\n    }\n\n    return format;\n}\n\nvar match1         = /\\d/;            //       0 - 9\nvar match2         = /\\d\\d/;          //      00 - 99\nvar match3         = /\\d{3}/;         //     000 - 999\nvar match4         = /\\d{4}/;         //    0000 - 9999\nvar match6         = /[+-]?\\d{6}/;    // -999999 - 999999\nvar match1to2      = /\\d\\d?/;         //       0 - 99\nvar match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\nvar match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\nvar match1to3      = /\\d{1,3}/;       //       0 - 999\nvar match1to4      = /\\d{1,4}/;       //       0 - 9999\nvar match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\nvar matchUnsigned  = /\\d+/;           //       0 - inf\nvar matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\nvar matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\nvar matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\nvar matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n// any word (or two) characters or numbers including two/three word month in arabic.\n// includes scottish gaelic two word and hyphenated months\nvar matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n\nvar regexes = {};\n\nfunction addRegexToken (token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n        return (isStrict && strictRegex) ? strictRegex : regex;\n    };\n}\n\nfunction getParseRegexForToken (token, config) {\n    if (!hasOwnProp(regexes, token)) {\n        return new RegExp(unescapeFormat(token));\n    }\n\n    return regexes[token](config._strict, config._locale);\n}\n\n// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n        return p1 || p2 || p3 || p4;\n    }));\n}\n\nfunction regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nvar tokens = {};\n\nfunction addParseToken (token, callback) {\n    var i, func = callback;\n    if (typeof token === 'string') {\n        token = [token];\n    }\n    if (isNumber(callback)) {\n        func = function (input, array) {\n            array[callback] = toInt(input);\n        };\n    }\n    for (i = 0; i < token.length; i++) {\n        tokens[token[i]] = func;\n    }\n}\n\nfunction addWeekParseToken (token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n        config._w = config._w || {};\n        callback(input, config._w, config, token);\n    });\n}\n\nfunction addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n        tokens[token](input, config._a, config, token);\n    }\n}\n\nvar YEAR = 0;\nvar MONTH = 1;\nvar DATE = 2;\nvar HOUR = 3;\nvar MINUTE = 4;\nvar SECOND = 5;\nvar MILLISECOND = 6;\nvar WEEK = 7;\nvar WEEKDAY = 8;\n\n// FORMATTING\n\naddFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? '' + y : '+' + y;\n});\n\naddFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n});\n\naddFormatToken(0, ['YYYY',   4],       0, 'year');\naddFormatToken(0, ['YYYYY',  5],       0, 'year');\naddFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n// ALIASES\n\naddUnitAlias('year', 'y');\n\n// PRIORITIES\n\naddUnitPriority('year', 1);\n\n// PARSING\n\naddRegexToken('Y',      matchSigned);\naddRegexToken('YY',     match1to2, match2);\naddRegexToken('YYYY',   match1to4, match4);\naddRegexToken('YYYYY',  match1to6, match6);\naddRegexToken('YYYYYY', match1to6, match6);\n\naddParseToken(['YYYYY', 'YYYYYY'], YEAR);\naddParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n});\naddParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n});\naddParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n});\n\n// HELPERS\n\nfunction daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n}\n\nfunction isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\n\n// HOOKS\n\nhooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n};\n\n// MOMENTS\n\nvar getSetYear = makeGetSet('FullYear', true);\n\nfunction getIsLeapYear () {\n    return isLeapYear(this.year());\n}\n\nfunction makeGetSet (unit, keepTime) {\n    return function (value) {\n        if (value != null) {\n            set$1(this, unit, value);\n            hooks.updateOffset(this, keepTime);\n            return this;\n        } else {\n            return get(this, unit);\n        }\n    };\n}\n\nfunction get (mom, unit) {\n    return mom.isValid() ?\n        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n}\n\nfunction set$1 (mom, unit, value) {\n    if (mom.isValid() && !isNaN(value)) {\n        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n        }\n        else {\n            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n        }\n    }\n}\n\n// MOMENTS\n\nfunction stringGet (units) {\n    units = normalizeUnits(units);\n    if (isFunction(this[units])) {\n        return this[units]();\n    }\n    return this;\n}\n\n\nfunction stringSet (units, value) {\n    if (typeof units === 'object') {\n        units = normalizeObjectUnits(units);\n        var prioritized = getPrioritizedUnits(units);\n        for (var i = 0; i < prioritized.length; i++) {\n            this[prioritized[i].unit](units[prioritized[i].unit]);\n        }\n    } else {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units](value);\n        }\n    }\n    return this;\n}\n\nfunction mod(n, x) {\n    return ((n % x) + x) % x;\n}\n\nvar indexOf;\n\nif (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n} else {\n    indexOf = function (o) {\n        // I know\n        var i;\n        for (i = 0; i < this.length; ++i) {\n            if (this[i] === o) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\nfunction daysInMonth(year, month) {\n    if (isNaN(year) || isNaN(month)) {\n        return NaN;\n    }\n    var modMonth = mod(month, 12);\n    year += (month - modMonth) / 12;\n    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n}\n\n// FORMATTING\n\naddFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n});\n\naddFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n});\n\naddFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n});\n\n// ALIASES\n\naddUnitAlias('month', 'M');\n\n// PRIORITY\n\naddUnitPriority('month', 8);\n\n// PARSING\n\naddRegexToken('M',    match1to2);\naddRegexToken('MM',   match1to2, match2);\naddRegexToken('MMM',  function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n});\naddRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n});\n\naddParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n});\n\naddParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict);\n    // if we didn't find a month name, mark the date as invalid.\n    if (month != null) {\n        array[MONTH] = month;\n    } else {\n        getParsingFlags(config).invalidMonth = input;\n    }\n});\n\n// LOCALES\n\nvar MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\nvar defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\nfunction localeMonths (m, format) {\n    if (!m) {\n        return isArray(this._months) ? this._months :\n            this._months['standalone'];\n    }\n    return isArray(this._months) ? this._months[m.month()] :\n        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nvar defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\nfunction localeMonthsShort (m, format) {\n    if (!m) {\n        return isArray(this._monthsShort) ? this._monthsShort :\n            this._monthsShort['standalone'];\n    }\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nfunction handleStrictParse(monthName, format, strict) {\n    var i, ii, mom, llc = monthName.toLocaleLowerCase();\n    if (!this._monthsParse) {\n        // this is not used\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n        for (i = 0; i < 12; ++i) {\n            mom = createUTC([2000, i]);\n            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'MMM') {\n            ii = indexOf.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'MMM') {\n            ii = indexOf.call(this._shortMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf.call(this._longMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeMonthsParse (monthName, format, strict) {\n    var i, mom, regex;\n\n    if (this._monthsParseExact) {\n        return handleStrictParse.call(this, monthName, format, strict);\n    }\n\n    if (!this._monthsParse) {\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n    }\n\n    // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        if (strict && !this._longMonthsParse[i]) {\n            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n        }\n        if (!strict && !this._monthsParse[i]) {\n            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (!strict && this._monthsParse[i].test(monthName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction setMonth (mom, value) {\n    var dayOfMonth;\n\n    if (!mom.isValid()) {\n        // No op\n        return mom;\n    }\n\n    if (typeof value === 'string') {\n        if (/^\\d+$/.test(value)) {\n            value = toInt(value);\n        } else {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (!isNumber(value)) {\n                return mom;\n            }\n        }\n    }\n\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n    return mom;\n}\n\nfunction getSetMonth (value) {\n    if (value != null) {\n        setMonth(this, value);\n        hooks.updateOffset(this, true);\n        return this;\n    } else {\n        return get(this, 'Month');\n    }\n}\n\nfunction getDaysInMonth () {\n    return daysInMonth(this.year(), this.month());\n}\n\nvar defaultMonthsShortRegex = matchWord;\nfunction monthsShortRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsShortStrictRegex;\n        } else {\n            return this._monthsShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsShortRegex')) {\n            this._monthsShortRegex = defaultMonthsShortRegex;\n        }\n        return this._monthsShortStrictRegex && isStrict ?\n            this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n}\n\nvar defaultMonthsRegex = matchWord;\nfunction monthsRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsStrictRegex;\n        } else {\n            return this._monthsRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            this._monthsRegex = defaultMonthsRegex;\n        }\n        return this._monthsStrictRegex && isStrict ?\n            this._monthsStrictRegex : this._monthsRegex;\n    }\n}\n\nfunction computeMonthsParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom;\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        shortPieces.push(this.monthsShort(mom, ''));\n        longPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.monthsShort(mom, ''));\n    }\n    // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 12; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n    }\n    for (i = 0; i < 24; i++) {\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n}\n\nfunction createDate (y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date = new Date(y, m, d, h, M, s, ms);\n\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n    }\n    return date;\n}\n\nfunction createUTCDate (y) {\n    var date = new Date(Date.UTC.apply(null, arguments));\n\n    // the Date.UTC function remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n    }\n    return date;\n}\n\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        fwd = 7 + dow - doy,\n        // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n    return -fwdlw + fwd - 1;\n}\n\n// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\nfunction dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n        weekOffset = firstWeekOffset(year, dow, doy),\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n        resYear, resDayOfYear;\n\n    if (dayOfYear <= 0) {\n        resYear = year - 1;\n        resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n        resYear = year + 1;\n        resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n        resYear = year;\n        resDayOfYear = dayOfYear;\n    }\n\n    return {\n        year: resYear,\n        dayOfYear: resDayOfYear\n    };\n}\n\nfunction weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n        resWeek, resYear;\n\n    if (week < 1) {\n        resYear = mom.year() - 1;\n        resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n        resWeek = week - weeksInYear(mom.year(), dow, doy);\n        resYear = mom.year() + 1;\n    } else {\n        resYear = mom.year();\n        resWeek = week;\n    }\n\n    return {\n        week: resWeek,\n        year: resYear\n    };\n}\n\nfunction weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n}\n\n// FORMATTING\n\naddFormatToken('w', ['ww', 2], 'wo', 'week');\naddFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n// ALIASES\n\naddUnitAlias('week', 'w');\naddUnitAlias('isoWeek', 'W');\n\n// PRIORITIES\n\naddUnitPriority('week', 5);\naddUnitPriority('isoWeek', 5);\n\n// PARSING\n\naddRegexToken('w',  match1to2);\naddRegexToken('ww', match1to2, match2);\naddRegexToken('W',  match1to2);\naddRegexToken('WW', match1to2, match2);\n\naddWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n});\n\n// HELPERS\n\n// LOCALES\n\nfunction localeWeek (mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n}\n\nvar defaultLocaleWeek = {\n    dow : 0, // Sunday is the first day of the week.\n    doy : 6  // The week that contains Jan 1st is the first week of the year.\n};\n\nfunction localeFirstDayOfWeek () {\n    return this._week.dow;\n}\n\nfunction localeFirstDayOfYear () {\n    return this._week.doy;\n}\n\n// MOMENTS\n\nfunction getSetWeek (input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\nfunction getSetISOWeek (input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\n// FORMATTING\n\naddFormatToken('d', 0, 'do', 'day');\n\naddFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n});\n\naddFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n});\n\naddFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n});\n\naddFormatToken('e', 0, 0, 'weekday');\naddFormatToken('E', 0, 0, 'isoWeekday');\n\n// ALIASES\n\naddUnitAlias('day', 'd');\naddUnitAlias('weekday', 'e');\naddUnitAlias('isoWeekday', 'E');\n\n// PRIORITY\naddUnitPriority('day', 11);\naddUnitPriority('weekday', 11);\naddUnitPriority('isoWeekday', 11);\n\n// PARSING\n\naddRegexToken('d',    match1to2);\naddRegexToken('e',    match1to2);\naddRegexToken('E',    match1to2);\naddRegexToken('dd',   function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n});\naddRegexToken('ddd',   function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n});\naddRegexToken('dddd',   function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n});\n\naddWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict);\n    // if we didn't get a weekday name, mark the date as invalid\n    if (weekday != null) {\n        week.d = weekday;\n    } else {\n        getParsingFlags(config).invalidWeekday = input;\n    }\n});\n\naddWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n});\n\n// HELPERS\n\nfunction parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n        return input;\n    }\n\n    if (!isNaN(input)) {\n        return parseInt(input, 10);\n    }\n\n    input = locale.weekdaysParse(input);\n    if (typeof input === 'number') {\n        return input;\n    }\n\n    return null;\n}\n\nfunction parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n        return locale.weekdaysParse(input) % 7 || 7;\n    }\n    return isNaN(input) ? null : input;\n}\n\n// LOCALES\n\nvar defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\nfunction localeWeekdays (m, format) {\n    if (!m) {\n        return isArray(this._weekdays) ? this._weekdays :\n            this._weekdays['standalone'];\n    }\n    return isArray(this._weekdays) ? this._weekdays[m.day()] :\n        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n}\n\nvar defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\nfunction localeWeekdaysShort (m) {\n    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n}\n\nvar defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\nfunction localeWeekdaysMin (m) {\n    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n}\n\nfunction handleStrictParse$1(weekdayName, format, strict) {\n    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._minWeekdaysParse = [];\n\n        for (i = 0; i < 7; ++i) {\n            mom = createUTC([2000, 1]).day(i);\n            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'dddd') {\n            ii = indexOf.call(this._weekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'dddd') {\n            ii = indexOf.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf.call(this._minWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeWeekdaysParse (weekdayName, format, strict) {\n    var i, mom, regex;\n\n    if (this._weekdaysParseExact) {\n        return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._minWeekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._fullWeekdaysParse = [];\n    }\n\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n\n        mom = createUTC([2000, 1]).day(i);\n        if (strict && !this._fullWeekdaysParse[i]) {\n            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n        }\n        if (!this._weekdaysParse[i]) {\n            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction getSetDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n    if (input != null) {\n        input = parseWeekday(input, this.localeData());\n        return this.add(input - day, 'd');\n    } else {\n        return day;\n    }\n}\n\nfunction getSetLocaleDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n}\n\nfunction getSetISODayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n\n    // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n    if (input != null) {\n        var weekday = parseIsoWeekday(input, this.localeData());\n        return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n        return this.day() || 7;\n    }\n}\n\nvar defaultWeekdaysRegex = matchWord;\nfunction weekdaysRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysStrictRegex;\n        } else {\n            return this._weekdaysRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            this._weekdaysRegex = defaultWeekdaysRegex;\n        }\n        return this._weekdaysStrictRegex && isStrict ?\n            this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n}\n\nvar defaultWeekdaysShortRegex = matchWord;\nfunction weekdaysShortRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysShortStrictRegex;\n        } else {\n            return this._weekdaysShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n            this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n        }\n        return this._weekdaysShortStrictRegex && isStrict ?\n            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n}\n\nvar defaultWeekdaysMinRegex = matchWord;\nfunction weekdaysMinRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysMinStrictRegex;\n        } else {\n            return this._weekdaysMinRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n            this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n        }\n        return this._weekdaysMinStrictRegex && isStrict ?\n            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n}\n\n\nfunction computeWeekdaysParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom, minp, shortp, longp;\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, 1]).day(i);\n        minp = this.weekdaysMin(mom, '');\n        shortp = this.weekdaysShort(mom, '');\n        longp = this.weekdays(mom, '');\n        minPieces.push(minp);\n        shortPieces.push(shortp);\n        longPieces.push(longp);\n        mixedPieces.push(minp);\n        mixedPieces.push(shortp);\n        mixedPieces.push(longp);\n    }\n    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 7; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\nfunction hFormat() {\n    return this.hours() % 12 || 12;\n}\n\nfunction kFormat() {\n    return this.hours() || 24;\n}\n\naddFormatToken('H', ['HH', 2], 0, 'hour');\naddFormatToken('h', ['hh', 2], 0, hFormat);\naddFormatToken('k', ['kk', 2], 0, kFormat);\n\naddFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\naddFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\nfunction meridiem (token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n}\n\nmeridiem('a', true);\nmeridiem('A', false);\n\n// ALIASES\n\naddUnitAlias('hour', 'h');\n\n// PRIORITY\naddUnitPriority('hour', 13);\n\n// PARSING\n\nfunction matchMeridiem (isStrict, locale) {\n    return locale._meridiemParse;\n}\n\naddRegexToken('a',  matchMeridiem);\naddRegexToken('A',  matchMeridiem);\naddRegexToken('H',  match1to2);\naddRegexToken('h',  match1to2);\naddRegexToken('k',  match1to2);\naddRegexToken('HH', match1to2, match2);\naddRegexToken('hh', match1to2, match2);\naddRegexToken('kk', match1to2, match2);\n\naddRegexToken('hmm', match3to4);\naddRegexToken('hmmss', match5to6);\naddRegexToken('Hmm', match3to4);\naddRegexToken('Hmmss', match5to6);\n\naddParseToken(['H', 'HH'], HOUR);\naddParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n});\naddParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n});\naddParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n});\naddParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n});\n\n// LOCALES\n\nfunction localeIsPM (input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return ((input + '').toLowerCase().charAt(0) === 'p');\n}\n\nvar defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\nfunction localeMeridiem (hours, minutes, isLower) {\n    if (hours > 11) {\n        return isLower ? 'pm' : 'PM';\n    } else {\n        return isLower ? 'am' : 'AM';\n    }\n}\n\n\n// MOMENTS\n\n// Setting the hour should keep the time, because the user explicitly\n// specified which hour he wants. So trying to maintain the same hour (in\n// a new timezone) makes sense. Adding/subtracting hours does not follow\n// this rule.\nvar getSetHour = makeGetSet('Hours', true);\n\n// months\n// week\n// weekdays\n// meridiem\nvar baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n\n    week: defaultLocaleWeek,\n\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n\n    meridiemParse: defaultLocaleMeridiemParse\n};\n\n// internal storage for locale config files\nvar locales = {};\nvar localeFamilies = {};\nvar globalLocale;\n\nfunction normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n}\n\n// pick the locale from the array\n// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\nfunction chooseLocale(names) {\n    var i = 0, j, next, locale, split;\n\n    while (i < names.length) {\n        split = normalizeLocale(names[i]).split('-');\n        j = split.length;\n        next = normalizeLocale(names[i + 1]);\n        next = next ? next.split('-') : null;\n        while (j > 0) {\n            locale = loadLocale(split.slice(0, j).join('-'));\n            if (locale) {\n                return locale;\n            }\n            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                //the next array item is better than a shallower substring of this one\n                break;\n            }\n            j--;\n        }\n        i++;\n    }\n    return null;\n}\n\nfunction loadLocale(name) {\n    var oldLocale = null;\n    // TODO: Find a better way to register and load all the locales in Node\n    if (!locales[name] && (typeof module !== 'undefined') &&\n            module && module.exports) {\n        try {\n            oldLocale = globalLocale._abbr;\n            var aliasedRequire = require;\n            aliasedRequire('./locale/' + name);\n            getSetGlobalLocale(oldLocale);\n        } catch (e) {}\n    }\n    return locales[name];\n}\n\n// This function will load locale and then set the global locale.  If\n// no arguments are passed in, it will simply return the current global\n// locale key.\nfunction getSetGlobalLocale (key, values) {\n    var data;\n    if (key) {\n        if (isUndefined(values)) {\n            data = getLocale(key);\n        }\n        else {\n            data = defineLocale(key, values);\n        }\n\n        if (data) {\n            // moment.duration._locale = moment._locale = data;\n            globalLocale = data;\n        }\n    }\n\n    return globalLocale._abbr;\n}\n\nfunction defineLocale (name, config) {\n    if (config !== null) {\n        var parentConfig = baseConfig;\n        config.abbr = name;\n        if (locales[name] != null) {\n            deprecateSimple('defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                    'an existing locale. moment.defineLocale(localeName, ' +\n                    'config) should only be used for creating a new locale ' +\n                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n            parentConfig = locales[name]._config;\n        } else if (config.parentLocale != null) {\n            if (locales[config.parentLocale] != null) {\n                parentConfig = locales[config.parentLocale]._config;\n            } else {\n                if (!localeFamilies[config.parentLocale]) {\n                    localeFamilies[config.parentLocale] = [];\n                }\n                localeFamilies[config.parentLocale].push({\n                    name: name,\n                    config: config\n                });\n                return null;\n            }\n        }\n        locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n        if (localeFamilies[name]) {\n            localeFamilies[name].forEach(function (x) {\n                defineLocale(x.name, x.config);\n            });\n        }\n\n        // backwards compat for now: also set the locale\n        // make sure we set the locale AFTER all child locales have been\n        // created, so we won't end up with the child locale set.\n        getSetGlobalLocale(name);\n\n\n        return locales[name];\n    } else {\n        // useful for testing\n        delete locales[name];\n        return null;\n    }\n}\n\nfunction updateLocale(name, config) {\n    if (config != null) {\n        var locale, tmpLocale, parentConfig = baseConfig;\n        // MERGE\n        tmpLocale = loadLocale(name);\n        if (tmpLocale != null) {\n            parentConfig = tmpLocale._config;\n        }\n        config = mergeConfigs(parentConfig, config);\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n\n        // backwards compat for now: also set the locale\n        getSetGlobalLocale(name);\n    } else {\n        // pass null for config to unupdate, useful for tests\n        if (locales[name] != null) {\n            if (locales[name].parentLocale != null) {\n                locales[name] = locales[name].parentLocale;\n            } else if (locales[name] != null) {\n                delete locales[name];\n            }\n        }\n    }\n    return locales[name];\n}\n\n// returns locale data\nfunction getLocale (key) {\n    var locale;\n\n    if (key && key._locale && key._locale._abbr) {\n        key = key._locale._abbr;\n    }\n\n    if (!key) {\n        return globalLocale;\n    }\n\n    if (!isArray(key)) {\n        //short-circuit everything else\n        locale = loadLocale(key);\n        if (locale) {\n            return locale;\n        }\n        key = [key];\n    }\n\n    return chooseLocale(key);\n}\n\nfunction listLocales() {\n    return keys(locales);\n}\n\nfunction checkOverflow (m) {\n    var overflow;\n    var a = m._a;\n\n    if (a && getParsingFlags(m).overflow === -2) {\n        overflow =\n            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n            -1;\n\n        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n            overflow = DATE;\n        }\n        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n            overflow = WEEK;\n        }\n        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n            overflow = WEEKDAY;\n        }\n\n        getParsingFlags(m).overflow = overflow;\n    }\n\n    return m;\n}\n\n// Pick the first defined of two or three arguments.\nfunction defaults(a, b, c) {\n    if (a != null) {\n        return a;\n    }\n    if (b != null) {\n        return b;\n    }\n    return c;\n}\n\nfunction currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n    if (config._useUTC) {\n        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n}\n\n// convert an array to a date.\n// the array should mirror the parameters below\n// note: all values past the year are optional and will default to the lowest possible value.\n// [year, month, day , hour, minute, second, millisecond]\nfunction configFromArray (config) {\n    var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n    if (config._d) {\n        return;\n    }\n\n    currentDate = currentDateArray(config);\n\n    //compute day of the year from weeks and weekdays\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n        dayOfYearFromWeekInfo(config);\n    }\n\n    //if the day of the year is set, figure out what it is\n    if (config._dayOfYear != null) {\n        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n            getParsingFlags(config)._overflowDayOfYear = true;\n        }\n\n        date = createUTCDate(yearToUse, 0, config._dayOfYear);\n        config._a[MONTH] = date.getUTCMonth();\n        config._a[DATE] = date.getUTCDate();\n    }\n\n    // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n        config._a[i] = input[i] = currentDate[i];\n    }\n\n    // Zero out whatever was not defaulted, including time\n    for (; i < 7; i++) {\n        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n    }\n\n    // Check for 24:00:00.000\n    if (config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0) {\n        config._nextDay = true;\n        config._a[HOUR] = 0;\n    }\n\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n    // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n    if (config._tzm != null) {\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n\n    if (config._nextDay) {\n        config._a[HOUR] = 24;\n    }\n\n    // check for mismatching day of week\n    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n        getParsingFlags(config).weekdayMismatch = true;\n    }\n}\n\nfunction dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n    w = config._w;\n    if (w.GG != null || w.W != null || w.E != null) {\n        dow = 1;\n        doy = 4;\n\n        // TODO: We need to take the current isoWeekYear, but that depends on\n        // how we interpret now (local, utc, fixed offset). So create\n        // a now version of current config (take local/utc/offset flags, and\n        // create now).\n        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n        week = defaults(w.W, 1);\n        weekday = defaults(w.E, 1);\n        if (weekday < 1 || weekday > 7) {\n            weekdayOverflow = true;\n        }\n    } else {\n        dow = config._locale._week.dow;\n        doy = config._locale._week.doy;\n\n        var curWeek = weekOfYear(createLocal(), dow, doy);\n\n        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n        // Default to current week.\n        week = defaults(w.w, curWeek.week);\n\n        if (w.d != null) {\n            // weekday -- low day numbers are considered next week\n            weekday = w.d;\n            if (weekday < 0 || weekday > 6) {\n                weekdayOverflow = true;\n            }\n        } else if (w.e != null) {\n            // local weekday -- counting starts from begining of week\n            weekday = w.e + dow;\n            if (w.e < 0 || w.e > 6) {\n                weekdayOverflow = true;\n            }\n        } else {\n            // default to begining of week\n            weekday = dow;\n        }\n    }\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n        getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n        getParsingFlags(config)._overflowWeekday = true;\n    } else {\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n}\n\n// iso 8601 regex\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\nvar extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\nvar basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\nvar tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\nvar isoDates = [\n    ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n    ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n    ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n    ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n    ['YYYY-DDD', /\\d{4}-\\d{3}/],\n    ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n    ['YYYYYYMMDD', /[+-]\\d{10}/],\n    ['YYYYMMDD', /\\d{8}/],\n    // YYYYMM is NOT allowed by the standard\n    ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n    ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n    ['YYYYDDD', /\\d{7}/]\n];\n\n// iso time formats and regexes\nvar isoTimes = [\n    ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n    ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n    ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n    ['HH:mm', /\\d\\d:\\d\\d/],\n    ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n    ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n    ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n    ['HHmm', /\\d\\d\\d\\d/],\n    ['HH', /\\d\\d/]\n];\n\nvar aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n// date from iso format\nfunction configFromISO(config) {\n    var i, l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime, dateFormat, timeFormat, tzFormat;\n\n    if (match) {\n        getParsingFlags(config).iso = true;\n\n        for (i = 0, l = isoDates.length; i < l; i++) {\n            if (isoDates[i][1].exec(match[1])) {\n                dateFormat = isoDates[i][0];\n                allowTime = isoDates[i][2] !== false;\n                break;\n            }\n        }\n        if (dateFormat == null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[3]) {\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(match[3])) {\n                    // match[2] should be 'T' or space\n                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (timeFormat == null) {\n                config._isValid = false;\n                return;\n            }\n        }\n        if (!allowTime && timeFormat != null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[4]) {\n            if (tzRegex.exec(match[4])) {\n                tzFormat = 'Z';\n            } else {\n                config._isValid = false;\n                return;\n            }\n        }\n        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n        configFromStringAndFormat(config);\n    } else {\n        config._isValid = false;\n    }\n}\n\n// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\nvar rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\nfunction extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n    var result = [\n        untruncateYear(yearStr),\n        defaultLocaleMonthsShort.indexOf(monthStr),\n        parseInt(dayStr, 10),\n        parseInt(hourStr, 10),\n        parseInt(minuteStr, 10)\n    ];\n\n    if (secondStr) {\n        result.push(parseInt(secondStr, 10));\n    }\n\n    return result;\n}\n\nfunction untruncateYear(yearStr) {\n    var year = parseInt(yearStr, 10);\n    if (year <= 49) {\n        return 2000 + year;\n    } else if (year <= 999) {\n        return 1900 + year;\n    }\n    return year;\n}\n\nfunction preprocessRFC2822(s) {\n    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n    return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').trim();\n}\n\nfunction checkWeekday(weekdayStr, parsedInput, config) {\n    if (weekdayStr) {\n        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n        if (weekdayProvided !== weekdayActual) {\n            getParsingFlags(config).weekdayMismatch = true;\n            config._isValid = false;\n            return false;\n        }\n    }\n    return true;\n}\n\nvar obsOffsets = {\n    UT: 0,\n    GMT: 0,\n    EDT: -4 * 60,\n    EST: -5 * 60,\n    CDT: -5 * 60,\n    CST: -6 * 60,\n    MDT: -6 * 60,\n    MST: -7 * 60,\n    PDT: -7 * 60,\n    PST: -8 * 60\n};\n\nfunction calculateOffset(obsOffset, militaryOffset, numOffset) {\n    if (obsOffset) {\n        return obsOffsets[obsOffset];\n    } else if (militaryOffset) {\n        // the only allowed military tz is Z\n        return 0;\n    } else {\n        var hm = parseInt(numOffset, 10);\n        var m = hm % 100, h = (hm - m) / 100;\n        return h * 60 + m;\n    }\n}\n\n// date and time from ref 2822 format\nfunction configFromRFC2822(config) {\n    var match = rfc2822.exec(preprocessRFC2822(config._i));\n    if (match) {\n        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n        if (!checkWeekday(match[1], parsedArray, config)) {\n            return;\n        }\n\n        config._a = parsedArray;\n        config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n        config._d = createUTCDate.apply(null, config._a);\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n        getParsingFlags(config).rfc2822 = true;\n    } else {\n        config._isValid = false;\n    }\n}\n\n// date from iso format or fallback\nfunction configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n\n    if (matched !== null) {\n        config._d = new Date(+matched[1]);\n        return;\n    }\n\n    configFromISO(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    configFromRFC2822(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    // Final attempt, use Input Fallback\n    hooks.createFromInputFallback(config);\n}\n\nhooks.createFromInputFallback = deprecate(\n    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n    'discouraged and will be removed in an upcoming major release. Please refer to ' +\n    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n    function (config) {\n        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n    }\n);\n\n// constant that refers to the ISO standard\nhooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\nhooks.RFC_2822 = function () {};\n\n// date from string and format string\nfunction configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n        configFromISO(config);\n        return;\n    }\n    if (config._f === hooks.RFC_2822) {\n        configFromRFC2822(config);\n        return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n        i, parsedInput, tokens, token, skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0;\n\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n        // console.log('token', token, 'parsedInput', parsedInput,\n        //         'regex', getParseRegexForToken(token, config));\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            }\n            else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n        else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0) {\n        getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n    configFromArray(config);\n    checkOverflow(config);\n}\n\n\nfunction meridiemFixWrap (locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n        // Fallback\n        isPm = locale.isPM(meridiem);\n        if (isPm && hour < 12) {\n            hour += 12;\n        }\n        if (!isPm && hour === 12) {\n            hour = 0;\n        }\n        return hour;\n    } else {\n        // this is not supposed to happen\n        return hour;\n    }\n}\n\n// date from string and array of format strings\nfunction configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n\n        scoreToBeat,\n        i,\n        currentScore;\n\n    if (config._f.length === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n\n    for (i = 0; i < config._f.length; i++) {\n        currentScore = 0;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n\n        if (!isValid(tempConfig)) {\n            continue;\n        }\n\n        // if there is any input that was not parsed add a penalty for that format\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        //or tokens\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n\n        if (scoreToBeat == null || currentScore < scoreToBeat) {\n            scoreToBeat = currentScore;\n            bestMoment = tempConfig;\n        }\n    }\n\n    extend(config, bestMoment || tempConfig);\n}\n\nfunction configFromObject(config) {\n    if (config._d) {\n        return;\n    }\n\n    var i = normalizeObjectUnits(config._i);\n    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n        return obj && parseInt(obj, 10);\n    });\n\n    configFromArray(config);\n}\n\nfunction createFromConfig (config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n    if (res._nextDay) {\n        // Adding is smart enough around DST\n        res.add(1, 'd');\n        res._nextDay = undefined;\n    }\n\n    return res;\n}\n\nfunction prepareConfig (config) {\n    var input = config._i,\n        format = config._f;\n\n    config._locale = config._locale || getLocale(config._l);\n\n    if (input === null || (format === undefined && input === '')) {\n        return createInvalid({nullInput: true});\n    }\n\n    if (typeof input === 'string') {\n        config._i = input = config._locale.preparse(input);\n    }\n\n    if (isMoment(input)) {\n        return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n        config._d = input;\n    } else if (isArray(format)) {\n        configFromStringAndArray(config);\n    } else if (format) {\n        configFromStringAndFormat(config);\n    }  else {\n        configFromInput(config);\n    }\n\n    if (!isValid(config)) {\n        config._d = null;\n    }\n\n    return config;\n}\n\nfunction configFromInput(config) {\n    var input = config._i;\n    if (isUndefined(input)) {\n        config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n        config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n        configFromString(config);\n    } else if (isArray(input)) {\n        config._a = map(input.slice(0), function (obj) {\n            return parseInt(obj, 10);\n        });\n        configFromArray(config);\n    } else if (isObject(input)) {\n        configFromObject(config);\n    } else if (isNumber(input)) {\n        // from milliseconds\n        config._d = new Date(input);\n    } else {\n        hooks.createFromInputFallback(config);\n    }\n}\n\nfunction createLocalOrUTC (input, format, locale, strict, isUTC) {\n    var c = {};\n\n    if (locale === true || locale === false) {\n        strict = locale;\n        locale = undefined;\n    }\n\n    if ((isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)) {\n        input = undefined;\n    }\n    // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n\n    return createFromConfig(c);\n}\n\nfunction createLocal (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n}\n\nvar prototypeMin = deprecate(\n    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\nvar prototypeMax = deprecate(\n    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\n// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nfunction pickBy(fn, moments) {\n    var res, i;\n    if (moments.length === 1 && isArray(moments[0])) {\n        moments = moments[0];\n    }\n    if (!moments.length) {\n        return createLocal();\n    }\n    res = moments[0];\n    for (i = 1; i < moments.length; ++i) {\n        if (!moments[i].isValid() || moments[i][fn](res)) {\n            res = moments[i];\n        }\n    }\n    return res;\n}\n\n// TODO: Use [].sort instead?\nfunction min () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isBefore', args);\n}\n\nfunction max () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isAfter', args);\n}\n\nvar now = function () {\n    return Date.now ? Date.now() : +(new Date());\n};\n\nvar ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\nfunction isDurationValid(m) {\n    for (var key in m) {\n        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n            return false;\n        }\n    }\n\n    var unitHasDecimal = false;\n    for (var i = 0; i < ordering.length; ++i) {\n        if (m[ordering[i]]) {\n            if (unitHasDecimal) {\n                return false; // only allow non-integers for smallest unit\n            }\n            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                unitHasDecimal = true;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction isValid$1() {\n    return this._isValid;\n}\n\nfunction createInvalid$1() {\n    return createDuration(NaN);\n}\n\nfunction Duration (duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        quarters = normalizedInput.quarter || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0;\n\n    this._isValid = isDurationValid(normalizedInput);\n\n    // representation for dateAddRemove\n    this._milliseconds = +milliseconds +\n        seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n    this._days = +days +\n        weeks * 7;\n    // It is impossible to translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n    this._months = +months +\n        quarters * 3 +\n        years * 12;\n\n    this._data = {};\n\n    this._locale = getLocale();\n\n    this._bubble();\n}\n\nfunction isDuration (obj) {\n    return obj instanceof Duration;\n}\n\nfunction absRound (number) {\n    if (number < 0) {\n        return Math.round(-1 * number) * -1;\n    } else {\n        return Math.round(number);\n    }\n}\n\n// FORMATTING\n\nfunction offset (token, separator) {\n    addFormatToken(token, 0, 0, function () {\n        var offset = this.utcOffset();\n        var sign = '+';\n        if (offset < 0) {\n            offset = -offset;\n            sign = '-';\n        }\n        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n    });\n}\n\noffset('Z', ':');\noffset('ZZ', '');\n\n// PARSING\n\naddRegexToken('Z',  matchShortOffset);\naddRegexToken('ZZ', matchShortOffset);\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n});\n\n// HELPERS\n\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\nvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\nfunction offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher);\n\n    if (matches === null) {\n        return null;\n    }\n\n    var chunk   = matches[matches.length - 1] || [];\n    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n    return minutes === 0 ?\n      0 :\n      parts[0] === '+' ? minutes : -minutes;\n}\n\n// Return a moment from input, that is local/utc/zone equivalent to model.\nfunction cloneWithOffset(input, model) {\n    var res, diff;\n    if (model._isUTC) {\n        res = model.clone();\n        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n        // Use low-level api, because this fn is low-level api.\n        res._d.setTime(res._d.valueOf() + diff);\n        hooks.updateOffset(res, false);\n        return res;\n    } else {\n        return createLocal(input).local();\n    }\n}\n\nfunction getDateOffset (m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n}\n\n// HOOKS\n\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\nhooks.updateOffset = function () {};\n\n// MOMENTS\n\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\nfunction getSetOffset (input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    if (input != null) {\n        if (typeof input === 'string') {\n            input = offsetFromString(matchShortOffset, input);\n            if (input === null) {\n                return this;\n            }\n        } else if (Math.abs(input) < 16 && !keepMinutes) {\n            input = input * 60;\n        }\n        if (!this._isUTC && keepLocalTime) {\n            localAdjust = getDateOffset(this);\n        }\n        this._offset = input;\n        this._isUTC = true;\n        if (localAdjust != null) {\n            this.add(localAdjust, 'm');\n        }\n        if (offset !== input) {\n            if (!keepLocalTime || this._changeInProgress) {\n                addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n            } else if (!this._changeInProgress) {\n                this._changeInProgress = true;\n                hooks.updateOffset(this, true);\n                this._changeInProgress = null;\n            }\n        }\n        return this;\n    } else {\n        return this._isUTC ? offset : getDateOffset(this);\n    }\n}\n\nfunction getSetZone (input, keepLocalTime) {\n    if (input != null) {\n        if (typeof input !== 'string') {\n            input = -input;\n        }\n\n        this.utcOffset(input, keepLocalTime);\n\n        return this;\n    } else {\n        return -this.utcOffset();\n    }\n}\n\nfunction setOffsetToUTC (keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n}\n\nfunction setOffsetToLocal (keepLocalTime) {\n    if (this._isUTC) {\n        this.utcOffset(0, keepLocalTime);\n        this._isUTC = false;\n\n        if (keepLocalTime) {\n            this.subtract(getDateOffset(this), 'm');\n        }\n    }\n    return this;\n}\n\nfunction setOffsetToParsedOffset () {\n    if (this._tzm != null) {\n        this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n        var tZone = offsetFromString(matchOffset, this._i);\n        if (tZone != null) {\n            this.utcOffset(tZone);\n        }\n        else {\n            this.utcOffset(0, true);\n        }\n    }\n    return this;\n}\n\nfunction hasAlignedHourOffset (input) {\n    if (!this.isValid()) {\n        return false;\n    }\n    input = input ? createLocal(input).utcOffset() : 0;\n\n    return (this.utcOffset() - input) % 60 === 0;\n}\n\nfunction isDaylightSavingTime () {\n    return (\n        this.utcOffset() > this.clone().month(0).utcOffset() ||\n        this.utcOffset() > this.clone().month(5).utcOffset()\n    );\n}\n\nfunction isDaylightSavingTimeShifted () {\n    if (!isUndefined(this._isDSTShifted)) {\n        return this._isDSTShifted;\n    }\n\n    var c = {};\n\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n        this._isDSTShifted = this.isValid() &&\n            compareArrays(c._a, other.toArray()) > 0;\n    } else {\n        this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n}\n\nfunction isLocal () {\n    return this.isValid() ? !this._isUTC : false;\n}\n\nfunction isUtcOffset () {\n    return this.isValid() ? this._isUTC : false;\n}\n\nfunction isUtc () {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n}\n\n// ASP.NET json date format regex\nvar aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n// and further modified to allow for strings containing both week and day\nvar isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\nfunction createDuration (input, key) {\n    var duration = input,\n        // matching against regexp is expensive, do it on demand\n        match = null,\n        sign,\n        ret,\n        diffRes;\n\n    if (isDuration(input)) {\n        duration = {\n            ms : input._milliseconds,\n            d  : input._days,\n            M  : input._months\n        };\n    } else if (isNumber(input)) {\n        duration = {};\n        if (key) {\n            duration[key] = input;\n        } else {\n            duration.milliseconds = input;\n        }\n    } else if (!!(match = aspNetRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y  : 0,\n            d  : toInt(match[DATE])                         * sign,\n            h  : toInt(match[HOUR])                         * sign,\n            m  : toInt(match[MINUTE])                       * sign,\n            s  : toInt(match[SECOND])                       * sign,\n            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n        };\n    } else if (!!(match = isoRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n        duration = {\n            y : parseIso(match[2], sign),\n            M : parseIso(match[3], sign),\n            w : parseIso(match[4], sign),\n            d : parseIso(match[5], sign),\n            h : parseIso(match[6], sign),\n            m : parseIso(match[7], sign),\n            s : parseIso(match[8], sign)\n        };\n    } else if (duration == null) {// checks for null or undefined\n        duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n        duration = {};\n        duration.ms = diffRes.milliseconds;\n        duration.M = diffRes.months;\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n        ret._locale = input._locale;\n    }\n\n    return ret;\n}\n\ncreateDuration.fn = Duration.prototype;\ncreateDuration.invalid = createInvalid$1;\n\nfunction parseIso (inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.'));\n    // apply sign while we're at it\n    return (isNaN(res) ? 0 : res) * sign;\n}\n\nfunction positiveMomentsDifference(base, other) {\n    var res = {milliseconds: 0, months: 0};\n\n    res.months = other.month() - base.month() +\n        (other.year() - base.year()) * 12;\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n        --res.months;\n    }\n\n    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n    return res;\n}\n\nfunction momentsDifference(base, other) {\n    var res;\n    if (!(base.isValid() && other.isValid())) {\n        return {milliseconds: 0, months: 0};\n    }\n\n    other = cloneWithOffset(other, base);\n    if (base.isBefore(other)) {\n        res = positiveMomentsDifference(base, other);\n    } else {\n        res = positiveMomentsDifference(other, base);\n        res.milliseconds = -res.milliseconds;\n        res.months = -res.months;\n    }\n\n    return res;\n}\n\n// TODO: remove 'name' arg after deprecation is removed\nfunction createAdder(direction, name) {\n    return function (val, period) {\n        var dur, tmp;\n        //invert the arguments, but complain about it\n        if (period !== null && !isNaN(+period)) {\n            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n            tmp = val; val = period; period = tmp;\n        }\n\n        val = typeof val === 'string' ? +val : val;\n        dur = createDuration(val, period);\n        addSubtract(this, dur, direction);\n        return this;\n    };\n}\n\nfunction addSubtract (mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = absRound(duration._days),\n        months = absRound(duration._months);\n\n    if (!mom.isValid()) {\n        // No op\n        return;\n    }\n\n    updateOffset = updateOffset == null ? true : updateOffset;\n\n    if (months) {\n        setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n    if (days) {\n        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n    if (milliseconds) {\n        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n    if (updateOffset) {\n        hooks.updateOffset(mom, days || months);\n    }\n}\n\nvar add      = createAdder(1, 'add');\nvar subtract = createAdder(-1, 'subtract');\n\nfunction getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' :\n            diff < -1 ? 'lastWeek' :\n            diff < 0 ? 'lastDay' :\n            diff < 1 ? 'sameDay' :\n            diff < 2 ? 'nextDay' :\n            diff < 7 ? 'nextWeek' : 'sameElse';\n}\n\nfunction calendar$1 (time, formats) {\n    // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n    var now = time || createLocal(),\n        sod = cloneWithOffset(now, this).startOf('day'),\n        format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n}\n\nfunction clone () {\n    return new Moment(this);\n}\n\nfunction isAfter (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() > localInput.valueOf();\n    } else {\n        return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n}\n\nfunction isBefore (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() < localInput.valueOf();\n    } else {\n        return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n}\n\nfunction isBetween (from, to, units, inclusivity) {\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n}\n\nfunction isSame (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n        inputMs;\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(units || 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() === localInput.valueOf();\n    } else {\n        inputMs = localInput.valueOf();\n        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n}\n\nfunction isSameOrAfter (input, units) {\n    return this.isSame(input, units) || this.isAfter(input,units);\n}\n\nfunction isSameOrBefore (input, units) {\n    return this.isSame(input, units) || this.isBefore(input,units);\n}\n\nfunction diff (input, units, asFloat) {\n    var that,\n        zoneDelta,\n        delta, output;\n\n    if (!this.isValid()) {\n        return NaN;\n    }\n\n    that = cloneWithOffset(input, this);\n\n    if (!that.isValid()) {\n        return NaN;\n    }\n\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n    units = normalizeUnits(units);\n\n    switch (units) {\n        case 'year': output = monthDiff(this, that) / 12; break;\n        case 'month': output = monthDiff(this, that); break;\n        case 'quarter': output = monthDiff(this, that) / 3; break;\n        case 'second': output = (this - that) / 1e3; break; // 1000\n        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n        default: output = this - that;\n    }\n\n    return asFloat ? output : absFloor(output);\n}\n\nfunction monthDiff (a, b) {\n    // difference in months\n    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n        // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, 'months'),\n        anchor2, adjust;\n\n    if (b - anchor < 0) {\n        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor2 - anchor);\n    }\n\n    //check for negative zero, return zero if negative zero\n    return -(wholeMonthDiff + adjust) || 0;\n}\n\nhooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\nhooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\nfunction toString () {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n}\n\nfunction toISOString(keepOffset) {\n    if (!this.isValid()) {\n        return null;\n    }\n    var utc = keepOffset !== true;\n    var m = utc ? this.clone().utc() : this;\n    if (m.year() < 0 || m.year() > 9999) {\n        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n    if (isFunction(Date.prototype.toISOString)) {\n        // native implementation is ~50x faster, use it when we can\n        if (utc) {\n            return this.toDate().toISOString();\n        } else {\n            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));\n        }\n    }\n    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n}\n\n/**\n * Return a human readable representation of a moment that can\n * also be evaluated to get a new moment which is the same\n *\n * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n */\nfunction inspect () {\n    if (!this.isValid()) {\n        return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n    var func = 'moment';\n    var zone = '';\n    if (!this.isLocal()) {\n        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n        zone = 'Z';\n    }\n    var prefix = '[' + func + '(\"]';\n    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n    var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    var suffix = zone + '[\")]';\n\n    return this.format(prefix + year + datetime + suffix);\n}\n\nfunction format (inputString) {\n    if (!inputString) {\n        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n}\n\nfunction from (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction fromNow (withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n}\n\nfunction to (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction toNow (withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n}\n\n// If passed a locale key, it will set the locale for this\n// instance.  Otherwise, it will return the locale configuration\n// variables for this instance.\nfunction locale (key) {\n    var newLocaleData;\n\n    if (key === undefined) {\n        return this._locale._abbr;\n    } else {\n        newLocaleData = getLocale(key);\n        if (newLocaleData != null) {\n            this._locale = newLocaleData;\n        }\n        return this;\n    }\n}\n\nvar lang = deprecate(\n    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n    function (key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    }\n);\n\nfunction localeData () {\n    return this._locale;\n}\n\nfunction startOf (units) {\n    units = normalizeUnits(units);\n    // the following switch intentionally omits break keywords\n    // to utilize falling through the cases.\n    switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n        case 'date':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n    }\n\n    // weeks are a special case\n    if (units === 'week') {\n        this.weekday(0);\n    }\n    if (units === 'isoWeek') {\n        this.isoWeekday(1);\n    }\n\n    // quarters are also special\n    if (units === 'quarter') {\n        this.month(Math.floor(this.month() / 3) * 3);\n    }\n\n    return this;\n}\n\nfunction endOf (units) {\n    units = normalizeUnits(units);\n    if (units === undefined || units === 'millisecond') {\n        return this;\n    }\n\n    // 'date' is an alias for 'day', so it should be considered as such.\n    if (units === 'date') {\n        units = 'day';\n    }\n\n    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n}\n\nfunction valueOf () {\n    return this._d.valueOf() - ((this._offset || 0) * 60000);\n}\n\nfunction unix () {\n    return Math.floor(this.valueOf() / 1000);\n}\n\nfunction toDate () {\n    return new Date(this.valueOf());\n}\n\nfunction toArray () {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n}\n\nfunction toObject () {\n    var m = this;\n    return {\n        years: m.year(),\n        months: m.month(),\n        date: m.date(),\n        hours: m.hours(),\n        minutes: m.minutes(),\n        seconds: m.seconds(),\n        milliseconds: m.milliseconds()\n    };\n}\n\nfunction toJSON () {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n}\n\nfunction isValid$2 () {\n    return isValid(this);\n}\n\nfunction parsingFlags () {\n    return extend({}, getParsingFlags(this));\n}\n\nfunction invalidAt () {\n    return getParsingFlags(this).overflow;\n}\n\nfunction creationData() {\n    return {\n        input: this._i,\n        format: this._f,\n        locale: this._locale,\n        isUTC: this._isUTC,\n        strict: this._strict\n    };\n}\n\n// FORMATTING\n\naddFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n});\n\naddFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n});\n\nfunction addWeekYearFormatToken (token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n}\n\naddWeekYearFormatToken('gggg',     'weekYear');\naddWeekYearFormatToken('ggggg',    'weekYear');\naddWeekYearFormatToken('GGGG',  'isoWeekYear');\naddWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n// ALIASES\n\naddUnitAlias('weekYear', 'gg');\naddUnitAlias('isoWeekYear', 'GG');\n\n// PRIORITY\n\naddUnitPriority('weekYear', 1);\naddUnitPriority('isoWeekYear', 1);\n\n\n// PARSING\n\naddRegexToken('G',      matchSigned);\naddRegexToken('g',      matchSigned);\naddRegexToken('GG',     match1to2, match2);\naddRegexToken('gg',     match1to2, match2);\naddRegexToken('GGGG',   match1to4, match4);\naddRegexToken('gggg',   match1to4, match4);\naddRegexToken('GGGGG',  match1to6, match6);\naddRegexToken('ggggg',  match1to6, match6);\n\naddWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n});\n\naddWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n});\n\n// MOMENTS\n\nfunction getSetWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy);\n}\n\nfunction getSetISOWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input, this.isoWeek(), this.isoWeekday(), 1, 4);\n}\n\nfunction getISOWeeksInYear () {\n    return weeksInYear(this.year(), 1, 4);\n}\n\nfunction getWeeksInYear () {\n    var weekInfo = this.localeData()._week;\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n}\n\nfunction getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n    if (input == null) {\n        return weekOfYear(this, dow, doy).year;\n    } else {\n        weeksTarget = weeksInYear(input, dow, doy);\n        if (week > weeksTarget) {\n            week = weeksTarget;\n        }\n        return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n}\n\nfunction setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n}\n\n// FORMATTING\n\naddFormatToken('Q', 0, 'Qo', 'quarter');\n\n// ALIASES\n\naddUnitAlias('quarter', 'Q');\n\n// PRIORITY\n\naddUnitPriority('quarter', 7);\n\n// PARSING\n\naddRegexToken('Q', match1);\naddParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n});\n\n// MOMENTS\n\nfunction getSetQuarter (input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n}\n\n// FORMATTING\n\naddFormatToken('D', ['DD', 2], 'Do', 'date');\n\n// ALIASES\n\naddUnitAlias('date', 'D');\n\n// PRIOROITY\naddUnitPriority('date', 9);\n\n// PARSING\n\naddRegexToken('D',  match1to2);\naddRegexToken('DD', match1to2, match2);\naddRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ?\n      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n      locale._dayOfMonthOrdinalParseLenient;\n});\n\naddParseToken(['D', 'DD'], DATE);\naddParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0]);\n});\n\n// MOMENTS\n\nvar getSetDayOfMonth = makeGetSet('Date', true);\n\n// FORMATTING\n\naddFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n// ALIASES\n\naddUnitAlias('dayOfYear', 'DDD');\n\n// PRIORITY\naddUnitPriority('dayOfYear', 4);\n\n// PARSING\n\naddRegexToken('DDD',  match1to3);\naddRegexToken('DDDD', match3);\naddParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n});\n\n// HELPERS\n\n// MOMENTS\n\nfunction getSetDayOfYear (input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n}\n\n// FORMATTING\n\naddFormatToken('m', ['mm', 2], 0, 'minute');\n\n// ALIASES\n\naddUnitAlias('minute', 'm');\n\n// PRIORITY\n\naddUnitPriority('minute', 14);\n\n// PARSING\n\naddRegexToken('m',  match1to2);\naddRegexToken('mm', match1to2, match2);\naddParseToken(['m', 'mm'], MINUTE);\n\n// MOMENTS\n\nvar getSetMinute = makeGetSet('Minutes', false);\n\n// FORMATTING\n\naddFormatToken('s', ['ss', 2], 0, 'second');\n\n// ALIASES\n\naddUnitAlias('second', 's');\n\n// PRIORITY\n\naddUnitPriority('second', 15);\n\n// PARSING\n\naddRegexToken('s',  match1to2);\naddRegexToken('ss', match1to2, match2);\naddParseToken(['s', 'ss'], SECOND);\n\n// MOMENTS\n\nvar getSetSecond = makeGetSet('Seconds', false);\n\n// FORMATTING\n\naddFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n});\n\naddFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n});\n\naddFormatToken(0, ['SSS', 3], 0, 'millisecond');\naddFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n});\naddFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n});\naddFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n});\naddFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n});\naddFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n});\naddFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n});\n\n\n// ALIASES\n\naddUnitAlias('millisecond', 'ms');\n\n// PRIORITY\n\naddUnitPriority('millisecond', 16);\n\n// PARSING\n\naddRegexToken('S',    match1to3, match1);\naddRegexToken('SS',   match1to3, match2);\naddRegexToken('SSS',  match1to3, match3);\n\nvar token;\nfor (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n}\n\nfunction parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n}\n\nfor (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n}\n// MOMENTS\n\nvar getSetMillisecond = makeGetSet('Milliseconds', false);\n\n// FORMATTING\n\naddFormatToken('z',  0, 0, 'zoneAbbr');\naddFormatToken('zz', 0, 0, 'zoneName');\n\n// MOMENTS\n\nfunction getZoneAbbr () {\n    return this._isUTC ? 'UTC' : '';\n}\n\nfunction getZoneName () {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n}\n\nvar proto = Moment.prototype;\n\nproto.add               = add;\nproto.calendar          = calendar$1;\nproto.clone             = clone;\nproto.diff              = diff;\nproto.endOf             = endOf;\nproto.format            = format;\nproto.from              = from;\nproto.fromNow           = fromNow;\nproto.to                = to;\nproto.toNow             = toNow;\nproto.get               = stringGet;\nproto.invalidAt         = invalidAt;\nproto.isAfter           = isAfter;\nproto.isBefore          = isBefore;\nproto.isBetween         = isBetween;\nproto.isSame            = isSame;\nproto.isSameOrAfter     = isSameOrAfter;\nproto.isSameOrBefore    = isSameOrBefore;\nproto.isValid           = isValid$2;\nproto.lang              = lang;\nproto.locale            = locale;\nproto.localeData        = localeData;\nproto.max               = prototypeMax;\nproto.min               = prototypeMin;\nproto.parsingFlags      = parsingFlags;\nproto.set               = stringSet;\nproto.startOf           = startOf;\nproto.subtract          = subtract;\nproto.toArray           = toArray;\nproto.toObject          = toObject;\nproto.toDate            = toDate;\nproto.toISOString       = toISOString;\nproto.inspect           = inspect;\nproto.toJSON            = toJSON;\nproto.toString          = toString;\nproto.unix              = unix;\nproto.valueOf           = valueOf;\nproto.creationData      = creationData;\n\n// Year\nproto.year       = getSetYear;\nproto.isLeapYear = getIsLeapYear;\n\n// Week Year\nproto.weekYear    = getSetWeekYear;\nproto.isoWeekYear = getSetISOWeekYear;\n\n// Quarter\nproto.quarter = proto.quarters = getSetQuarter;\n\n// Month\nproto.month       = getSetMonth;\nproto.daysInMonth = getDaysInMonth;\n\n// Week\nproto.week           = proto.weeks        = getSetWeek;\nproto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\nproto.weeksInYear    = getWeeksInYear;\nproto.isoWeeksInYear = getISOWeeksInYear;\n\n// Day\nproto.date       = getSetDayOfMonth;\nproto.day        = proto.days             = getSetDayOfWeek;\nproto.weekday    = getSetLocaleDayOfWeek;\nproto.isoWeekday = getSetISODayOfWeek;\nproto.dayOfYear  = getSetDayOfYear;\n\n// Hour\nproto.hour = proto.hours = getSetHour;\n\n// Minute\nproto.minute = proto.minutes = getSetMinute;\n\n// Second\nproto.second = proto.seconds = getSetSecond;\n\n// Millisecond\nproto.millisecond = proto.milliseconds = getSetMillisecond;\n\n// Offset\nproto.utcOffset            = getSetOffset;\nproto.utc                  = setOffsetToUTC;\nproto.local                = setOffsetToLocal;\nproto.parseZone            = setOffsetToParsedOffset;\nproto.hasAlignedHourOffset = hasAlignedHourOffset;\nproto.isDST                = isDaylightSavingTime;\nproto.isLocal              = isLocal;\nproto.isUtcOffset          = isUtcOffset;\nproto.isUtc                = isUtc;\nproto.isUTC                = isUtc;\n\n// Timezone\nproto.zoneAbbr = getZoneAbbr;\nproto.zoneName = getZoneName;\n\n// Deprecations\nproto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\nproto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\nproto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\nproto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\nproto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\nfunction createUnix (input) {\n    return createLocal(input * 1000);\n}\n\nfunction createInZone () {\n    return createLocal.apply(null, arguments).parseZone();\n}\n\nfunction preParsePostFormat (string) {\n    return string;\n}\n\nvar proto$1 = Locale.prototype;\n\nproto$1.calendar        = calendar;\nproto$1.longDateFormat  = longDateFormat;\nproto$1.invalidDate     = invalidDate;\nproto$1.ordinal         = ordinal;\nproto$1.preparse        = preParsePostFormat;\nproto$1.postformat      = preParsePostFormat;\nproto$1.relativeTime    = relativeTime;\nproto$1.pastFuture      = pastFuture;\nproto$1.set             = set;\n\n// Month\nproto$1.months            =        localeMonths;\nproto$1.monthsShort       =        localeMonthsShort;\nproto$1.monthsParse       =        localeMonthsParse;\nproto$1.monthsRegex       = monthsRegex;\nproto$1.monthsShortRegex  = monthsShortRegex;\n\n// Week\nproto$1.week = localeWeek;\nproto$1.firstDayOfYear = localeFirstDayOfYear;\nproto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n// Day of Week\nproto$1.weekdays       =        localeWeekdays;\nproto$1.weekdaysMin    =        localeWeekdaysMin;\nproto$1.weekdaysShort  =        localeWeekdaysShort;\nproto$1.weekdaysParse  =        localeWeekdaysParse;\n\nproto$1.weekdaysRegex       =        weekdaysRegex;\nproto$1.weekdaysShortRegex  =        weekdaysShortRegex;\nproto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n// Hours\nproto$1.isPM = localeIsPM;\nproto$1.meridiem = localeMeridiem;\n\nfunction get$1 (format, index, field, setter) {\n    var locale = getLocale();\n    var utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n}\n\nfunction listMonthsImpl (format, index, field) {\n    if (isNumber(format)) {\n        index = format;\n        format = undefined;\n    }\n\n    format = format || '';\n\n    if (index != null) {\n        return get$1(format, index, field, 'month');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 12; i++) {\n        out[i] = get$1(format, i, field, 'month');\n    }\n    return out;\n}\n\n// ()\n// (5)\n// (fmt, 5)\n// (fmt)\n// (true)\n// (true, 5)\n// (true, fmt, 5)\n// (true, fmt)\nfunction listWeekdaysImpl (localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    } else {\n        format = localeSorted;\n        index = format;\n        localeSorted = false;\n\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    }\n\n    var locale = getLocale(),\n        shift = localeSorted ? locale._week.dow : 0;\n\n    if (index != null) {\n        return get$1(format, (index + shift) % 7, field, 'day');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 7; i++) {\n        out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n    return out;\n}\n\nfunction listMonths (format, index) {\n    return listMonthsImpl(format, index, 'months');\n}\n\nfunction listMonthsShort (format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n}\n\nfunction listWeekdays (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n}\n\nfunction listWeekdaysShort (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n}\n\nfunction listWeekdaysMin (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n}\n\ngetSetGlobalLocale('en', {\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal : function (number) {\n        var b = number % 10,\n            output = (toInt(number % 100 / 10) === 1) ? 'th' :\n            (b === 1) ? 'st' :\n            (b === 2) ? 'nd' :\n            (b === 3) ? 'rd' : 'th';\n        return number + output;\n    }\n});\n\n// Side effect imports\nhooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\nhooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\nvar mathAbs = Math.abs;\n\nfunction abs () {\n    var data           = this._data;\n\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days         = mathAbs(this._days);\n    this._months       = mathAbs(this._months);\n\n    data.milliseconds  = mathAbs(data.milliseconds);\n    data.seconds       = mathAbs(data.seconds);\n    data.minutes       = mathAbs(data.minutes);\n    data.hours         = mathAbs(data.hours);\n    data.months        = mathAbs(data.months);\n    data.years         = mathAbs(data.years);\n\n    return this;\n}\n\nfunction addSubtract$1 (duration, input, value, direction) {\n    var other = createDuration(input, value);\n\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days         += direction * other._days;\n    duration._months       += direction * other._months;\n\n    return duration._bubble();\n}\n\n// supports only 2.0-style add(1, 's') or add(duration)\nfunction add$1 (input, value) {\n    return addSubtract$1(this, input, value, 1);\n}\n\n// supports only 2.0-style subtract(1, 's') or subtract(duration)\nfunction subtract$1 (input, value) {\n    return addSubtract$1(this, input, value, -1);\n}\n\nfunction absCeil (number) {\n    if (number < 0) {\n        return Math.floor(number);\n    } else {\n        return Math.ceil(number);\n    }\n}\n\nfunction bubble () {\n    var milliseconds = this._milliseconds;\n    var days         = this._days;\n    var months       = this._months;\n    var data         = this._data;\n    var seconds, minutes, hours, years, monthsFromDays;\n\n    // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n            (milliseconds <= 0 && days <= 0 && months <= 0))) {\n        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n        days = 0;\n        months = 0;\n    }\n\n    // The following code bubbles up values, see the tests for\n    // examples of what that means.\n    data.milliseconds = milliseconds % 1000;\n\n    seconds           = absFloor(milliseconds / 1000);\n    data.seconds      = seconds % 60;\n\n    minutes           = absFloor(seconds / 60);\n    data.minutes      = minutes % 60;\n\n    hours             = absFloor(minutes / 60);\n    data.hours        = hours % 24;\n\n    days += absFloor(hours / 24);\n\n    // convert days to months\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays));\n\n    // 12 months -> 1 year\n    years = absFloor(months / 12);\n    months %= 12;\n\n    data.days   = days;\n    data.months = months;\n    data.years  = years;\n\n    return this;\n}\n\nfunction daysToMonths (days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n}\n\nfunction monthsToDays (months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n}\n\nfunction as (units) {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    var days;\n    var months;\n    var milliseconds = this._milliseconds;\n\n    units = normalizeUnits(units);\n\n    if (units === 'month' || units === 'year') {\n        days   = this._days   + milliseconds / 864e5;\n        months = this._months + daysToMonths(days);\n        return units === 'month' ? months : months / 12;\n    } else {\n        // handle milliseconds separately because of floating point math errors (issue #1867)\n        days = this._days + Math.round(monthsToDays(this._months));\n        switch (units) {\n            case 'week'   : return days / 7     + milliseconds / 6048e5;\n            case 'day'    : return days         + milliseconds / 864e5;\n            case 'hour'   : return days * 24    + milliseconds / 36e5;\n            case 'minute' : return days * 1440  + milliseconds / 6e4;\n            case 'second' : return days * 86400 + milliseconds / 1000;\n            // Math.floor prevents floating point math errors here\n            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n            default: throw new Error('Unknown unit ' + units);\n        }\n    }\n}\n\n// TODO: Use this.as('ms')?\nfunction valueOf$1 () {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    return (\n        this._milliseconds +\n        this._days * 864e5 +\n        (this._months % 12) * 2592e6 +\n        toInt(this._months / 12) * 31536e6\n    );\n}\n\nfunction makeAs (alias) {\n    return function () {\n        return this.as(alias);\n    };\n}\n\nvar asMilliseconds = makeAs('ms');\nvar asSeconds      = makeAs('s');\nvar asMinutes      = makeAs('m');\nvar asHours        = makeAs('h');\nvar asDays         = makeAs('d');\nvar asWeeks        = makeAs('w');\nvar asMonths       = makeAs('M');\nvar asYears        = makeAs('y');\n\nfunction clone$1 () {\n    return createDuration(this);\n}\n\nfunction get$2 (units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n}\n\nfunction makeGetter(name) {\n    return function () {\n        return this.isValid() ? this._data[name] : NaN;\n    };\n}\n\nvar milliseconds = makeGetter('milliseconds');\nvar seconds      = makeGetter('seconds');\nvar minutes      = makeGetter('minutes');\nvar hours        = makeGetter('hours');\nvar days         = makeGetter('days');\nvar months       = makeGetter('months');\nvar years        = makeGetter('years');\n\nfunction weeks () {\n    return absFloor(this.days() / 7);\n}\n\nvar round = Math.round;\nvar thresholds = {\n    ss: 44,         // a few seconds to seconds\n    s : 45,         // seconds to minute\n    m : 45,         // minutes to hour\n    h : 22,         // hours to day\n    d : 26,         // days to month\n    M : 11          // months to year\n};\n\n// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\nfunction substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n}\n\nfunction relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n    var duration = createDuration(posNegDuration).abs();\n    var seconds  = round(duration.as('s'));\n    var minutes  = round(duration.as('m'));\n    var hours    = round(duration.as('h'));\n    var days     = round(duration.as('d'));\n    var months   = round(duration.as('M'));\n    var years    = round(duration.as('y'));\n\n    var a = seconds <= thresholds.ss && ['s', seconds]  ||\n            seconds < thresholds.s   && ['ss', seconds] ||\n            minutes <= 1             && ['m']           ||\n            minutes < thresholds.m   && ['mm', minutes] ||\n            hours   <= 1             && ['h']           ||\n            hours   < thresholds.h   && ['hh', hours]   ||\n            days    <= 1             && ['d']           ||\n            days    < thresholds.d   && ['dd', days]    ||\n            months  <= 1             && ['M']           ||\n            months  < thresholds.M   && ['MM', months]  ||\n            years   <= 1             && ['y']           || ['yy', years];\n\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n}\n\n// This function allows you to set the rounding function for relative time strings\nfunction getSetRelativeTimeRounding (roundingFunction) {\n    if (roundingFunction === undefined) {\n        return round;\n    }\n    if (typeof(roundingFunction) === 'function') {\n        round = roundingFunction;\n        return true;\n    }\n    return false;\n}\n\n// This function allows you to set a threshold for relative time strings\nfunction getSetRelativeTimeThreshold (threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n        return false;\n    }\n    if (limit === undefined) {\n        return thresholds[threshold];\n    }\n    thresholds[threshold] = limit;\n    if (threshold === 's') {\n        thresholds.ss = limit - 1;\n    }\n    return true;\n}\n\nfunction humanize (withSuffix) {\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var locale = this.localeData();\n    var output = relativeTime$1(this, !withSuffix, locale);\n\n    if (withSuffix) {\n        output = locale.pastFuture(+this, output);\n    }\n\n    return locale.postformat(output);\n}\n\nvar abs$1 = Math.abs;\n\nfunction sign(x) {\n    return ((x > 0) - (x < 0)) || +x;\n}\n\nfunction toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var seconds = abs$1(this._milliseconds) / 1000;\n    var days         = abs$1(this._days);\n    var months       = abs$1(this._months);\n    var minutes, hours, years;\n\n    // 3600 seconds -> 60 minutes -> 1 hour\n    minutes           = absFloor(seconds / 60);\n    hours             = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60;\n\n    // 12 months -> 1 year\n    years  = absFloor(months / 12);\n    months %= 12;\n\n\n    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n    var Y = years;\n    var M = months;\n    var D = days;\n    var h = hours;\n    var m = minutes;\n    var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n    var total = this.asSeconds();\n\n    if (!total) {\n        // this is the same as C#'s (Noda) and python (isodate)...\n        // but not other JS (goog.date)\n        return 'P0D';\n    }\n\n    var totalSign = total < 0 ? '-' : '';\n    var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n    var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n    return totalSign + 'P' +\n        (Y ? ymSign + Y + 'Y' : '') +\n        (M ? ymSign + M + 'M' : '') +\n        (D ? daysSign + D + 'D' : '') +\n        ((h || m || s) ? 'T' : '') +\n        (h ? hmsSign + h + 'H' : '') +\n        (m ? hmsSign + m + 'M' : '') +\n        (s ? hmsSign + s + 'S' : '');\n}\n\nvar proto$2 = Duration.prototype;\n\nproto$2.isValid        = isValid$1;\nproto$2.abs            = abs;\nproto$2.add            = add$1;\nproto$2.subtract       = subtract$1;\nproto$2.as             = as;\nproto$2.asMilliseconds = asMilliseconds;\nproto$2.asSeconds      = asSeconds;\nproto$2.asMinutes      = asMinutes;\nproto$2.asHours        = asHours;\nproto$2.asDays         = asDays;\nproto$2.asWeeks        = asWeeks;\nproto$2.asMonths       = asMonths;\nproto$2.asYears        = asYears;\nproto$2.valueOf        = valueOf$1;\nproto$2._bubble        = bubble;\nproto$2.clone          = clone$1;\nproto$2.get            = get$2;\nproto$2.milliseconds   = milliseconds;\nproto$2.seconds        = seconds;\nproto$2.minutes        = minutes;\nproto$2.hours          = hours;\nproto$2.days           = days;\nproto$2.weeks          = weeks;\nproto$2.months         = months;\nproto$2.years          = years;\nproto$2.humanize       = humanize;\nproto$2.toISOString    = toISOString$1;\nproto$2.toString       = toISOString$1;\nproto$2.toJSON         = toISOString$1;\nproto$2.locale         = locale;\nproto$2.localeData     = localeData;\n\n// Deprecations\nproto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\nproto$2.lang = lang;\n\n// Side effect imports\n\n// FORMATTING\n\naddFormatToken('X', 0, 0, 'unix');\naddFormatToken('x', 0, 0, 'valueOf');\n\n// PARSING\n\naddRegexToken('x', matchSigned);\naddRegexToken('X', matchTimestamp);\naddParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input, 10) * 1000);\n});\naddParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n});\n\n// Side effect imports\n\n\nhooks.version = '2.20.1';\n\nsetHookCallback(createLocal);\n\nhooks.fn                    = proto;\nhooks.min                   = min;\nhooks.max                   = max;\nhooks.now                   = now;\nhooks.utc                   = createUTC;\nhooks.unix                  = createUnix;\nhooks.months                = listMonths;\nhooks.isDate                = isDate;\nhooks.locale                = getSetGlobalLocale;\nhooks.invalid               = createInvalid;\nhooks.duration              = createDuration;\nhooks.isMoment              = isMoment;\nhooks.weekdays              = listWeekdays;\nhooks.parseZone             = createInZone;\nhooks.localeData            = getLocale;\nhooks.isDuration            = isDuration;\nhooks.monthsShort           = listMonthsShort;\nhooks.weekdaysMin           = listWeekdaysMin;\nhooks.defineLocale          = defineLocale;\nhooks.updateLocale          = updateLocale;\nhooks.locales               = listLocales;\nhooks.weekdaysShort         = listWeekdaysShort;\nhooks.normalizeUnits        = normalizeUnits;\nhooks.relativeTimeRounding  = getSetRelativeTimeRounding;\nhooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\nhooks.calendarFormat        = getCalendarFormat;\nhooks.prototype             = proto;\n\n// currently HTML5 input type only supports 24-hour formats\nhooks.HTML5_FMT = {\n    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n    DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n    TIME: 'HH:mm',                                  // <input type=\"time\" />\n    TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n    TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n    WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n    MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n};\n\nreturn hooks;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/moment/moment.js\n// module id = 38\n// module chunks = 35783957827783 115261235868047 170264817138936","import React from 'react'\r\nimport styled from 'styled-components'\r\nimport Container from './container'\r\nimport SectionHeader from './sectionHeader'\r\nimport timeline from '../images/timeline.svg'\r\nimport allocationImg from '../images/ill_allocation.svg'\r\nimport Timer from './timer'\r\n\r\nconst Header = styled.header`\r\n  display: flex;\r\n  justify-content: space-between;\r\n  margin-top: 4rem;\r\n\r\n  section {\r\n    ${'' /* max-width: 420px; */};\r\n  }\r\n\r\n  p {\r\n    font-weight: 300;\r\n    line-height: 2rem;\r\n  }\r\n\r\n  aside {\r\n  }\r\n\r\n  h3 {\r\n    font-size: 2rem;\r\n  }\r\n\r\n  h4 {\r\n    text-transform: uppercase;\r\n    color: #278cd6;\r\n    font-size: 0.8rem;\r\n    margin-bottom: 0;\r\n  }\r\n\r\n  time {\r\n    font-size: 2rem;\r\n    letter-spacing: 0.2rem;\r\n  }\r\n\r\n  a:link,\r\n  a:visited {\r\n    background-color: #278cd6;\r\n    color: #fff;\r\n    border: none;\r\n    border-radius: 48px;\r\n    text-transform: uppercase;\r\n    font-weight: bold;\r\n    font-size: 0.8rem;\r\n    padding: 12px 24px;\r\n    letter-spacing: 0.1rem;\r\n\r\n    &:link,\r\n    &:visited {\r\n      text-decoration: none;\r\n    }\r\n  }\r\n\r\n  form {\r\n    border: thin solid #278cd6;\r\n    border-radius: 3rem;\r\n    height: 3rem;\r\n    display: flex;\r\n\r\n    input {\r\n      flex: 1;\r\n      border: none;\r\n      margin-left: 1.5rem;\r\n      font-family: 'Open Sans';\r\n      font-weight: 300;\r\n\r\n      input::placeholder {\r\n        opacity: 0.34;\r\n        font-size: 0.8rem;\r\n      }\r\n\r\n      &:focus {\r\n        outline: none;\r\n      }\r\n    }\r\n\r\n    button {\r\n      color: #fff;\r\n      background-color: #278cd6;\r\n      border: none;\r\n      border-radius: 3rem;\r\n      padding: 0 2rem;\r\n      text-transform: uppercase;\r\n      font-size: 0.8rem;\r\n      font-weight: 700;\r\n    }\r\n  }\r\n\r\n  @media (max-width: 640px) {\r\n    flex-direction: column;\r\n    align-items: center;\r\n  }\r\n`\r\n\r\nconst CrowdsaleInfo = styled.div`\r\n  background-color: #f7f7f9;\r\n  padding-top: 100px;\r\n  position: relative;\r\n\r\n  &:before {\r\n    background: #fff;\r\n    height: 200px;\r\n    clip-path: ellipse(100% 50% at 50% -40%);\r\n    width: 100%;\r\n    content: '';\r\n    display: block;\r\n    position: absolute;\r\n    top: 0;\r\n    z-index: 1;\r\n  }\r\n\r\n  h2 {\r\n    text-align: center;\r\n    margin-bottom: 4rem;\r\n    font-size: 2rem;\r\n  }\r\n\r\n  section {\r\n    display: flex;\r\n    justify-content: space-between;\r\n  }\r\n\r\n  h3 {\r\n    font-family: 'Open Sans';\r\n    font-weight: 700;\r\n    font-size: 0.9rem;\r\n    text-align: center;\r\n  }\r\n\r\n  aside {\r\n    font-size: 0.8rem;\r\n    flex-basis: calc(50% - 1rem);\r\n  }\r\n\r\n  table {\r\n    font-size: 0.8rem;\r\n  }\r\n\r\n  img {\r\n    margin: 0 1rem;\r\n    width: calc(100% - 2rem);\r\n  }\r\n\r\n  @media (max-width: 640px) {\r\n    section {\r\n      flex-direction: column;\r\n    }\r\n\r\n    aside {\r\n      flex-basis: 100%;\r\n      margin-bottom: 2rem;\r\n    }\r\n  }\r\n`\r\n\r\nconst Timeline = styled.div`\r\n  text-align: center;\r\n  h2 {\r\n    margin: 4rem auto;\r\n    font-size: 2rem;\r\n  }\r\n\r\n  img {\r\n    margin: 4rem;\r\n    max-width: 540px;\r\n  }\r\n`\r\n\r\nclass Presale extends React.Component {\r\n  state = {\r\n    thanks: false,\r\n    email: ''\r\n  }\r\n\r\n  _submit = event => {\r\n    event.preventDefault()\r\n    const email = encodeURIComponent(this.state.email)\r\n    const url = `https://script.google.com/a/suncoast.io/macros/s/AKfycbx5j3f48_i0layRQ8mKhBwVo-wJSuu-XHNMXc77kKPC9pGhob5P/exec?email=${email}`\r\n    window.fetch(url, { method: 'GET' })\r\n    this.setState({ thanks: true, email: '' })\r\n  }\r\n\r\n  _change = event => {\r\n    this.setState({ email: event.target.value })\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Container>\r\n          <SectionHeader>Presale</SectionHeader>\r\n          <Header>\r\n            {this.state.thanks ? (\r\n              <div>\r\n                <h3>\r\n                  <strong>Thanks</strong>, we'll be in touch.\r\n                </h3>\r\n              </div>\r\n            ) : (\r\n              <section>\r\n                <h3>\r\n                  The presale is open until April 26<sup>th</sup>.\r\n                </h3>\r\n                <p>To purchase VRS, create your wallet and exchange NEO or ETH for VRS:</p>\r\n                <p>\r\n                  <a href=\"https://ico.verisfoundation.com/\">Get Started</a>\r\n                </p>\r\n                <p>Stay informed about Veris:</p>\r\n                <form action=\"\" onSubmit={this._submit}>\r\n                  <input required type=\"email\" placeholder=\"Enter Your Email\" onChange={this._change} />\r\n                  <button type=\"submit\">Submit</button>\r\n                </form>\r\n              </section>\r\n            )}\r\n          </Header>\r\n        </Container>\r\n        <CrowdsaleInfo>\r\n          <Container>\r\n            <h2>Veris Foundation Crowdsale Info</h2>\r\n            <section>\r\n              <aside>\r\n                <h3>Overview</h3>\r\n                <table>\r\n                  <tbody>\r\n                    <tr>\r\n                      <th>Presale Timeline</th>\r\n                      <td>Mar 19th, 2018 - Apr 26, 2018</td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>ICO Timeline</th>\r\n                      <td>Apr 30th, 2018 - Jul 30, 2018</td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>VRS Total Supply</th>\r\n                      <td>50,000,000</td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>Presale + ICO Allocation</th>\r\n                      <td>30,000,000</td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>Presale Price (25% bonus)</th>\r\n                      <td>\r\n                        1 NEO = 100 VRS<br />\r\n                        1 ETH = (ETH-USD/NEO-USD) * 100 VRS\r\n                      </td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>ICO Price</th>\r\n                      <td>\r\n                        1 NEO = 80 VRS<br />\r\n                        1 ETH = (ETH-USD/NEO-USD) * 80 VRS\r\n                      </td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>Minimum Cap</th>\r\n                      <td>9,000 ETH / 28,000 NEO</td>\r\n                    </tr>\r\n                    <tr>\r\n                      <th>Maximum Cap</th>\r\n                      <td>90,000 ETH / 270,000 NEO</td>\r\n                    </tr>\r\n                  </tbody>\r\n                </table>\r\n              </aside>\r\n\r\n              <aside>\r\n                <h3>Allocation</h3>\r\n\r\n                <img src={allocationImg} width=\"400\" />\r\n              </aside>\r\n            </section>\r\n          </Container>\r\n        </CrowdsaleInfo>\r\n        <Timeline>\r\n          <Container>\r\n            <h2>Veris Project Timeline</h2>\r\n            <img src={timeline} />\r\n          </Container>\r\n        </Timeline>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Presale\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/presale.js","import React from 'react'\r\nimport moment from 'moment'\r\nimport momentDurationFormat from 'moment-duration-format'\r\n\r\nmomentDurationFormat(moment)\r\n\r\nclass Timer extends React.Component {\r\n  state = {\r\n    remaining: moment.duration(0)\r\n  }\r\n\r\n  componentWillMount() {\r\n    this.tick()\r\n    this.timer = setInterval(() => this.tick(), 1000)\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    clearInterval(this.timer)\r\n  }\r\n\r\n  tick() {\r\n    const remaining = moment.duration(-1 * moment().diff(this.props.to))\r\n    this.setState({ remaining })\r\n  }\r\n\r\n  render() {\r\n    const { remaining } = this.state\r\n    return <time>{remaining.format('DD:HH:mm:ss', { trim: false })}</time>\r\n  }\r\n}\r\n\r\nexport default Timer\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/timer.js","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMi4wLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA0MDAgNjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDojQ0EwMDAwO30NCgkuc3Qxe2ZpbGw6I0NEMDBDQTt9DQoJLnN0MntmaWxsOiMxODAwMDE7fQ0KCS5zdDN7ZmlsbDojMDBCRDVDO30NCgkuc3Q0e2ZpbGw6IzI3OENENjt9DQoJLnN0NXtmaWxsOiMwRjM1NTI7fQ0KCS5zdDZ7Zm9udC1mYW1pbHk6J09wZW5TYW5zJzt9DQoJLnN0N3tmb250LXNpemU6MTRweDt9DQo8L3N0eWxlPg0KPGc+DQoJPHBhdGggY2xhc3M9InN0MCIgZD0iTTE5Mi40LDEwNUMxOTIuNSwxMDUsMTkyLjUsMTA1LDE5Mi40LDEwNWwwLjEtNTUuM2MtNS45LDAtMTIuNSwwLjUtMTguMywxLjNsNy43LDU0LjYNCgkJQzE4NS4zLDEwNS4yLDE4OC45LDEwNSwxOTIuNCwxMDV6Ii8+DQoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTE3Ny41LDg5LjJsLTUuMy0zNy45Yy0xMiwxLjctMjEuMiw0LjItMzIuNCw4LjdsMjAuNiw1MWM2LjItMi40LDEyLjctNC4xLDE5LjUtNS4xTDE3Ny41LDg5LjJ6Ii8+DQoJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIxNzIuMiw1MS4zIDE3Mi4yLDUxLjMgMTc3LjUsODkuMiAJIi8+DQoJPHBhdGggY2xhc3M9InN0MyIgZD0iTTE1OC41LDExMS43bC0yMC42LTUxYy0yMy4xLDkuNS00MS4zLDIzLTU3LjIsNDIuM2w0Mi44LDM0LjdDMTMyLjgsMTI2LjQsMTQ0LjgsMTE3LjQsMTU4LjUsMTExLjd6Ii8+DQoJPHBhdGggY2xhc3M9InN0NCIgZD0iTTEwMy40LDE5NGMwLTIwLjYsNy0zOS42LDE4LjktNTQuN2wtNDIuOC0zNC43Yy0xLjYsMi0yLjMsMy00LDUuM0MyOC40LDE3NC43LDQyLjYsMjY1LjcsMTA3LDMxMy4ybDMzLjktNDYuNw0KCQlDMTE4LjIsMjUwLjMsMTAzLjQsMjIzLjgsMTAzLjQsMTk0eiIvPg0KCTxwYXRoIGNsYXNzPSJzdDUiIGQ9Ik0yODEuNCwxOTRjMCw0OS4xLTM5LjksODktODksODljLTE4LjUsMC0zNS43LTUuNy01MC0xNS40bC0zMy45LDQ2LjdjMjUuOSwxOC42LDUzLDI3LjMsODUsMjcuMw0KCQljODAuNSwwLDE0NS45LTY1LjUsMTQ1LjktMTQ1LjljMC04MC4xLTY0LjktMTQ1LjQtMTQ0LjktMTQ1LjlWMTA1QzI0Mi42LDEwNi4xLDI4MS40LDE0NS42LDI4MS40LDE5NHoiLz4NCjwvZz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDE1LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+UHVibGljIENvbnRyaWJ1dG9yczwvdGV4dD4NCjxjaXJjbGUgY2xhc3M9InN0NSIgY3g9IjE5LjciIGN5PSI0MTkiIHI9IjkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDM1LjY2NykiIGNsYXNzPSJzdDYgc3Q3Ij4zMG0gVlJTIC8gNjAlIDwvdGV4dD4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDc2LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+VmVyaXMgRm91bmRhdGlvbjwvdGV4dD4NCjxjaXJjbGUgY2xhc3M9InN0NCIgY3g9IjE5LjciIGN5PSI0ODAiIHI9IjkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNDk2LjY2NykiIGNsYXNzPSJzdDYgc3Q3Ij4xM20gVlJTIC8gMjYlIDwvdGV4dD4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMzkuNjYgNTM4LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+VmVyaXMgQ29yZSBUZWFtPC90ZXh0Pg0KPGNpcmNsZSBjbGFzcz0ic3QzIiBjeD0iMTkuNyIgY3k9IjU0MiIgcj0iOSIvPg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAzOS42NiA1NTguNjY3KSIgY2xhc3M9InN0NiBzdDciPjRtIFZSUyAvIDglIDwvdGV4dD4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjQzLjY2IDQxNS42Mzk2KSIgY2xhc3M9InN0NiBzdDciPlBhcnRuZXJzaGlwICZhbXA7IEFkdmlzb3J5PC90ZXh0Pg0KPGNpcmNsZSBjbGFzcz0ic3QxIiBjeD0iMjIzLjciIGN5PSI0MTkiIHI9IjkiLz4NCjx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjQzLjY2IDQzNS42NjcpIiBjbGFzcz0ic3Q2IHN0NyI+Mm0gVlJTIC8gNCUgPC90ZXh0Pg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNDMuNjYgNDc2LjYzOTYpIiBjbGFzcz0ic3Q2IHN0NyI+Qm91bnRpZXM8L3RleHQ+DQo8Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSIyMjMuNyIgY3k9IjQ4MCIgcj0iOSIvPg0KPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNDMuNjYgNDk2LjY2NykiIGNsYXNzPSJzdDYgc3Q3Ij4xbSBWUlMgLyAyJSA8L3RleHQ+DQo8L3N2Zz4NCg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/images/ill_allocation.svg\n// module id = 653\n// module chunks = 115261235868047","module.exports = __webpack_public_path__ + \"static/timeline.c5db9b43.svg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/images/timeline.svg\n// module id = 682\n// module chunks = 115261235868047","import React from 'react'\r\nimport Whitepaper from '../components/whitepaper'\r\nimport Presale from '../components/presale'\r\n\r\nexport default () => (\r\n  <div>\r\n    <Presale />\r\n    <Whitepaper />\r\n  </div>\r\n)\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/presale.js"],"sourceRoot":""}